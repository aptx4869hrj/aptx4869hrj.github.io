<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>端木胥的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.duanmuxu.top/"/>
  <updated>2019-06-02T04:31:29.751Z</updated>
  <id>http://www.duanmuxu.top/</id>
  
  <author>
    <name>端木胥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>罗马数字转化为阿拉伯数字</title>
    <link href="http://www.duanmuxu.top/20190602/roman-numerals-are-converted-to-arabic.html"/>
    <id>http://www.duanmuxu.top/20190602/roman-numerals-are-converted-to-arabic.html</id>
    <published>2019-06-02T04:28:32.282Z</published>
    <updated>2019-06-02T04:31:29.751Z</updated>
    
    <content type="html"><![CDATA[<p>题目简述：</p><hr><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. </p><hr><p>简而言之，从I到M七个字母分别代表着1~1000的七种不同大小。当所给罗马数字的字母顺序为从M到I的顺序排列时，它的值即为其字母所代表的值相加，比如’XXVII’，即表示X+X+V+I+I。当所给罗马数字字符串中有一个字母比这个字母其后的字母所表示的值小时，这两个字母结合起来代表一个数值，其值为（后一个字母的值-前一个字母的值），比如’MCD’，C的值比D小，因此等于M+CD=1000+500-100=1400。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实经过分析过后思路就很明确了，比较所给字符串中当前字母和下一个字母的数值大小，如果当前字母的值比下一个字母的值大，直接相加，反之则后一个字母的值减去当前字母的值，并将这两个字母当作一个整体。</p><p>有了思路，就得有解题方法。既然是涉及到前后两个字母进行比较，那么就有两种情况，<strong>一种是获取当前字母的值，与后一个字母进行比较；一种是保存前一个字母的值，与当前字母的值进行比较。</strong></p><hr><h4 id="当前字母与前一个字母相比较"><a href="#当前字母与前一个字母相比较" class="headerlink" title="当前字母与前一个字母相比较"></a>当前字母与前一个字母相比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        a[&apos;I&apos; - &apos;A&apos;] = 1;</span><br><span class="line">        a[&apos;V&apos; - &apos;A&apos;] = 5;</span><br><span class="line">        a[&apos;X&apos; - &apos;A&apos;] = 10;</span><br><span class="line">        a[&apos;L&apos; - &apos;A&apos;] = 50;</span><br><span class="line">        a[&apos;C&apos; - &apos;A&apos;] = 100;</span><br><span class="line">        a[&apos;D&apos; - &apos;A&apos;] = 500;</span><br><span class="line">        a[&apos;M&apos; - &apos;A&apos;] = 1000;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        char prev = &apos;A&apos;;</span><br><span class="line">        for (char str : s.toCharArray()) &#123;</span><br><span class="line">            if(a[str - &apos;A&apos;] &gt; a[prev - &apos;A&apos;])&#123;</span><br><span class="line">                sum = sum - 2*a[prev - &apos;A&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            sum = sum + a[str - &apos;A&apos;];</span><br><span class="line">            prev = str;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法foreach中，当前值为str，保存的前一个字母为prev。当当前字母的值大于前一个字母的值时，整体总数sum减去前一个字母的值的两倍（一倍拿来消除之前加过的前一个字母的值，一倍拿来做整体两个字母的减数）。从而得出结果。</p><hr><h4 id="当前字母与后一个字母相比较"><a href="#当前字母与后一个字母相比较" class="headerlink" title="当前字母与后一个字母相比较"></a>当前字母与后一个字母相比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; chara = new HashMap&lt;&gt;();</span><br><span class="line">        chara.put(&apos;I&apos;, 1);</span><br><span class="line">        chara.put(&apos;V&apos;, 5);</span><br><span class="line">        chara.put(&apos;X&apos;, 10);</span><br><span class="line">        chara.put(&apos;L&apos;, 50);</span><br><span class="line">        chara.put(&apos;C&apos;, 100);</span><br><span class="line">        chara.put(&apos;D&apos;, 500);</span><br><span class="line">        chara.put(&apos;M&apos;, 1000);</span><br><span class="line"></span><br><span class="line">        int sum = 0; //定义总数</span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(i &lt; s.length()-1 &amp;&amp; chara.get(s.charAt(i)) &lt; chara.get(s.charAt(i+1)))&#123;</span><br><span class="line">                sum = sum - chara.get(s.charAt(i));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum = sum + chara.get(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Map进行存储，当时使用数组也可以，只是为了<strong>存储多元化</strong>。这种方法要注意charAt的界限，防止越界。当当前的字母的值大于下一个字母的值时，正常相加；反之则总数sum减去当前字母的值。</p><p>有一点值得注意的是if的条件中有个<em>i &lt; s.length()-1</em>，即为了防止越界我们作比较只比较到了字符串的倒数第二个字母，最后一个字母的值是直接相加的。因为最后一个字母无需与其后的字母相比较，因此此种方法可行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目简述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Symbol&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>两个字符串中含有几个相同字符的几种解法</title>
    <link href="http://www.duanmuxu.top/20190602/several-solutions-for-identical-characters-in-two-strings.html"/>
    <id>http://www.duanmuxu.top/20190602/several-solutions-for-identical-characters-in-two-strings.html</id>
    <published>2019-06-02T04:28:32.281Z</published>
    <updated>2019-06-02T04:31:29.751Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。<br><br><br>进入正题，题目如下：</p><blockquote><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br><br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.<br><br>Example 1:<br>Input: <br>J = “aA”,<br> S = “aAAbbbb”<br>Output: 3<br><br>Example 2:<br>Input: <br>J = “z”,<br> S = “ZZ”<br>Output: 0<br><br>Note:<br>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p></blockquote><h4 id="简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。"><a href="#简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。" class="headerlink" title="简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。"></a>简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。</h4><hr><blockquote><p><em>以下方法全是基于Java进行实现</em></p></blockquote><p>先放我的方法：</p><h3 id="方法一：将字符串转化成数组"><a href="#方法一：将字符串转化成数组" class="headerlink" title="方法一：将字符串转化成数组"></a>方法一：将字符串转化成数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        char[] Ja = J.toCharArray();</span><br><span class="line">        char[] Sa = S.toCharArray();</span><br><span class="line">        int r = 0;</span><br><span class="line">        for (int i = 0;i &lt; Ja.length ; i ++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; Sa.length; j++)&#123;</span><br><span class="line">                if(Ja[i] == Sa[j])</span><br><span class="line">                    r ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先将J和S字符串转化成两个数组</li><li>对J的数组进行遍历，再对S的数组进行遍历</li><li>如果J中的字母与S中的字母相等（区分大小写），累加器r就加一</li><li>最后输出r即可</li></ul><br>&nbsp;&nbsp;&nbsp;&nbsp;很简单的一道题，当时想着继续刷题吧，反正刷题网站的意义就在于刷刷刷。不过还好打开了这道题的评论区，让我看到了一个新的世界。评论里有着许许多多其他不同的解题方法。这才是刷题网站的意义，**给一道题以不同的解题思路，让每个人都能有多种不同的思考。**<br>&nbsp;&nbsp;&nbsp;&nbsp;以下是本道题评论区中给出的其他解题方法，亲测有效<h3 id="方法二：字符串直接进行比较"><a href="#方法二：字符串直接进行比较" class="headerlink" title="方法二：字符串直接进行比较"></a>方法二：字符串直接进行比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for (int i=0;i&lt;J.length();i++)&#123;</span><br><span class="line">            for (int j=0;j&lt;S.length();j++)&#123;</span><br><span class="line">                if (S.charAt(j) == J.charAt(i))&#123;</span><br><span class="line">                    count+=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其实和方法一差不大多，直接<strong>对字符串进行循环比较</strong>。最开始我也想用这方法，不过忘了charAt方法，不能确定字符串某个位置上的字母，于是换成了方法一。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;另一种直接比较方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        int count =0;</span><br><span class="line">        for (int i =0;i&lt;S.length();i++)&#123;</span><br><span class="line">            if (J.contains(String.valueOf(S.charAt(i))))&#123;</span><br><span class="line">                count++;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是循环比较，少了层for循环而已，不再赘述。</p><h3 id="方法三：正则表达式"><a href="#方法三：正则表达式" class="headerlink" title="方法三：正则表达式"></a>方法三：正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">    return S.replaceAll(&quot;[^&quot; + J + &quot;]&quot;, &quot;&quot;).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太狠了，这方法太狠了，一行解决事情。先介绍一下什么是正则表达式：</p><blockquote><p>正则表达式是对字符串（包括普通字符（例如，a到z之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。</p></blockquote><p>判断S字符串中有多少能被J字符串所替换的字符，将这些字符的长度输出就是答案。太狠了。<br><br><strong>不过这种方法时间会占用更多。</strong></p><h3 id="方法四：Hash-Set方法"><a href="#方法四：Hash-Set方法" class="headerlink" title="方法四：Hash Set方法"></a>方法四：Hash Set方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (char c : J.toCharArray()) </span><br><span class="line">            set.add(c);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (char c : S.toCharArray()) </span><br><span class="line">            if (set.contains(c)) </span><br><span class="line">                res++;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Hash Set就是用来提高查找效率的</strong>，将J字符串中的字母放在set中，判断S字符串中的字母知否包含在set中，是则累加器res加一，最后输出。<strong>这种方法运行效率也高。</strong></p><hr><p>问：为什么不是将S字符串的字符存入set中？<br><br>答：Hash Set不能存入相同的元素。以例子一为例，S字符串为：S = “aAAbbbb”，”A”有两个，”b”有四个，最后存入set后，set的长度为3，即存入元素为”a”,”A,”b”，因为字符串直接存入set里时，相同元素的HashCode是一样的，就会跳过重复的字符。这时与J字符串相比较，就只有”a”,”A”相匹配，输出结果为2，答案错误。</p><h3 id="方法五：ASCII值转换"><a href="#方法五：ASCII值转换" class="headerlink" title="方法五：ASCII值转换"></a>方法五：ASCII值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int[] arr = new int[&apos;z&apos; - &apos;A&apos; + 1];</span><br><span class="line">    for (char c : J.toCharArray()) </span><br><span class="line">        arr[c - &apos;A&apos;] = 1;</span><br><span class="line">    for (char c : S.toCharArray()) </span><br><span class="line">        count += arr[c - &apos;A&apos;];</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个arr数组，大小为A的ASCII的值（65）到z的ASCII的值（122）的范围，中间有些特殊字符也占用了空间，不过没关系，不碍事。然后将J字符串中的字符也转成ASCII值，并将以该字符的ASCII值（与A相减过后的值，不然会溢出）为角标的数组值设为1，再对S字符串进行循环，累加器count一直与角标为S串中的字符的ASCII值的arr数组的值相加，最后结果输出即可。也是一种转换思维。</p><h3 id="方法六：Hash-Map方法"><a href="#方法六：Hash-Map方法" class="headerlink" title="方法六：Hash Map方法"></a>方法六：Hash Map方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(char s : S.toCharArray())</span><br><span class="line">            map.put(s, map.getOrDefault(s, 0) + 1);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; J.length(); i++)</span><br><span class="line">            count += map.getOrDefault(J.charAt(i), 0);</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashSet方法更简洁，详情参见方法四。</p><hr><p>暂时放这一些方法，有看到新的再更新，继续学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。&lt;br&gt;&lt;br&gt;&lt;br&gt;进入正题，题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You’re given strings J represen
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://www.duanmuxu.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第k个结点</title>
    <link href="http://www.duanmuxu.top/20190602/the-kth-node-in-list.html"/>
    <id>http://www.duanmuxu.top/20190602/the-kth-node-in-list.html</id>
    <published>2019-06-02T04:28:32.279Z</published>
    <updated>2019-06-02T04:31:29.754Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p>链表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由链表结构就能知道由此基础建立的链表不能直接知道该链表的长度，需要通过node = node.next 一步一步遍历链表才能获取链表长度。</p><p>因此最先想到的方法就是<strong>先遍历一遍链表，获取链表长度，然后通过链表长度和k数值的差得出目标地址</strong>。实现方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        ListNode newHead = head, pre = head;</span><br><span class="line">        int count = 0; // 获取链表长度</span><br><span class="line">        while(pre != null)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count &lt; k) // 不存在倒数第k个链表</span><br><span class="line">            return null;</span><br><span class="line">        else&#123;</span><br><span class="line">            int num = count - k; // num为正数的目的地址，与倒数第k个链表值一致</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            return newHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了基础思路，下一步就是简化代码，用更简洁的表达将效果呈现出来。以下使用for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123; //5,&#123;1,2,3,4,5&#125;</span><br><span class="line">        ListNode p, q;</span><br><span class="line">        p = q = head;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; p != null; i++) &#123;</span><br><span class="line">            if (i &gt;= k) </span><br><span class="line">                q = q.next;</span><br><span class="line">            p = p.next; // p相当于上面的pre链表，用于测量链表长度</span><br><span class="line">        &#125;</span><br><span class="line">        return i &lt;= k ? null : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<strong>while一次遍历</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        ListNode pre=null,p=null;</span><br><span class="line">        //两个指针都指向头结点</span><br><span class="line">        p=head;</span><br><span class="line">        pre=head;</span><br><span class="line">        //记录k值</span><br><span class="line">        int a=k;</span><br><span class="line">        //记录节点的个数</span><br><span class="line">        int count=0;</span><br><span class="line">        //p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span><br><span class="line">        //当p指针跑到最后时，pre所指指针就是倒数第k个节点</span><br><span class="line">        while(p!=null)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">            count++;</span><br><span class="line">            if(k&lt;1)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果节点个数小于所求的倒数第k个节点，则返回空</span><br><span class="line">        if(count&lt;a) return null;</span><br><span class="line">        return pre;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实思路是一致的，就是<strong>通过得到链表长度，再得到n-k位置的链表值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链表结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>括号匹配消除</title>
    <link href="http://www.duanmuxu.top/20190602/bracket-matching-elimination.html"/>
    <id>http://www.duanmuxu.top/20190602/bracket-matching-elimination.html</id>
    <published>2019-06-02T04:28:32.278Z</published>
    <updated>2019-05-16T08:08:39.154Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><hr><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><blockquote><p>input : ()[]{}<br>output : true</p></blockquote><blockquote><p>input : ({[]})<br>output : true</p></blockquote><blockquote><p>input : ({)}<br>output : false</p></blockquote><hr><p>简单得说就是括号相匹配，同一个类型的括号连在一起。同一对括号可以嵌套在其他括号中，但只能一对括号都嵌套进去（如（{}）），不能只嵌套一边的括号（如（{）}）。</p><p>有看过<strong>二叉树的前中后序遍历进行加减乘除操作</strong>的应该一看到这一题就知道怎么做了。运算中有有括号的先算括号中的数的原则，那么就需要对运算中的括号进行识别与约束，与这道题一个道理。因此一看到这道题就应该想到可以用栈去求解。解法如下：</p><h4 id="使用栈-Stack-的解法"><a href="#使用栈-Stack-的解法" class="headerlink" title="使用栈(Stack)的解法"></a>使用栈(Stack)的解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (Character chara:s.toCharArray()) &#123;</span><br><span class="line">            if (chara == &apos;(&apos; || chara == &apos;[&apos; || chara == &apos;&#123;&apos;)</span><br><span class="line">                stack.push(chara);</span><br><span class="line">            else &#123;</span><br><span class="line">                if (stack.isEmpty())&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    Character charPop = stack.pop();</span><br><span class="line">                    if (charPop == &apos;(&apos; &amp;&amp; chara != &apos;)&apos; || charPop == &apos;[&apos; &amp;&amp; chara != &apos;]&apos; || charPop == &apos;&#123;&apos; &amp;&amp; chara != &apos;&#125;&apos;)&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (stack.isEmpty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：所给字符串第一个字符必为”(“,”[“,”{“中的一种，如果不是，那必然无法必配成功，return false。按字符串顺序识别字符将字符串push进栈中。当字符为”)”,”]”,”}”中的一种时，pop一个字符与上面三种字符向匹配，如果匹配成功，继续执行程序，匹配成功的括号自动消除。反之return false，说明这个“右”括号的前面一个括号也是“右”括号，即前面一个括号无法匹配成功。最后判断这个栈是否为空，如果全部都匹配消除完成，栈为空。</p><h4 id="优化后的使用栈的方法"><a href="#优化后的使用栈的方法" class="headerlink" title="优化后的使用栈的方法"></a>优化后的使用栈的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">for (char c : s.toCharArray()) &#123;</span><br><span class="line">if (c == &apos;(&apos;)</span><br><span class="line">stack.push(&apos;)&apos;);</span><br><span class="line">else if (c == &apos;&#123;&apos;)</span><br><span class="line">stack.push(&apos;&#125;&apos;);</span><br><span class="line">else if (c == &apos;[&apos;)</span><br><span class="line">stack.push(&apos;]&apos;);</span><br><span class="line">else if (stack.isEmpty() || stack.pop() != c)</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>太简洁了！！！</strong> 字符如果是“左”括号，那么栈中保存相应的“右”括号。字符如果是“右”括号，与pop出的值相比，如果不相等则说明前一个括号不是相对应的“左”括号，即无法匹配，return false。</p><p>除了上面用栈的方法外，还有一种<strong>值替换法</strong>，实现如下：</p><h4 id="目标值替换法"><a href="#目标值替换法" class="headerlink" title="目标值替换法"></a>目标值替换法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int length;</span><br><span class="line">    </span><br><span class="line">        do &#123;</span><br><span class="line">            length = s.length();</span><br><span class="line">            s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;);</span><br><span class="line">        &#125; while(length != s.length());</span><br><span class="line">    </span><br><span class="line">        return s.length() == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：暴力替换目标值，符合一整对括号的值直接替换成空值，以替换前的字符串长度和替换后的字符串长度作比较条件，建立循环。最后判断字符串长度是否为零，即整对括号是否被替换完全。</p><p>还有Map的方法：</p><h4 id="使用Key-Value匹配进行求解"><a href="#使用Key-Value匹配进行求解" class="headerlink" title="使用Key-Value匹配进行求解"></a>使用Key-Value匹配进行求解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    Map&lt;Character,Character&gt; pairs = new HashMap&lt;Character,Character&gt;();</span><br><span class="line">    pairs.put(&apos;(&apos;, &apos;)&apos;);</span><br><span class="line">    pairs.put(&apos;&#123;&apos;, &apos;&#125;&apos;);</span><br><span class="line">    pairs.put(&apos;[&apos;, &apos;]&apos;);</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">    for (char c:chars) &#123;</span><br><span class="line">    if (pairs.containsKey(c)) &#123;</span><br><span class="line">    stack.push(pairs.get(c));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    if (stack.isEmpty() || c != stack.pop()) </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：将“左”括号作为key，“右”括号作为值放在Map中，其他思路与优化后的使用栈的方法一致。</p><hr><p>无论是用栈还是数组还是Hash Map，都只是一种工具，最主要的是思路，有了思路就有了目标，各种存储方法只是帮助达到目标的工具罢了。（当然，有些工具是独轮车，有些工具是飞机哈哈哈哈哈哈哈）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.duanmuxu.top/20190602/reverse-list.html"/>
    <id>http://www.duanmuxu.top/20190602/reverse-list.html</id>
    <published>2019-06-02T04:28:32.276Z</published>
    <updated>2019-06-02T04:31:29.749Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p>最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，<strong>暴力</strong>反转链表。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre, result = new ListNode(0);</span><br><span class="line">        pre = result;</span><br><span class="line"></span><br><span class="line">        if(head == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(cur != null)&#123; //循环读取链表数值，存在array链表中</span><br><span class="line">            array.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = array.size() - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            pre = new ListNode(array.get(i));</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法很美好，现实很骨感。运行时报出如下错误：</p><blockquote><p>Exception in thread “main” java.lang.NullPointerException</p></blockquote><p>咋肥事，还会有空指针报错？马上Debug，发现一个漏洞。</p><p>最开始定义了ListNode pre, result两个新链表，pre用于循环，每次增加新的next节点，因为每次pre.next = new ListNode(num)时，pre.val会赋予新的值，不能成为一条完整的逆序链表，因此定义了result链表来与pre每次添加的值相等，因为result = pre，因此两个<strong>内存地址相等</strong>，也就是result每次会以链表形式添加pre所添加的新元素，从而达到逆序操作。</p><p>不过问题就出在pre = new ListNode(array.get(i));这上，<strong>每次new一个值时，pre的内存地址就改变一次</strong>，但是result的内存地址不会变，因此result不会与pre产生联系，也就是最后return result的时候，<strong>result的值在最开始定义result时就已经确定了</strong>，与后续pre的操作无关，因此无法得到反转链表的目的。</p><p>所以上述代码是些辣鸡。那就换个思路吧，直接从<strong>链表本身</strong>入手。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        if(head==null)</span><br><span class="line">            return null;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啥意思呢，pre表示所给链表的前一个节点，next表示所给链表的下一个节点。代码解释如下:</p><ol><li>next = head.next 表示next保存head的下一个节点，<strong>保证head.next不会丢失</strong>；</li><li>head.next = pre 表示head指向了pre,也就是head<strong>从后指向前</strong>；</li><li>pre = head 表示pre现在已经是在next前面的数值中，由后指向前的一个链表；</li><li>head = next 表示head找回原先的head的下一节点，也就是第一步中被next保存的节点；</li><li>继续以上操作，直至head遍历完成，此时pre也反转完成。</li></ol><p>举个栗子最直观：</p><p><strong>输入链表 1-&gt;2-&gt;3-&gt;4-&gt;5</strong></p><ol><li>next = head.next = 2-&gt;3-&gt;4-&gt;5</li><li>head.next = pre =null</li><li>pre = head = 1</li><li>head = next = 2-&gt;3-&gt;4-&gt;5</li><li>—新一轮循环—</li><li>next = head.next = 3-&gt;4-&gt;5</li><li>head.next = pre = 1  （<strong>此时head.val = 2，因此head 表示2-&gt;1</strong>）</li><li>pre = head = 2-&gt;1 （<strong>达到反转的目的</strong>）</li><li>head = next = 3-&gt;4-&gt;5</li><li>—新一轮循环—</li><li>……</li><li>head = null</li><li>pre = 5-&gt;4-&gt;3-&gt;2-&gt;1</li></ol><p><strong>输出链表 5-&gt;4-&gt;3-&gt;2-&gt;1</strong></p><p>任务完成，值得品味。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，&lt;strong&gt;暴力&lt;/strong&gt;反转链表。实现如下：&lt;/p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>对所有员工的薪水按照salary进行按照1-N的排名</title>
    <link href="http://www.duanmuxu.top/20190602/salary-for-all-employees-is-ranked-according-to-1n-in.html"/>
    <id>http://www.duanmuxu.top/20190602/salary-for-all-employees-is-ranked-according-to-1n-in.html</id>
    <published>2019-06-02T04:28:32.273Z</published>
    <updated>2019-06-02T04:31:29.752Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列</p></blockquote><p>建表语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">`emp_no` int(11) NOT NULL,</span><br><span class="line">`salary` int(11) NOT NULL,</span><br><span class="line">`from_date` date NOT NULL,</span><br><span class="line">`to_date` date NOT NULL,</span><br><span class="line">PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure><p>输出描述：</p><table><thead><tr><th>emp_no</th><th>salary</th><th>rank</th></tr></thead><tbody><tr><td>10005</td><td>94692</td><td>1</td></tr><tr><td>10002</td><td>94409</td><td>2</td></tr><tr><td>10010</td><td>94409</td><td>2</td></tr><tr><td>10001</td><td>88958</td><td>3</td></tr><tr><td>10007</td><td>88958</td><td>3</td></tr><tr><td>10004</td><td>74057</td><td>4</td></tr></tbody></table><p>不看最后一个rank排名，那么这道题特别简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s.emp_no, s.salary</span><br><span class="line">from salaries s</span><br><span class="line">where s.to_date = &apos;9999-01-01&apos;</span><br><span class="line">order by s.salary desc, s.emp_no asc</span><br></pre></td></tr></table></figure><p>但是题目偏偏加了一个rank工资排名。那么怎样才能获得这个排名呢？</p><p>在Java中我们可以直接使用循环来给目标值加排名，SQL查询语句中看来行不通。仅仅使用一张表似乎达不到目的，那就使用两张表吧。</p><p>既然不能使用循环，那么可以通过什么方法来表示排名，或者说是<strong>表示在自己的前面还有多少人（包括自己）</strong>。</p><p>很明显了，我们可以通过两张表中salary的大小不同来获取在自己前面的人的个数，即<strong>s1.salary &lt;= s2.salary</strong>。举个栗子：<br><br>有三个salary（6000，5000，4000， 4000），输出为s1.salary，那么当s1.salary = 6000时，s1.salary &lt;= s2.salary 的值为6000，也就是一个，当s1.salary = 5000时，s1.salary &lt;= s2.salary 的值为6000和5000两个。但是当s1.salary = 4000时，s1.salary &lt;= s2.salary 的值就为（6000，5000，4000， 4000）四个，且4000是重复的，因此我们使用<strong>count(distinct s2.salary) rank</strong> 来去重，并计算个数，即排名，以此类推，<strong>输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary就是s1.salary的排名</strong></p><p>当然不要忘了<strong>group by s1.emp_no</strong> ，用来将员工编号分组，计算count()</p><p>最后结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s1.emp_no, s1.salary, count(distinct s2.salary) rank</span><br><span class="line">from salaries s1, salaries s2</span><br><span class="line">where s1.salary &lt;= s2.salary and s1.to_date = &apos;9999-01-01&apos; and s2.to_date = &apos;9999-01-01&apos;</span><br><span class="line">group by s1.emp_no</span><br><span class="line">order by rank</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建表语句：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>单向链表小记</title>
    <link href="http://www.duanmuxu.top/20190602/oneway-linked-list.html"/>
    <id>http://www.duanmuxu.top/20190602/oneway-linked-list.html</id>
    <published>2019-06-02T04:28:32.272Z</published>
    <updated>2019-06-02T04:31:29.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。　　</p><h3 id="什么是单向链表？"><a href="#什么是单向链表？" class="headerlink" title="什么是单向链表？"></a>什么是单向链表？</h3><p>单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。（其实就是上一篇中提到的ListNode）</p><p>单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p><h3 id="单向链表的具体实现"><a href="#单向链表的具体实现" class="headerlink" title="单向链表的具体实现"></a>单向链表的具体实现</h3><p>这边放上练习用的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package LinkedList;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">private int size;</span><br><span class="line">private Node head;</span><br><span class="line"></span><br><span class="line">public SingleLinkedList() &#123;</span><br><span class="line">size = 0;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class Node&#123;</span><br><span class="line">private Object data;//每个节点的数据</span><br><span class="line">private Node next; //每个节点指向下一个节点的连接</span><br><span class="line"></span><br><span class="line">public Node(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在链表头添加元素</span><br><span class="line">public Object addhead(Object obj) &#123;</span><br><span class="line">Node newHead = new Node(obj);</span><br><span class="line">if(size == 0)</span><br><span class="line">head = newHead;</span><br><span class="line">else &#123;</span><br><span class="line">newHead.next = head;</span><br><span class="line">head = newHead;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在链表头删除元素</span><br><span class="line">public Object deleteHead() &#123;</span><br><span class="line">Object obj = head.data;</span><br><span class="line">head = head.next;</span><br><span class="line">size--;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找指定元素，找到了返回节点Node，找不到返回null</span><br><span class="line">public Node find(Object obj) &#123;</span><br><span class="line">Node current = head;</span><br><span class="line">int tempSize = size;</span><br><span class="line">while(tempSize &gt; 0)&#123;</span><br><span class="line"> if(obj.equals(current.data))&#123;</span><br><span class="line"> return current;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> current = current.next;</span><br><span class="line">     &#125;</span><br><span class="line">    tempSize--;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     //删除指定的元素，删除成功返回true</span><br><span class="line">     public boolean delete(Object value)&#123;</span><br><span class="line">         if(size == 0)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">         Node current = head;</span><br><span class="line">         Node previous = head;</span><br><span class="line">         while(current.data != value)&#123;</span><br><span class="line">         if(current.next == null)&#123;</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 previous = current;</span><br><span class="line">                 current = current.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //如果删除的节点是第一个节点</span><br><span class="line">         if(current == head)&#123;</span><br><span class="line">             head = current.next;</span><br><span class="line">             size--;</span><br><span class="line">         &#125;else&#123;//删除的节点不是第一个节点</span><br><span class="line">             previous.next = current.next;</span><br><span class="line">             size--;</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    //判断链表是否为空</span><br><span class="line">     public boolean isEmpty() &#123;</span><br><span class="line">     return (size == 0);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //在链表尾部添加元素</span><br><span class="line">     public Object addTail(Object obj) &#123;</span><br><span class="line">     Node newTail = new Node(obj);</span><br><span class="line">     Node current = head;</span><br><span class="line">     int temSize = size;</span><br><span class="line">     while (temSize &gt; 0) &#123;</span><br><span class="line">if (current.next == null) &#123;</span><br><span class="line">//需要先增加链表的容量，才能进行添加</span><br><span class="line">size++;</span><br><span class="line">current.next = newTail;</span><br><span class="line">newTail.next = null;</span><br><span class="line"></span><br><span class="line">return current;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">temSize--;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">     return obj;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //显示节点信息</span><br><span class="line">     public void display() &#123;</span><br><span class="line">     if (size &gt; 0) &#123;</span><br><span class="line">Node node = head;</span><br><span class="line">int tempSize = size;</span><br><span class="line">if (tempSize == 1) &#123;</span><br><span class="line">System.out.print(&quot;[&quot; + node.data + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">while (tempSize &gt; 0) &#123;</span><br><span class="line">if (node.equals(head)) &#123;</span><br><span class="line">System.out.print(&quot;[&quot; + node.data + &quot;-&gt;&quot;);</span><br><span class="line">&#125;else if (node.next == null) &#123;</span><br><span class="line">System.out.print(node.data+&quot;]&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.print(node.data+&quot;-&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node = node.next;</span><br><span class="line">tempSize--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;[]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">SingleLinkedList sLinkedList  = new SingleLinkedList();</span><br><span class="line">sLinkedList.addhead(&quot;A&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;B&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;C&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;D&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.addTail(&quot;O&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.deleteHead();</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.delete(&quot;B&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[D-&gt;C-&gt;B-&gt;A]</span><br><span class="line">[D-&gt;C-&gt;B-&gt;A-&gt;O]</span><br><span class="line">[C-&gt;B-&gt;A-&gt;O]</span><br><span class="line">[C-&gt;A-&gt;O]</span><br></pre></td></tr></table></figure><p>这边注意一个地方，addTail()是往链表的末尾添加一个元素，在进行判断current.next == null 后，<strong>要先将整体链表的size + 1</strong>，不要将size + 1放在循环外进行,才能够使current.next = newTail,否则将无法添加成功，因为容量不够。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是链表？&quot;&gt;&lt;a href=&quot;#什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;什么是链表？&quot;&gt;&lt;/a&gt;什么是链表？&lt;/h3&gt;&lt;p&gt;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer 替换字符串中的空格</title>
    <link href="http://www.duanmuxu.top/20190602/stringbuffer-replaces-spaces-in-strings.html"/>
    <id>http://www.duanmuxu.top/20190602/stringbuffer-replaces-spaces-in-strings.html</id>
    <published>2019-06-02T04:28:32.269Z</published>
    <updated>2019-03-22T13:01:39.998Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将一个字符串中的空格替换成 &quot;%20&quot;。</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="将String-Buffer转换为String类型，再进行操作"><a href="#将String-Buffer转换为String类型，再进行操作" class="headerlink" title="将String Buffer转换为String类型，再进行操作"></a>将String Buffer转换为String类型，再进行操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    String str1 = str.toString();</span><br><span class="line">str1 = str1.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">    return str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别简单，不过好像不是出题者的原意</p><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><h4 id="先填充字符串再进行遍历替换"><a href="#先填充字符串再进行遍历替换" class="headerlink" title="先填充字符串再进行遍历替换"></a>先填充字符串再进行遍历替换</h4><blockquote><p>解题思路：<br>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。<br>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。<br>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    int P1 = str.length() - 1;</span><br><span class="line">    for (int i = 0; i &lt;= P1; i++)</span><br><span class="line">        if (str.charAt(i) == &apos; &apos;)</span><br><span class="line">            str.append(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line">    int P2 = str.length() - 1;</span><br><span class="line">    while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        char c = str.charAt(P1--);</span><br><span class="line">        if (c == &apos; &apos;) &#123;</span><br><span class="line">            str.setCharAt(P2--, &apos;0&apos;);</span><br><span class="line">            str.setCharAt(P2--, &apos;2&apos;);</span><br><span class="line">            str.setCharAt(P2--, &apos;%&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://www.duanmuxu.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Single Number 找出数组中的单一数字</title>
    <link href="http://www.duanmuxu.top/20190602/single-number-find-a-in-the-array.html"/>
    <id>http://www.duanmuxu.top/20190602/single-number-find-a-in-the-array.html</id>
    <published>2019-06-02T04:28:32.252Z</published>
    <updated>2019-06-02T04:31:29.720Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.<br><br>给定一个非空的整数数组，除了一个元素外，每个元素都会出现两次。找出那个单一的整数。</p></blockquote><p>最常规的思路就是进行循环，统计出现的数字，只出现一次的就是我们要的答案了</p><h4 id="for循环统计数字出现次数"><a href="#for循环统计数字出现次数" class="headerlink" title="for循环统计数字出现次数"></a>for循环统计数字出现次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int[] result = new int[nums.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i &lt; nums.length; i++)&#123;</span><br><span class="line">            for (int j = 0;j &lt;= count;j++)&#123;</span><br><span class="line">                if (j == count)&#123;</span><br><span class="line">                    result[j] = -1;</span><br><span class="line">                    count++;</span><br><span class="line">                    j = count +1;</span><br><span class="line">                &#125;else if (nums[i] == nums[j])&#123;</span><br><span class="line">                    result[j]++;</span><br><span class="line">                    count++;</span><br><span class="line">                    j = count + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k = 0; k &lt; result.length ;k++)&#123;</span><br><span class="line">            if (result[k] == -1)</span><br><span class="line">                return nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个result数组用来存放统计的次数，初始值为-1，进行双重循环，以后每找到一个与nums数组中相同的数字，就在result数组中+1，即值变为0。最后根据result中值为-1（即在nums数组中没找到相同数值的数字）的数字就是我们要找的数字。</p><p>这种方法逻辑很顺，但是<strong>时间复杂度为O(n^2)</strong>，运行时间会消费很多。<br>那么要降低时间复杂度，就得<strong>减少一层循环</strong>。怎么才能实现呢？既要实现统计次数，又要遍历数组，有应用过<strong>Map Reducer</strong>方法的同学应该很容易就能想到<strong>word count</strong>程序好像就是这么一个道理，因此我们可以使用Map进行存值判断。</p><h4 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        int resultNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            if(result.containsKey(num))&#123;</span><br><span class="line">                result.remove(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.put(num, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int res : result.keySet()) &#123;</span><br><span class="line">            resultNum = res;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为nums数组中的重复数字只有两个，因此判断数字是否已经存在于Map中，若已经存在，则remove该数字，此时Map和nums数组中都已不存在该数字，若Map中不存在该数字，则put该数字。最后Map只剩下单一的数字，即我们想要的结果。</p><p>Map中需要插入<strong>key-value</strong>两个值，但是value的值对我们没有什么帮助，因此可以使用HashSet进一步优化。</p><h4 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if(!result.add(num))</span><br><span class="line">                result.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; it = result.iterator();</span><br><span class="line">        return it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断nums中的数字是否已经存在与HashSet中，若已经存在，则remove，若不存在，则直接add。这步与Map类似，不过只需要插入一个nums数组中的值就够了。</p><p>上面都是常规的一些存储方法，可没想到还有一个<strong>更加简洁帅气</strong>的方法。就是使用异或 ^ 的方法。</p><h4 id="XOR异或方法"><a href="#XOR异或方法" class="headerlink" title="XOR异或方法"></a>XOR异或方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            result = result ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么意思呢，^ 异或满足下面的转化：</p><table><thead><tr><th>a</th><th>b</th><th>result</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>所以两个数字进行 ^ 运算时，先将数字转化为二进制，再进行 ^ 操作，<strong>当两个数字相同时，则对应的二进制数的位数也都相同，因此运算结果为0</strong>。当<strong>0与任意数字进行异或运算时，运算结果为该任意数字</strong>，因此最终的结果就是nums数组中出现的单一数字。</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a non-empty array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;&lt;br&gt;给
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级真题—福尔摩斯的约会</title>
    <link href="http://www.duanmuxu.top/20190602/pat-b-level-question-sherlock-holmess-date.html"/>
    <id>http://www.duanmuxu.top/20190602/pat-b-level-question-sherlock-holmess-date.html</id>
    <published>2019-06-02T04:28:32.251Z</published>
    <updated>2019-06-02T04:31:29.750Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p></blockquote><p>输入描述:</p><blockquote><p>输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p></blockquote><p>输出描述:</p><blockquote><p>在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p></blockquote><p>输入例子:</p><blockquote><p>3485djDkxh4hhGE<br>2984akDfkkkkggEdsb<br>s&amp;hgsfdk<br>d&amp;Hyscvnm</p></blockquote><p>输出例子:</p><blockquote><p>THU 14:04</p></blockquote><hr><p>这边注意几点，如果前两个输入中出现<strong>连续相同的字母</strong>怎么办？如果<strong>代表小时的相同字母/数字出现得比代表日期的相同字母要早</strong>怎么办？如果后两个输入中有多组相同的字母怎么办？输出中碰到个位数的小时/分钟时前面不带”0”（<strong>输出不规范</strong>）怎么办？</p><p>这些都不是问题，下面贴出通过的代码，并且有详细注释。可能会显得有些冗长，但是看起来一目了然，毫无难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Holmes &#123;</span><br><span class="line">    //定义日期</span><br><span class="line">    private static char[] day = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">    //定义当天的小时</span><br><span class="line">    private static char[] hour =&#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        //循环读取四个输入</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            //获取四个字符串</span><br><span class="line">            String str1 = scanner.nextLine();</span><br><span class="line">            String str2 = scanner.nextLine();</span><br><span class="line">            String str3 = scanner.nextLine();</span><br><span class="line">            String str4 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            //判断前两个字符串哪一个最短</span><br><span class="line">            int daytime = shortest(str1, str2);</span><br><span class="line">            boolean isDay = true;//判断相同的字母是否是代表“天”</span><br><span class="line">            String result = &quot;&quot;;//结果字符串</span><br><span class="line">            int sum = 0; //前两个字符串中相同字母/数字的个数</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; daytime; i++)&#123;</span><br><span class="line">                if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInDay(str1.toCharArray()[i]) &amp;&amp; isDay)&#123;</span><br><span class="line">                    result += getDay(str1.toCharArray()[i]);</span><br><span class="line">                    /**</span><br><span class="line">                     * isDay有两个作用：</span><br><span class="line">                     * 一是防止下一次有字母出现时将字母当作成“天”的字母；</span><br><span class="line">                     * 二是供else if 中做判断，防止识别时间在识别周几之前</span><br><span class="line">                     */</span><br><span class="line">                    isDay = false;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;else if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInHour(str1.toCharArray()[i]) &amp;&amp; !isDay )&#123;</span><br><span class="line">                    //输出规范化，防止出现输出为 “THU 2:12”的情况</span><br><span class="line">                    if (getHour(str1.toCharArray()[i]) &lt; 10)&#123;</span><br><span class="line">                        result += &quot; 0&quot;+ getHour(str1.toCharArray()[i]);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        result += &quot; &quot;+ getHour(str1.toCharArray()[i]);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //防止已经识别周几和小时之后还有相同又符合判断条件的字母出现</span><br><span class="line">                if (sum == 2)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取str3，str4中最小的字符串长度</span><br><span class="line">            int minute = shortest(str3, str4);</span><br><span class="line">            for (int i = 0; i &lt; minute ; i++)&#123;</span><br><span class="line">                if (str3.toCharArray()[i] == str4.toCharArray()[i] &amp;&amp; isEnglishChar(str3.toCharArray()[i]))&#123;</span><br><span class="line">                    //输出规范化，与上同</span><br><span class="line">                    if (i &lt; 10 ) &#123;</span><br><span class="line">                        result += &quot;:0&quot; + i;</span><br><span class="line">                        break; //有相同的字母直接退出for循环</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        result += &quot;:&quot; + i;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回两个字符串长度最小的字符串长度</span><br><span class="line">     * @param str1</span><br><span class="line">     * @param str2</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int shortest(String str1, String str2)&#123;</span><br><span class="line">        return str1.length() &lt; str2.length() ? str1.length() : str2.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断输入字符是否存在与day的数组中</span><br><span class="line">     * @param character</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isInDay(Character character)&#123;</span><br><span class="line">        for (int i = 0; i &lt; day.length; i++)&#123;</span><br><span class="line">            if (character == day[i])</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断输入字符是否存在与hour数组中</span><br><span class="line">     * @param character</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isInHour(Character character)&#123;</span><br><span class="line">        for (int i = 0; i &lt; hour.length; i++)&#123;</span><br><span class="line">            if (character == hour[i])</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据输入字符获取星期几的简写</span><br><span class="line">     * @param dayChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getDay(Character dayChar)&#123;</span><br><span class="line">        switch (dayChar)&#123;</span><br><span class="line">            case &apos;A&apos;:</span><br><span class="line">                return &quot;MON&quot;;</span><br><span class="line">            case &apos;B&apos;:</span><br><span class="line">                return &quot;TUE&quot;;</span><br><span class="line">            case &apos;C&apos;:</span><br><span class="line">                return &quot;WED&quot;;</span><br><span class="line">            case &apos;D&apos;:</span><br><span class="line">                return &quot;THU&quot;;</span><br><span class="line">            case &apos;E&apos;:</span><br><span class="line">                return &quot;FRI&quot;;</span><br><span class="line">            case &apos;F&apos;:</span><br><span class="line">                return &quot;SAT&quot;;</span><br><span class="line">            case &apos;G&apos;:</span><br><span class="line">                return &quot;SUN&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Not Found This Day&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据输入字符获取小时时间</span><br><span class="line">     * @param hourChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int getHour(Character hourChar)&#123;</span><br><span class="line">        for (int i = 0; i &lt; hour.length; i++)&#123;</span><br><span class="line">            if (hourChar == hour[i])</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断输入字符是否是一个英文字母（包含大小写）</span><br><span class="line">     * @param engChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isEnglishChar(Character engChar)&#123;</span><br><span class="line">        if (engChar &gt;= &apos;a&apos; &amp;&amp; engChar &lt;= &apos;z&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        else if(engChar &gt;= &apos;A&apos; &amp;&amp; engChar &lt;= &apos;Z&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="http://www.duanmuxu.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>往微信图文中插入外链视频的方法（包含几种失败方法）</title>
    <link href="http://www.duanmuxu.top/20190602/how-to-insert-an-external-video-into-a-wechat-graphic-including-several-failure-methods.html"/>
    <id>http://www.duanmuxu.top/20190602/how-to-insert-an-external-video-into-a-wechat-graphic-including-several-failure-methods.html</id>
    <published>2019-06-02T04:28:32.249Z</published>
    <updated>2019-06-02T04:31:29.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种不同方法"><a href="#几种不同方法" class="headerlink" title="几种不同方法"></a>几种不同方法</h1><h2 id="最常见方法"><a href="#最常见方法" class="headerlink" title="最常见方法"></a>最常见方法</h2><p>我们平时转发图文时，往往转发的图文中会带有视频，一般的解决方法就是在浏览器中打开<br>腾讯视频，找到原图文中的原视频，然后进行分享复制链接，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/1.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>再把链接复制粘贴到后台视频链接的地方就会有视频显示出来</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/2.jpg" alt="在这里插入图片描述"></p><p>再点击确定就可以在图文中看见插入的视频了。<br>但是！！前几天在进行转发一篇图文中的视频时我发现了一个新的问题，有些视频点击分享时无法复制视频地址链接，怎么整都不行！<br>所以我先试了以下方法，但都<strong>无法实现</strong>！为了不让大家走弯路，我先把我用过的<strong>行不通</strong>的方法列出来。</p><h2 id="失败方法一："><a href="#失败方法一：" class="headerlink" title="失败方法一："></a>失败方法一：</h2><p>下载视频上传后台</p><p>该视频只有 57 秒，不足 <strong>20M</strong>（微信公众号后台要求上传的视频大小要小于20M），那我就下载腾讯视频客户端，再下载原视频，然后把视频上传到后台就行了呗，但是问题又出现了，腾讯视频的下载格式是<strong>qlv</strong>，公众号后台<strong>不支持该格式</strong>的视频。</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/3.jpg" alt="在这里插入图片描述"></p><p>不过问题不大，将原视频进行格式转换成 <strong>MP4</strong>，再上传到后台，还是美滋滋，但是问题又来了，格式工厂无法支持该格式，无法进行转换，那就从网上找吧，可是市面上的格式转换器（对我使用过的而言）转换后的 MP4 格式上传到后台后，公众号后台却无法解码，</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/4.jpg" alt="公众号后台转码失败"></p><p>因此视频还是无法成功上传，这条路，卒。</p><h2 id="利用windows-系统命令行对视频缓存的合成及转换"><a href="#利用windows-系统命令行对视频缓存的合成及转换" class="headerlink" title="利用windows 系统命令行对视频缓存的合成及转换"></a>利用windows 系统命令行对视频缓存的合成及转换</h2><p>我们每次在浏览器或是客户端进行视频查看时，系统会<strong>自动生成缓存</strong>保存在电脑中，下次查看视频时就会方便很多，因此我们先找到电脑本地视频缓存区，</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/5.jpg" alt="本地缓存目录"></p><p>腾讯视频将一整段完整的视频进行分段缓存，还都是<strong>ts</strong>的文件，这个格式第一次见，问题不<br>大，打开 <strong>cmd 命令行</strong>，使用 <strong>copy/b</strong> 命令进行分段视频的合成和转换，</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/6.jpg" alt="利用命令行进行合成"><br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/7.jpg" alt="合成并转换后的视频文件" title>                </div>                <div class="image-caption">合成并转换后的视频文件</div>            </figure></p><p>视频转换成功，美滋滋。可是问题又来了，点击打开只能在腾讯视频进行播放，其他视频软件出现解码错误（又是解码错误！！）</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/8.jpg" alt="迅雷影音播放画面"></p><p>而且腾讯视频里只有音频，没有视频图像，这条路，卒。</p><h2 id="检查网页元素进行视频捕捉和保存"><a href="#检查网页元素进行视频捕捉和保存" class="headerlink" title="检查网页元素进行视频捕捉和保存"></a>检查网页元素进行视频捕捉和保存</h2><p>知乎上的一个方法，利用浏览器播放视频，检查网页元素进行视频捕捉和保存 <a href="https://www.zhihu.com/question/23805794/answer/55527454" target="_blank" rel="noopener">如何下载网页上的视频？ - 习惯秋落的回答 - 知乎</a> 有兴趣的可以根据里面详细的介绍试一试</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/9.jpg" alt="在这里插入图片描述"></p><p>当我开开心心地进行视频保存时，却发现保存的视频格式是<strong>ts</strong> 文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/10.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>又是<strong>ts</strong>文件！！！这条路，卒。</p><h2 id="手机端UC浏览器进行视频保存"><a href="#手机端UC浏览器进行视频保存" class="headerlink" title="手机端UC浏览器进行视频保存"></a>手机端UC浏览器进行视频保存</h2><p>平时我们用<strong>手机 UC 浏览器</strong>进行看视频时，右上角会有一个下载视频的图标，我们可以进行视频下载，一般来说是 <strong>MP4</strong> 格式，但是前两天我在试验的时候那个图标不见了，我也就没有去深究。</p><h2 id="成功方法"><a href="#成功方法" class="headerlink" title="成功方法"></a>成功方法</h2><h3 id="查找浏览器视频元素"><a href="#查找浏览器视频元素" class="headerlink" title="查找浏览器视频元素"></a>查找浏览器视频元素</h3><p>既然团中央学校部的图文中可以播放该视频，那这篇<strong>图文的信息中肯定有该视频的信息</strong>，所以重点来啦，下面都是要记笔记的地方！<br>首先在浏览器中打开我们要转发的图文，我用的是谷歌浏览器，也建议大家使用。</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/11.jpg" alt="浏览器打开图文" title>                </div>                <div class="image-caption">浏览器打开图文</div>            </figure></p><p><br>然后打开网页检查元素，一种方法是<strong>右击鼠标，选择检查</strong>即可，另一种方法是 <strong>shift+ctrl+I快捷键</strong>进入检查</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/12.jpg" alt="进入检查页面" title>                </div>                <div class="image-caption">进入检查页面</div>            </figure></p><p><br>点击右边框框中的 <strong>element</strong> 元素 </p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/13.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>键入 <strong>ctrl+F</strong> 进行元素检索</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/14.jpg" alt="进行检索" title>                </div>                <div class="image-caption">进行检索</div>            </figure></p><p><br>搜索 <strong>v.qq.com</strong>,因为这个是所有腾讯视频链接中所包含的特定元素</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/15.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>此时网页自动找到页面中的视频元素（左半边），以及该视频的链接地址（右半边中的<strong>黄色部分</strong>所在区域），然后呢，我们有了该视频链接的总地址，此时我们复制 <strong>src=…后的部分，从 v.qq.com 一直到 false</strong></p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/16.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>然后将我们复制的这段链接再粘贴到后台</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/17.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>以上就是从<strong>原图文找原视频链接地址</strong>的方法，十分简便，为什么我之前会试那么多复杂的方法！！</p><p><strong>当然如果腾讯视频可以直接复制视频地址链接，那就不要整这些花里胡哨的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几种不同方法&quot;&gt;&lt;a href=&quot;#几种不同方法&quot; class=&quot;headerlink&quot; title=&quot;几种不同方法&quot;&gt;&lt;/a&gt;几种不同方法&lt;/h1&gt;&lt;h2 id=&quot;最常见方法&quot;&gt;&lt;a href=&quot;#最常见方法&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="新媒体运营" scheme="http://www.duanmuxu.top/categories/%E6%96%B0%E5%AA%92%E4%BD%93%E8%BF%90%E8%90%A5/"/>
    
    
      <category term="新媒体" scheme="http://www.duanmuxu.top/tags/%E6%96%B0%E5%AA%92%E4%BD%93/"/>
    
      <category term="视频" scheme="http://www.duanmuxu.top/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>使用MultipleOutputs方法将mapreduce分组输出</title>
    <link href="http://www.duanmuxu.top/20190602/mapreduce-group-output-using-the-multipleoutputs-method.html"/>
    <id>http://www.duanmuxu.top/20190602/mapreduce-group-output-using-the-multipleoutputs-method.html</id>
    <published>2019-06-02T04:28:32.247Z</published>
    <updated>2019-06-02T04:31:31.616Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-00000文件），那么我们如果需要将这一个输出文件分为多个输出文件该怎么办呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/mapreduce-grouping-output-using-multipleoutputs-method/1.jpg" alt="一个输出" title>                </div>                <div class="image-caption">一个输出</div>            </figure><p>这里就用到了MR框架中的MultipleOutputs函数（MultipleOutputs是2.0之后的新API，是对老版本中MultipleOutputs与MultipleOutputFormat的一个整合）。<br>先来看段完整代码熟悉一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class dateFormat &#123;</span><br><span class="line">    static class MyMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value,Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span><br><span class="line">            String time = simpleDateFormat.format(new Date());</span><br><span class="line">            String line = value.toString().trim();</span><br><span class="line">            for (int i =0; i&lt; line.length(); i++)&#123;</span><br><span class="line">                char newChar = line.charAt(i);</span><br><span class="line">                context.write(new Text(time), new Text(String.valueOf(newChar)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyReducer extends Reducer&lt;Text,Text,Text,Text&gt;&#123;</span><br><span class="line">        private MultipleOutputs&lt;Text, Text&gt; multipleOutputs;</span><br><span class="line"></span><br><span class="line">        protected void setup(Context context)&#123;</span><br><span class="line">            multipleOutputs = new MultipleOutputs&lt;Text, Text&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values,Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            for (Text value : values) &#123;</span><br><span class="line">                multipleOutputs.write((Text) null, value, key.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        protected void cleanup(Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">            multipleOutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(dateFormat.class);</span><br><span class="line"></span><br><span class="line">        job.setJobName(&quot;MultipleOutputTest&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(NullWritable.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line">//      MultipleOutputs.addNamedOutput(job, TextOutputFormat.class, NullWritable.class, Text.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, new Path(args[0]));</span><br><span class="line">        Path outPath = new Path(args[1]);</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">        if(fs.exists(outPath)) &#123;</span><br><span class="line">            fs.delete(outPath, true);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outPath);</span><br><span class="line"></span><br><span class="line">        job.waitForCompletion(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multipleOutputs.write的输出规范如下：<br><strong>multipleOutputs.write((namedOutput,) key, value, baseOutputPath)</strong><br>这里需要注意的一点在是map中的输出值会作为reduce中输出文件的文件命名（<em>map.key</em>-r-00000），即<strong>baseOutputPath</strong>的值确定了分组输出文件的命名规范。</p><p><strong>namedOutput</strong>为可选项，为当前输出Job的名称，如果有多于一个multipleOutputs.write时，需指定namedOutput名称，并在Driver里添加 <strong>MultipleOutputs.addNamedOutput(job,</strong> <strong>“namedOutput”</strong> , <strong>TextOutputFormat.class, NullWritable.class, Text.class)</strong>;作为作业的入口。</p><p>上述的代码段是我根据获取系统时间作为reducer的输入key值，命名时也根据map的执行时间进行命名，输出到同一文件夹之下，具体结果如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/mapreduce-grouping-output-using-multipleoutputs-method/2.jpg" alt="分组输出到同一文件下" title>                </div>                <div class="image-caption">分组输出到同一文件下</div>            </figure><p>如果需要将这些文件分别输出到不同的文件夹下，那么只需要将 multipleOutputs.write((Text) null, value, key.toString());中的key.toString()改为key+”/“,即改为<strong>multipleOutputs.write((Text) null, value, key+”/“)</strong>; 即可，输出结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/mapreduce-grouping-output-using-multipleoutputs-method/3.jpg" alt="分组输出到不同文件夹下" title>                </div>                <div class="image-caption">分组输出到不同文件夹下</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/tags/Hadoop/"/>
    
      <category term="Map Reduce" scheme="http://www.duanmuxu.top/tags/Map-Reduce/"/>
    
  </entry>
  
  <entry>
    <title>只爱一点点</title>
    <link href="http://www.duanmuxu.top/20190602/just-love-a-little-bit.html"/>
    <id>http://www.duanmuxu.top/20190602/just-love-a-little-bit.html</id>
    <published>2019-06-02T04:28:32.246Z</published>
    <updated>2019-06-02T04:30:52.443Z</updated>
    
    <content type="html"><![CDATA[<p>不爱那么多，<br>只爱一点点。<br>别人的爱情像海深，<br>我的爱情浅。<br>不爱那么多，<br>只爱一点点。<br>别人的爱情像天长，<br>我的爱情短。<br>不爱那么多，<br>只爱一点点。<br>别人眉来又眼去，<br>我只偷看你一眼。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/just-love-a-little/1.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人的爱情像海深，&lt;br&gt;我的爱情浅。&lt;br&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人的爱情像天长，&lt;br&gt;我的爱情短。&lt;br&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人眉来又眼去，&lt;br&gt;我只偷看你一眼。&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.duanmuxu.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="现代诗" scheme="http://www.duanmuxu.top/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java实现从尾到头打印链表（ListNode）每个节点的值</title>
    <link href="http://www.duanmuxu.top/20190602/java-implementation-prints-the-value-of-each-node-from-end-to-linked-list-listnode.html"/>
    <id>http://www.duanmuxu.top/20190602/java-implementation-prints-the-value-of-each-node-from-end-to-linked-list-listnode.html</id>
    <published>2019-06-02T04:28:32.243Z</published>
    <updated>2019-06-02T04:30:52.392Z</updated>
    
    <content type="html"><![CDATA[<p>进行做题之前，先来看看什么是ListNode。</p><blockquote><p>ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    public ListNode(int x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>val表示当前ListNode的值，next指向下一个ListNode。在进行ListNode<strong>初始化时必须传值</strong>，如下面main函数中进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ListNode listNode = new ListNode(1);</span><br><span class="line">listNode.next = new ListNode(3);</span><br><span class="line">listNode.next.next = new ListNode(4);</span><br><span class="line">listNode.next.next.next = new ListNode(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时生成链表：1-&gt;3-&gt;4-&gt;1</p><hr><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</span><br></pre></td></tr></table></figure><h3 id="方法一：利用栈的思想"><a href="#方法一：利用栈的思想" class="headerlink" title="方法一：利用栈的思想"></a>方法一：利用栈的思想</h3><p>一个链表从头到尾输入，要求输出的是从尾到头。符合栈<strong>先进后出</strong>的思想，因此可以用下面方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">while (listNode != null) &#123;</span><br><span class="line">stack.push(listNode.val);</span><br><span class="line">listNode = listNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList  = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">arrayList.add(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      return arrayList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList  = new ArrayList&lt;Integer&gt;();</span><br><span class="line">if (listNode != null) &#123;</span><br><span class="line">arrayList.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">arrayList.add(listNode.val);</span><br><span class="line">&#125;</span><br><span class="line">return arrayList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下addAll()和all()的区别：</p><blockquote><p>add（）是将传入的的参数作为当前 List 中d的一个项目（Item）来存储，即使你传入一个 list 也只会另当前的List集合增加 1 个元素。<br><br><br>addAll（）是传入一个List，将此前List集合中的所有元素加入到当前的 List 中，当前 List 集合会增加的元素个数是传入的 List 的大小。</p></blockquote><h3 id="方法三：头插法"><a href="#方法三：头插法" class="headerlink" title="方法三：头插法"></a>方法三：头插法</h3><p>利用链表头插法为逆序的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ListNode head = new ListNode(-1);</span><br><span class="line">while (listNode != null) &#123;</span><br><span class="line">ListNode q = listNode.next;</span><br><span class="line">listNode.next = head.next;</span><br><span class="line">head.next = listNode;</span><br><span class="line">listNode = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = head.next;</span><br><span class="line">while (head != null) &#123;</span><br><span class="line">arrayList.add(head.val);</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：链表翻转"><a href="#方法四：链表翻转" class="headerlink" title="方法四：链表翻转"></a>方法四：链表翻转</h3><ul><li>利用函数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    while(listNode != null)&#123;</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Collections.reverse(list);//使用Collections的reverse方法，直接将list反转</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>强行进行逆序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(listNode == null)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    while(listNode.next != null)&#123;</span><br><span class="line">        arr.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.add(listNode.val);</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int inx=0, end=arr.size()-1; inx&lt;end; inx++, end--)&#123;</span><br><span class="line">        temp = arr.get(inx);</span><br><span class="line">        arr.set(inx, arr.get(end));</span><br><span class="line">        arr.set(end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行做题之前，先来看看什么是ListNode。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;f
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找二叉树的下一个节点（中序遍历）</title>
    <link href="http://www.duanmuxu.top/20190602/find-the-next-node-of-binary-tree-middle-order-traversal.html"/>
    <id>http://www.duanmuxu.top/20190602/find-the-next-node-of-binary-tree-middle-order-traversal.html</id>
    <published>2019-06-02T04:28:32.229Z</published>
    <updated>2019-06-02T04:30:52.508Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们先了解一下二叉树的三种遍历方法：</p><ul><li>前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；</li><li>中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面；</li><li>后序遍历：也是从最左节点开始，根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面。</li></ul><p>比如下面一张图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/find-the-next-node-of-the-binary-tree-(intermediate-traversal)/1.jpg" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><ul><li>前序遍历为：ABDGHECKFIJ</li><li>中序遍历为：GDHBEAKCIJF</li><li>后序遍历为：GHDEBKJIFCA</li></ul><p>了解了二叉树的大致遍历方式，我们来看下题目：</p><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p>通过中序遍历我们可以知道一个节点的下一个节点有两种情况：</p><ul><li>如果一个节点的右子树不为空，那么该节点的下一个节点是<strong>右子树的最左节点</strong>，比如上图中C的后一个节点是I；</li><li>如果一个节点的右子树为空，那么向上找<strong>第一个左链接</strong>指向的树包含该节点的<strong>父节点</strong>。比如上图H的下一个节点是B。</li></ul><p>接下来看代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义一棵树</span><br><span class="line"></span><br><span class="line">public class TreeLinkNode &#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode next = null;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        //判断该节点是否存在右子节点</span><br><span class="line">        if(pNode.right != null)&#123;</span><br><span class="line">        //如果有右子树，则找右子树的最左节点</span><br><span class="line">            TreeLinkNode rightNode = pNode.right;</span><br><span class="line">            while(rightNode.left != null)</span><br><span class="line">                rightNode = rightNode.left;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        //没右子树，则找第一个当前节点是父节点左孩子的节点</span><br><span class="line">            while(pNode.next != null)&#123;</span><br><span class="line">                TreeLinkNode parentNode = pNode.next;</span><br><span class="line">                if(parentNode.left == pNode)</span><br><span class="line">                    return parentNode;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们先了解一下二叉树的三种遍历方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；&lt;/li&gt;
&lt;li&gt;中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer中关于斐波那契数列的分析和运用</title>
    <link href="http://www.duanmuxu.top/20190602/analysis-and-application-of-the-fibonacci-sequence-in-sword.html"/>
    <id>http://www.duanmuxu.top/20190602/analysis-and-application-of-the-fibonacci-sequence-in-sword.html</id>
    <published>2019-06-02T04:28:32.227Z</published>
    <updated>2019-06-02T04:30:52.476Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。</p><blockquote><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br>——《百度百科》</p></blockquote><p>具体函数表达参考下面这张图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/1.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h4 id="那么我们该如何求解与斐波那契数列相关的问题呢？"><a href="#那么我们该如何求解与斐波那契数列相关的问题呢？" class="headerlink" title="那么我们该如何求解与斐波那契数列相关的问题呢？"></a>那么我们该如何求解与斐波那契数列相关的问题呢？</h4><p>先看一下题目描述：</p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p></blockquote><p>具体可以用以下几种方法求解：</p><h5 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h5><p>递归能将一个问题划分成多个子问题进行求解。求F(n)时会转化成求F(n-1)、F(n-2),以此类推，最后转化成几个F(0)、F(1)相加的结果。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result = Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/2.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可是使用递归会有一个问题，会重复计算一些子问题。比如计算F(5)需要计算F(4)和F(3)，计算F(4)需要计算F(3)和F(2)，可以看到F(3)被重复计算了。造成了资源浪费。</p><p>所以我们换个思路。</p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>递归是将一个问题划分成多个子问题进行求解。动态规划相当于是个相反的过程，将子问题的解存储起来，用来解决大问题，比如已知F(0)、F(1)，进行求F(2)，再进一步求F(3)，以此类推，直至求到F(n)。这样子就不会有重复求解子问题的烦恼产生。<br>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int[] fib = new int[n+1];</span><br><span class="line">        fib[0] = 0;</span><br><span class="line">        fib[1] = 1;</span><br><span class="line">        for(int i = 2;i &lt; n + 1; i++)&#123;</span><br><span class="line">            fib[i] = fib[i - 1] + fib[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return fib[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/3.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><p>这么做比递归好很多，但是考虑到第i项只与第i-1和第i-2项有关，因此只需要存储前两项的值就能求解第i项，从而将空间复杂度由O(N)降低为O(1)。所以我们可以进一步优化。</p><h5 id="动态规划的进一步优化"><a href="#动态规划的进一步优化" class="headerlink" title="动态规划的进一步优化"></a>动态规划的进一步优化</h5><p>使用两个值存储i-1和i-2，避免使用数组，浪费更多的空间。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne = 1; //存储i-1</span><br><span class="line">        int preTwo = 0; //存储i-2</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 2;i &lt; n + 1; i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/4.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><hr><p>接下来我们来看看剑指Offer中其他关于斐波那契数列的运用的题目：</p><h6 id="题目一：跳台阶"><a href="#题目一：跳台阶" class="headerlink" title="题目一：跳台阶"></a>题目一：跳台阶</h6><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p>简单分析一下，就可以知道还是上面斐波那契数列的变化，青蛙跳1级台阶有1种跳法，2级台阶有2种跳法，3级台阶时可以从1级台阶跳上来也可以从2级台阶跳上来，即等于1级台阶的跳法加2级台阶的跳法因此n级台阶共有n-2级台阶跳法数+n-1级台阶跳法数。</p><p>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)</span><br><span class="line">            return target;</span><br><span class="line"></span><br><span class="line">        int preOne = 2;</span><br><span class="line">        int preTwo = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target+1 ;i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="题目二：变态跳台阶"><a href="#题目二：变态跳台阶" class="headerlink" title="题目二：变态跳台阶"></a>题目二：变态跳台阶</h6><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p></blockquote><p>上一题的升级版，跳n级台阶时可以允许跳1~n任意阶级的台阶。<br><br>先来分析一下</p><ul><li>跳n级台阶，那么第一步有n种跳法：跳1级、跳2级、到跳n级</li><li>跳1级，剩下n-1级，则剩下跳法是F(n-1)；</li><li>跳2级，剩下n-2级，则剩下跳法是F(n-2)；</li><li>所以F(n)=F(n-1)+F(n-2)+…+F(1)+1，最后的+1是因为直接跳n级台阶只有一种方法；</li><li>因为F(n-1)=F(n-2)+F(n-3)+…+F(1)+1;</li><li>以此类推，得F(n)=2*F(n-1)。</li></ul><p>分析后变得比上面一提还要简单。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)&#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int preNum = 2;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target + 1;i++)&#123;</span><br><span class="line">            result = 2 * preNum;</span><br><span class="line">            preNum = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="题目三：矩阵覆盖"><a href="#题目三：矩阵覆盖" class="headerlink" title="题目三：矩阵覆盖"></a>题目三：矩阵覆盖</h6><blockquote><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p></blockquote><p>再来分析一下</p><ul><li>首先从n=1开始，小矩阵只能竖着放，只有一种方法；</li><li>n=2时，大矩阵为2 * 2，小矩阵既可以竖着放也可以横着放，有两种方法；</li><li>当n越来越大时，如果第一步选择竖着放，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/5.jpg" alt="第一步：竖着放" title>                </div>                <div class="image-caption">第一步：竖着放</div>            </figure>那么大矩阵的规模缩小成2 * (n-1)；</li><li>如果第一步选择竖着放，那么第二排也只能横着放，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/6.jpg" alt="第一步：横着放" title>                </div>                <div class="image-caption">第一步：横着放</div>            </figure>那么大矩阵的规模缩小成2 * (n-2)；</li><li>因此，题目又转化成了与题目一一样的斐波那契数列了。<br>实现如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)</span><br><span class="line">            return target;</span><br><span class="line"></span><br><span class="line">        int preOne = 2;</span><br><span class="line">        int preTwo = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target+1 ;i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是关于斐波那契数列的含义和使用方式，题目一二三都是剑指Offer中的真题，示例中关于运行时间和占用内存是根据牛客网的测试用例得来的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于Storm（一）Storm简介</title>
    <link href="http://www.duanmuxu.top/20190602/about-storm-1.html"/>
    <id>http://www.duanmuxu.top/20190602/about-storm-1.html</id>
    <published>2019-06-02T04:28:32.198Z</published>
    <updated>2019-06-02T04:30:52.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Storm"><a href="#什么是Storm" class="headerlink" title="什么是Storm"></a>什么是Storm</h1><p>Apache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批处理相类似，Storm可以对大量的数据流进行可靠的实时处理，这一过程也称为“流式处理”，是分布式大数据处理的一个重要方向。Storm支持多种类型的应用，包括：实时分析、在线机器学习、连续计算、分布式 RPC（ DRPC）、ETL等。Strom的一个重要特点就是“快速”的数据处理，有benchmark示显示Storm级能够达到单个节点每秒百万级tuple处理（tuple是Storm的最小数据单元）的速度。快速的数据是处理、优秀的可扩展性与容错性、便捷的可操作性与维护性、活跃的社区技术支持，这就是 Storm 。</p><hr><h1 id="Hadoop与Storm的比较"><a href="#Hadoop与Storm的比较" class="headerlink" title="Hadoop与Storm的比较"></a>Hadoop与Storm的比较</h1><h3 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h3><table><thead><tr><th></th><th>Hadoop</th><th>Storm</th></tr></thead><tbody><tr><td>系统角色</td><td>JobTracker</td><td>Nimbus</td></tr><tr><td></td><td>TaskTracker</td><td>Supervisor</td></tr><tr><td></td><td>Child</td><td>Worker</td></tr><tr><td>应用名称</td><td>Job</td><td>Topology</td></tr><tr><td>组件接口</td><td>Mapper/Reducer</td><td>Spout/Bolt</td></tr><tr><td>- <strong>Nimbus</strong>：Nimbus在Storm中用于资源分配和作业调度，类比Hadoop中的Job Tracker</td><td></td><td></td></tr><tr><td>- <strong>Supervisor</strong>：Supervisor在Storm中用于接收Nimbus分配的任务，并且启动和停止用于完成这些任务对的Worker进程。Supervisor类比Hadoop中的TaskTracker</td><td></td><td></td></tr><tr><td>- <strong>Worker</strong>：运行Storm中具体组件逻辑的进程。这里的组件指的是Spout或者Bolt，对比Hadoop.x的Child进程。</td><td></td><td></td></tr><tr><td>- <strong>Topology</strong>：Topology是Storm中运行的一个任务，类比Hadoop.x中的一个作业（Job）</td><td></td><td></td></tr><tr><td>- <strong>Spout</strong>：在一个Topology中产生源数据流的组件</td><td></td><td></td></tr><tr><td>- <strong>Bolt</strong>：在一个Topology中接收数据，并进行逻辑处理的组件，称为Transformation</td><td></td><td></td></tr></tbody></table><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><table><thead><tr><th></th><th>Hadoop</th><th>Storm</th></tr></thead><tbody><tr><td>数据来源</td><td>Hadoop处理的是HDFS上TB级别的数据（历史数据）</td><td>Storm处理的是实时新增的某一笔数据（实时数据）</td></tr><tr><td>处理过程</td><td>Hadoop是分Map阶段和Reduce阶段</td><td>Storm是由用户定义处理流程，流程中可以包含多个步骤，每个步骤可以是数据源（Spout）或处理逻辑（Bolt）</td></tr><tr><td>是否结束</td><td>Hadoop最后是要结束的</td><td>Storm没有结束状态，到最后一步时，就停在那，直到有新数据进入时再从头开始</td></tr><tr><td>处理速度</td><td>Hadoop是以处理HDFS上大量数据为目的的，处理速度慢</td><td>Storm是只要处理新增的某一笔数据即可，可以做到很快</td></tr><tr><td>适用场景</td><td>Hadoop是在要处理批量数据时用的，不讲究时效性</td><td>Storm是要处理某一新增数据时使用的，讲究时效性</td></tr></tbody></table><p>ps：在Hadoop集群上运行MapReduce jobs，在Storm集群上运行topologies。jobs和topologies有很大的不同。一个关键区别是：一个Map Reduce jobs最终可以完成，而topologies处理过程将永远执行（除非Kill it）</p><hr><h1 id="Storm组件"><a href="#Storm组件" class="headerlink" title="Storm组件"></a>Storm组件</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/a-brief-introduction-to-storm-(i)-storm/1.jpg" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><h5 id="Storm集群中包含两类节点：主控节点（Master-Node）和工作节点（Work-Node）"><a href="#Storm集群中包含两类节点：主控节点（Master-Node）和工作节点（Work-Node）" class="headerlink" title="Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node）"></a>Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node）</h5><ul><li>主控节点上运行着Nimbus，负责在Storm集群内分发代码，分配任务给工作机器，并且负责监控集群运行状态</li><li>工作节点上运行着Supervisor，负责监听从Nimbus分配给它执行的任务，据此启动或停止任务的工作进程。</li><li><strong>每一个工作进程执行一个Topology的子集；一个运行中的Topology由分布在不同工作节点上的多个工作进程组成。</strong></li><li>Nimbus 和和 Supervisor节点之间所有的协调工作是通过<strong>Zookeeper集群</strong>来实现的。此外，Nimbus 和Supervisor进程都是<strong>快速失败（fail-fast)</strong> 和 <strong>无状态（stateless）</strong> 的；<strong>Storm集群所有的状态要么在Zookeeper集群中，要么存储在本地磁盘上</strong>。这意味着我们可以用kill-9来杀死Nimbus和Supervisor进程，它们在重启后可以继续工作。这个设计使得Storm集群拥有极强的<strong>稳定性</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Storm&quot;&gt;&lt;a href=&quot;#什么是Storm&quot; class=&quot;headerlink&quot; title=&quot;什么是Storm&quot;&gt;&lt;/a&gt;什么是Storm&lt;/h1&gt;&lt;p&gt;Apache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批
      
    
    </summary>
    
      <category term="Storm学习" scheme="http://www.duanmuxu.top/categories/Storm%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Storm" scheme="http://www.duanmuxu.top/tags/Storm/"/>
    
  </entry>
  
</feed>
