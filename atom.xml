<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>端木胥的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.duanmuxu.top/"/>
  <updated>2020-04-08T13:44:05.087Z</updated>
  <id>http://www.duanmuxu.top/</id>
  
  <author>
    <name>端木胥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu16.04离线安装redis（单机版）</title>
    <link href="http://www.duanmuxu.top/20200408/ubuntu1604-offline-installation-of-redis-standalone-version.html"/>
    <id>http://www.duanmuxu.top/20200408/ubuntu1604-offline-installation-of-redis-standalone-version.html</id>
    <published>2020-04-08T13:28:37.711Z</published>
    <updated>2020-04-08T13:44:05.087Z</updated>
    
    <content type="html"><![CDATA[<p>本教程适用于linux系统无法联网的情况，并且是在<strong>root用户</strong>下进行安装配置的</p><h1 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h1><ul><li>Ubuntu版本：16.04</li><li>Redis版本：4.0.2</li></ul><h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><h2 id="判断linux系统中是否有gcc环境"><a href="#判断linux系统中是否有gcc环境" class="headerlink" title="判断linux系统中是否有gcc环境"></a>判断linux系统中是否有gcc环境</h2><p>在命令行中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br><span class="line"></span><br><span class="line">g++ --version</span><br></pre></td></tr></table></figure><p>若出现以下的提示，则表示linux系统暂未有gcc环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The program &apos;gcc&apos; is currently not installed. You can install it by typing:apt install gcc</span><br></pre></td></tr></table></figure><p>那么进行下一步：gcc安装</p><p>如果直接显示gcc和g++的版本，表明linux系统中已有gcc环境，可直接进行下一步：redis安装</p><h2 id="gcc安装"><a href="#gcc安装" class="headerlink" title="gcc安装"></a>gcc安装</h2><h3 id="gcc在线安装"><a href="#gcc在线安装" class="headerlink" title="gcc在线安装"></a>gcc在线安装</h3><p>执行下列命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install gcc</span><br><span class="line">apt install g++</span><br></pre></td></tr></table></figure><p>如果安装过程中出现错误，可以执行 apt-get update 更新一下，再进行安装</p><p>安装完成之后，再查看gcc和g++版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@master:~/redis# g++ --version</span><br><span class="line">g++ (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br><span class="line"></span><br><span class="line">root@master:~/redis# gcc --version</span><br><span class="line">gcc (Ubuntu 5.4.0-6ubuntu1~16.04.12) 5.4.0 20160609</span><br><span class="line">Copyright (C) 2015 Free Software Foundation, Inc.</span><br></pre></td></tr></table></figure><p>出现以上版本显示则表示安装成功，版本会根据Ubuntu版本的不同而不同。</p><h3 id="gcc离线安装"><a href="#gcc离线安装" class="headerlink" title="gcc离线安装"></a>gcc离线安装</h3><h4 id="下载gcc安装包"><a href="#下载gcc安装包" class="headerlink" title="下载gcc安装包"></a>下载gcc安装包</h4><p>在官网 <a href="http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-4.6" target="_blank" rel="noopener">http://archive.ubuntu.com/ubuntu/pool/main/g/gcc-4.6</a> 中可以下载gcc安装包</p><p>一般来说需要以下四个：</p><ul><li>gcc-4.6_4.6.3-1ubuntu5_amd64.deb</li><li>g++-4.6_4.6.3-1ubuntu5_amd64.deb</li><li>gcc-4.6-base_4.6.3-1ubuntu5_amd64.deb</li><li>libstdc++6-4.6-dev_4.6.3-1ubuntu5_amd64.deb</li></ul><h4 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h4><p>首先将上述四个文件都放在同一目录下，比如我都放在 /root/gcc 目录下</p><p>然后依次在命令行中输入 dpkg -i 安装这四个包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i *.deb</span><br></pre></td></tr></table></figure><p>如果执行此命令时，提示有些包还没安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dpkg: dependency problems prevent configuration of gcc-4.6:</span><br><span class="line"> gcc-4.6 depends on cpp-4.6 (= 4.6.3-1ubuntu5); however:</span><br><span class="line">  Package cpp-4.6 is not installed.</span><br><span class="line"> gcc-4.6 depends on libgomp1 (&gt;= 4.6.3-1ubuntu5); however:</span><br><span class="line">  Package libgomp1 is not installed.</span><br></pre></td></tr></table></figure><p>那么先将这些依赖包提前安装即可。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>安装好之后，这时候输入 gcc –version 会返回gcc的版本，然而输入g++ –version 则会报错；此时进入 /usr/bin 目录下，发现 g++ 的文件夹名称为 g++-4.6 ，因此我们输入 g++-4.6  –version发现，就会返回g++版本号</p><h4 id="设为默认编译器"><a href="#设为默认编译器" class="headerlink" title="设为默认编译器"></a>设为默认编译器</h4><p>至此，g++-4.6已经安装，但还未被设为默认g++编译器。再执行下面的命令切换链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/bin/g++   //删除原来默认的g++编译器连接文件</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/bin/g++-4.6 /usr/bin/g++ //创建新的连接文件指向新的g++-4.6编译器</span><br></pre></td></tr></table></figure><p>此命令还可以对ubuntu系统中默认gcc和g++编译器的版本进行修改。</p><p>如果要对原来系统默认的gcc编译器版本修改，就可以执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm /usr/bin/gcc  //删除原来默认的gcc编译器连接文件</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/bin/gcc-x.xxx  /usr/bin/gcc   //创建新的连接文件指向新的gcc编译器</span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://blog.csdn.net/qq_27630885/article/details/85051391?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4" target="_blank" rel="noopener">ubuntu 离线安装g++-4.6编译器</a></p><h2 id="redis安装"><a href="#redis安装" class="headerlink" title="redis安装"></a>redis安装</h2><p>先将安装包上传到linux中，我放到了 /root 目录下</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-4.0.2.tar.gz</span><br></pre></td></tr></table></figure><h3 id="编译源代码"><a href="#编译源代码" class="headerlink" title="编译源代码"></a>编译源代码</h3><p>进入解压后的redis目录，然后进行编译源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd redis-4.0.2</span><br><span class="line"></span><br><span class="line">make MALLOC=libc</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>源代码编译完成后，会在/root/redis-4.0.2/ 目录中生成一个 redis.conf 文件，进入 redis.conf 文件进行下述修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 先创建一个redis 目录用来存放redis日志</span><br><span class="line">mkdir /root/redis</span><br><span class="line"></span><br><span class="line">// 编辑redis.conf文件</span><br><span class="line">vim /root/redis-4.0.2/redis.conf</span><br><span class="line"></span><br><span class="line">// 修改以下内容</span><br><span class="line">daemonize yes   //是否以后台daemon方式运行，默认不是后台运行</span><br><span class="line">pidfile /var/run/redis/redis.pid   //redis的PID文件路径（可选）</span><br><span class="line">bind 0.0.0.0   //绑定主机IP，默认值为127.0.0.1，我这需要从主机连接虚拟机，所以需要更改</span><br><span class="line">logfile &quot;/root/redis/redis.log&quot;    //定义log文件位置，模式log信息定向到stdout，输出到/dev/null（可选）</span><br><span class="line">dir &quot;/root/redis&quot;  //本地数据库存放路径，默认为./，编译安装默认存在在/usr/local/bin下（可选）</span><br></pre></td></tr></table></figure><p>之后将conf文件复制一份到刚才新建的redis 目录中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/redis-4.0.2/redis.conf /root/redis</span><br></pre></td></tr></table></figure><p>至此，redis就安装完毕了。</p><h2 id="redis启动与关闭"><a href="#redis启动与关闭" class="headerlink" title="redis启动与关闭"></a>redis启动与关闭</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 启动 redis</span><br><span class="line">redis-server /root/redis/redis.conf</span><br><span class="line"></span><br><span class="line">// 连接 redis 服务器</span><br><span class="line">redis-cli</span><br><span class="line"></span><br><span class="line">// 连接之后会进入redis操作区</span><br><span class="line">127.0.0.1:6379&gt; set a b</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get a</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 关闭 redis 服务器</span><br><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本教程适用于linux系统无法联网的情况，并且是在&lt;strong&gt;root用户&lt;/strong&gt;下进行安装配置的&lt;/p&gt;
&lt;h1 id=&quot;软件配置&quot;&gt;&lt;a href=&quot;#软件配置&quot; class=&quot;headerlink&quot; title=&quot;软件配置&quot;&gt;&lt;/a&gt;软件配置&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://www.duanmuxu.top/categories/Redis/"/>
    
    
      <category term="Linux" scheme="http://www.duanmuxu.top/tags/Linux/"/>
    
      <category term="Redis" scheme="http://www.duanmuxu.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Scala基础</title>
    <link href="http://www.duanmuxu.top/20200314/scala-basics.html"/>
    <id>http://www.duanmuxu.top/20200314/scala-basics.html</id>
    <published>2020-03-14T10:20:37.401Z</published>
    <updated>2020-03-14T10:22:52.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="REPL"><a href="#REPL" class="headerlink" title="REPL"></a>REPL</h3><p>Scala解释器读到一个表达式，对它进行求值，将它打印出来，接着再继续下一个表达式。这个过程被称作“<strong>读取-求值-打印</strong>”循环（read-eval-print loop），即REPL</p><h3 id="var和val的区别"><a href="#var和val的区别" class="headerlink" title="var和val的区别"></a>var和val的区别</h3><ul><li>var是一个<strong>可变变量</strong>，是一个可以通过重新分配来更改为另一个值的变量。这种声明变量的方式<strong>和java中声明变量的方式一样</strong>。</li><li>val是一个<strong>只读变量</strong>，这种声明变量的方式<strong>相当于java中的final变量</strong>。一个val创建的时候<strong>必须初始化</strong>，因为以后不能被改变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//var 即variable,用于声明变量</span><br><span class="line">var str : String = &quot;Hello Scala!&quot;</span><br><span class="line"></span><br><span class="line">//val 即value，用于声明常量，类似Java中的final，使用val定义的常量不允许重新赋值</span><br><span class="line">val num : Int = 100;</span><br><span class="line">scala&gt; num = 200</span><br><span class="line">&lt;console&gt;:12: error: reassignment to val</span><br><span class="line">        num = 200</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure><p>Scala编译器可以通过值的类型推断出变量的类型，因此变量类型可以省略</p><h3 id="常用类型"><a href="#常用类型" class="headerlink" title="常用类型"></a>常用类型</h3><p>和Java一样，Scala也有七种数值类型：Byte、Char、Short、Int、Long、Float和Double，以及一个Boolean类型。与Java不同的是，这些类型是类。Scala并不刻意区分基本类型和引用类型。可以对数字执行方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.toString()  // 将交出字符串“1”</span><br></pre></td></tr></table></figure><p>在Scala中，不需要包装类型，在基本类型和包装类型之间的转换是Scala编译器的工作。</p><p>Scala用底层的java.lang.String类来表示字符串，通过StringOps类给字符串追加了上百种操作，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; &quot;hello&quot;.intersect(&quot;World&quot;)</span><br><span class="line">res0: String = lo</span><br></pre></td></tr></table></figure><p>在这个例子中，java.lang.String对象”Hello”被隐式地转换成了一个StringOps对象，接着StringOps类的intersect方法被应用。</p><h3 id="算术和操作符重载"><a href="#算术和操作符重载" class="headerlink" title="算术和操作符重载"></a>算术和操作符重载</h3><p>+ - * / 与在Java中完成的工作一样，但这些操作符实际上是方法，比如 <strong>a + b 是 a.+(b) 的简写</strong>，这里的+是方法名。通常来说， a 方法 b可以写成 a.方法(b)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 to 10 可以写成 1.to(10)</span><br><span class="line">输出都为 Range 1 to 10</span><br></pre></td></tr></table></figure><p>值得注意的是，Scala中没有 ++ 和 – 操作符，需要递增或者递减时，使用 += 1 或 -= 1</p><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import scala.math._</span><br><span class="line">// 这里的 _ 字符表示通配符，类似于Java中的 * ，然后就可以直接使用调用包中的方法</span><br><span class="line">sqrt(2) // 将交出 1.4142135623730951</span><br><span class="line"></span><br><span class="line">// 如果不引入scala.math 包，则添加包名来使用</span><br><span class="line">scala.math.sqrt(2)</span><br></pre></td></tr></table></figure><p>注意一点，使用以scala. 开头的包时，可以省去scala前缀，例如 import math._ 等同于 import scala.math_</p><h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>在Java中，如果需要得到字符串中的第i个字符，那么需要用到 s.charAt(i)，在Scala中，则使用 s(i) 进行表示，它背后的实现原理是一个名为apply 的方法。在StringOps类的文档中，有这么一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def apply(n : Int): Char</span><br></pre></td></tr></table></figure><p>也就是说，s(i) 是 s.apply(4)</p><p>如果是在多个方法中使用apply方法，则可以把apply方法前的表达式圈起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;HelloWorld&quot;.sorted(3)  // 这将会引发一个错误，因为sorted 方法可以用一个隐式的排序参数来调用，但3并不是一个有效的排序</span><br><span class="line"></span><br><span class="line">// 因此可以如下使用</span><br><span class="line">(&quot;HelloWprld&quot;.sorted)(3)</span><br><span class="line">或者</span><br><span class="line">&quot;HelloWorld&quot;.sorted.apply(3)</span><br></pre></td></tr></table></figure><h3 id="获取首尾字符"><a href="#获取首尾字符" class="headerlink" title="获取首尾字符"></a>获取首尾字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var s = &quot;HelloWorld&quot;</span><br><span class="line">s: String = HelloWorld</span><br><span class="line"></span><br><span class="line">scala&gt; s(0)</span><br><span class="line">res0: Char = H</span><br><span class="line"></span><br><span class="line">scala&gt; var x = s.reverseIterator</span><br><span class="line">x: Iterator[Char] = &lt;iterator&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; x.next()</span><br><span class="line">res1: Char = d</span><br></pre></td></tr></table></figure><h3 id="take-drop-takeRight和dropRight-字符串函数区别"><a href="#take-drop-takeRight和dropRight-字符串函数区别" class="headerlink" title="take,drop,takeRight和dropRight 字符串函数区别"></a>take,drop,takeRight和dropRight 字符串函数区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">take、drop、takeRight、dropRight 位于StringOps中</span><br><span class="line"></span><br><span class="line">def take （n：Int）：String // 获取前n个元素</span><br><span class="line">def takeRight(n: Int): String //获取最后n个元素</span><br><span class="line">def drop(n: Int): String //获取所有元素，除了前n个</span><br><span class="line">def dropRight(n: Int): String //获取所有元素，除了最后n个</span><br><span class="line"></span><br><span class="line">substring调用的是java的方法</span><br><span class="line">def substring(arg0: Int): String // 截取所有字符，除了前n个，类似drop(索引从1开始)</span><br><span class="line">def substring(arg0: Int, arg1: Int): String //从索引[arg0,arg1)截取字符串（索引从0开始）</span><br></pre></td></tr></table></figure><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>scala中的类不能定义静态成员，而代之以定义单例对象来替代，单例对象通过object关键字来声明，单例对象中的所有方法，可以直接通过object单例对象的名字直接来调用。</p><p>一个单例对象可以绑定在一个类，当单例对象和某个类写在同一个源文件且共享一个名字，它们就产生了绑定关系。此时单例对象称之为该类的伴生对象，类称之为该对象的伴生类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object food &#123;</span><br><span class="line">  def getFood()&#123;</span><br><span class="line">    println(&quot;this is not the same&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class food&#123;</span><br><span class="line">  def getFood(): Unit =&#123;</span><br><span class="line">    println(&quot;this is your food.&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类和它的伴生对象可以互相访问其私有成员，单例对象不能new，所以也没有构造参数，可以把单例对象当做java中可能会用到的静态方法工具类。</p><p>作为程序入口的方法必须是静态的，所以main方法必须处在一个单例对象中，而不能写在一个类中。</p><p><a href="https://blog.csdn.net/starkpan/article/details/86633228" target="_blank" rel="noopener">参考博客：scala 伴生对象的作用</a><br><a href="https://blog.csdn.net/zhangjg_blog/article/details/23462695?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考博客：学习Scala：伴生对象的实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;REPL&quot;&gt;&lt;a href=&quot;#REPL&quot; class=&quot;headerlink&quot; title=&quot;REPL&quot;&gt;&lt;/a&gt;REPL&lt;/h3&gt;&lt;p&gt;Scala解释器读到一个表达式，对它进行求值，将它打印出来，接着再继续下一个表达式。这个过程被称作“&lt;strong&gt;读取-求
      
    
    </summary>
    
      <category term="Scala" scheme="http://www.duanmuxu.top/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://www.duanmuxu.top/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>python爬虫简单实例-爬取17K小说网小说</title>
    <link href="http://www.duanmuxu.top/20200308/a-simple-example-of-python-crawler.html"/>
    <id>http://www.duanmuxu.top/20200308/a-simple-example-of-python-crawler.html</id>
    <published>2020-03-07T16:24:22.722Z</published>
    <updated>2020-03-07T16:46:41.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是网络爬虫"><a href="#什么是网络爬虫" class="headerlink" title="什么是网络爬虫?"></a>什么是网络爬虫?</h2><p>网络爬虫（Web Spider），又被称为网页蜘蛛，是一种按照一定的规则，自动地抓取网站信息的<strong>程序或者脚本</strong>。</p><h2 id="爬虫流程"><a href="#爬虫流程" class="headerlink" title="爬虫流程"></a>爬虫流程</h2><ol><li>先由urllib的request打开Url得到<strong>网页html文档</strong></li><li>浏览器打开网页源代码分析<strong>元素节点</strong></li><li>通过<strong>Beautiful Soup</strong>或者<strong>正则表达式</strong>提取想要的数据</li><li><strong>存储数据到本地磁盘或数据库（抓取，分析，存储）</strong></li></ol><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>爬取17K小说网（<a href="https://www.17k.com/" target="_blank" rel="noopener">https://www.17k.com/</a> ）中的一部小说《斩月》</p><h3 id="获取章节内容"><a href="#获取章节内容" class="headerlink" title="获取章节内容"></a>获取章节内容</h3><p>先看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    target = &apos;https://www.17k.com/chapter/3062292/39084147.html&apos;</span><br><span class="line">    req = requests.get(target)</span><br><span class="line">    req.encoding = req.apparent_encoding</span><br><span class="line">    html = req.text</span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure><p>通过urllib的request打开Url得到网页html文档，apparent_encoding 属性是通过解析得到网页的编码方式，并且赋值给requests.encoding，就能保证打印出来的不是乱码格式的网页html文档。</p><blockquote><p>不过有时候apparent_encoding属性解析出来的是它所认为正确的编码格式，但是和原编码格式不一致，最终导致乱码问题。因此可以现在网页端知道网页编码格式，再通过requests.encoding直接赋值进行转码。就不会出现乱码，如 requests.encoding=’utf-8’</p></blockquote><p>通过此方法得到网页文档，找到文章内容所对应的div：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301141932663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>再通过 BeautifulSoup 提取想要的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    target = &apos;https://www.17k.com/chapter/3062292/39084147.html&apos;</span><br><span class="line">    req = requests.get(target)</span><br><span class="line">    req.encoding = req.apparent_encoding</span><br><span class="line">    html = req.text</span><br><span class="line">    bf = BeautifulSoup(html)</span><br><span class="line">    texts = bf.find_all(&apos;div&apos;,class_=&apos;p&apos;)</span><br><span class="line">    print(texts[0].text)</span><br></pre></td></tr></table></figure><p>texts[0].text通过text属性将&lt;p&gt;标签隐去，只打印&lt;p&gt;标签包含的内容，得到结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301141951640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><h3 id="获取章节标题和链接"><a href="#获取章节标题和链接" class="headerlink" title="获取章节标题和链接"></a>获取章节标题和链接</h3><p>在章节页面中只能获取章节内容，不能获取每章的章节链接，因此我们需要回到小说的目录页面上进行信息获取。方法也和上述获取章节内容一致，先通过requests获取网页文档，再通过BeautifulSoup提取想要的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    www = &apos;https://www.17k.com&apos;</span><br><span class="line">    target = &apos;https://www.17k.com/list/3062292.html&apos;</span><br><span class="line">    req = requests.get(target)</span><br><span class="line">    req.encoding = req.apparent_encoding</span><br><span class="line">    html = req.text</span><br><span class="line">    bf = BeautifulSoup(html)</span><br><span class="line">    texts = bf.find_all(&apos;dl&apos;,class_=&apos;Volume&apos;)</span><br><span class="line">    a_bf = BeautifulSoup(str(texts[0]))</span><br><span class="line">    a_text = a_bf.find_all(&apos;a&apos;)</span><br><span class="line">    print(a_text[0].text)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301142132553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301142144455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>但是我们发现章节标题被包在了&lt;span&gt;标签下，这就意味着提取出来的内容即使通过.text属性转变后，&lt;span&gt;标签和标签中的内容也会一起打印出来。<br>那么此时就可以通过截取字符的形式将标题截取出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests</span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    www = &apos;https://www.17k.com&apos;</span><br><span class="line">    target = &apos;https://www.17k.com/list/3062292.html&apos;</span><br><span class="line">    req = requests.get(target)</span><br><span class="line">    req.encoding = req.apparent_encoding</span><br><span class="line">    html = req.text</span><br><span class="line">    bf = BeautifulSoup(html)</span><br><span class="line">    texts = bf.find_all(&apos;dl&apos;,class_=&apos;Volume&apos;)</span><br><span class="line">    a_bf = BeautifulSoup(str(texts[0]))</span><br><span class="line">    a_text = a_bf.find_all(&apos;a&apos;)</span><br><span class="line">    for each in a_text[2:]:  # 去掉第一个不需要的链接</span><br><span class="line">        name = str(each.find_all(&apos;span&apos;,class_=&apos;ellipsis&apos;))</span><br><span class="line">        href = each.get(&apos;href&apos;)</span><br><span class="line">        print(name[43:len(name)-24], www+href)</span><br></pre></td></tr></table></figure><p>得到如下结果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301142204589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>上面已经学会了获取章节内容和章节标题、链接，接下来就是下载整部小说了，直接上代码，逻辑就是上述的逻辑，加了点函数包装而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:UTF-8 -*-</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">import requests, sys</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">类说明：</span><br><span class="line">    下载17K小说网中的小说《斩月》</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class download(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.server = &apos;https://www.17k.com&apos;</span><br><span class="line">        self.target = &apos;https://www.17k.com/list/3062292.html&apos;</span><br><span class="line">        self.names = []  # 存放章节名</span><br><span class="line">        self.urls = []   # 存放章节链接</span><br><span class="line">        self.nums = 0    # 章节数</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    函数说明：</span><br><span class="line">        获取下载链接</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def get_download_url(self):</span><br><span class="line">        req = requests.get(url=self.target)</span><br><span class="line">        req.encoding = &apos;utf-8&apos;</span><br><span class="line">        html = req.text</span><br><span class="line">        bf = BeautifulSoup(html)</span><br><span class="line">        div = bf.find_all(&apos;dl&apos;,class_=&apos;Volume&apos;)</span><br><span class="line">        a_bf = BeautifulSoup(str(div[0]))</span><br><span class="line">        a = a_bf.find_all(&apos;a&apos;)</span><br><span class="line">        self.nums = len(a[1:])  # 去取一些不必要的链接，并统计章节数</span><br><span class="line">        for each in a[1:]:</span><br><span class="line">            name = str(each.find_all(&apos;span&apos;, class_=&apos;ellipsis&apos;)) # 获取章节名字</span><br><span class="line">            href = each.get(&apos;href&apos;) # 获取章节链接</span><br><span class="line">            self.names.append(name[43:len(name) - 24])</span><br><span class="line">            self.urls.append(self.server + href)</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    函数说明：</span><br><span class="line">        获取章节内容</span><br><span class="line">    Parameters：</span><br><span class="line">        target - 下载链接(String)</span><br><span class="line">    Returns：</span><br><span class="line">        texts - 章节内容(String)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def get_contents(self, target):</span><br><span class="line">        req = requests.get(url=target)</span><br><span class="line">        req.encoding = &apos;utf-8&apos;</span><br><span class="line">        html = req.text</span><br><span class="line">        bf = BeautifulSoup(html)</span><br><span class="line">        texts = bf.find_all(&apos;div&apos;,class_=&apos;p&apos;)</span><br><span class="line">        texts = texts[0].text</span><br><span class="line">        return texts[:len(texts)-90]</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    函数说明：</span><br><span class="line">        将爬取的文章内容写入文件</span><br><span class="line">    Parameters：</span><br><span class="line">        name - 章节名称(String)</span><br><span class="line">        path - 当前路径下，小说保存名称(String)</span><br><span class="line">        text - 章节内容(String)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def write(self,name,path,text):</span><br><span class="line">        write_flag = True</span><br><span class="line">        with open(path, &apos;a&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">            f.write(name + &apos;\n&apos;)</span><br><span class="line">            f.writelines(text)</span><br><span class="line">            f.write(&apos;\n\n&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    download = download()</span><br><span class="line">    download.get_download_url()</span><br><span class="line">    print(&quot;《斩月》开始下载：&quot;)</span><br><span class="line">    for i in range(download.nums):</span><br><span class="line">        download.write(download.names[i], &quot;斩月.txt&quot;, download.get_contents(download.urls[i]))</span><br><span class="line">        sys.stdout.write(&quot;  已下载:%.3f%%&quot; %float(i/download.nums) + &apos;\r&apos;)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">    print(&quot;《斩月》下载完成！&quot;)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301142225345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301142327533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200301142338239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>大功告成！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是网络爬虫&quot;&gt;&lt;a href=&quot;#什么是网络爬虫&quot; class=&quot;headerlink&quot; title=&quot;什么是网络爬虫?&quot;&gt;&lt;/a&gt;什么是网络爬虫?&lt;/h2&gt;&lt;p&gt;网络爬虫（Web Spider），又被称为网页蜘蛛，是一种按照一定的规则，自动地抓取网站信息的&lt;
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
      <category term="爬虫" scheme="http://www.duanmuxu.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>机器学习—交叉验证</title>
    <link href="http://www.duanmuxu.top/20200219/machine-learningcrossvalidation.html"/>
    <id>http://www.duanmuxu.top/20200219/machine-learningcrossvalidation.html</id>
    <published>2020-02-18T17:25:45.469Z</published>
    <updated>2020-02-18T17:34:13.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong>交叉验证</strong>是机器学习的重要概念。</p><p>为了能够让模型更加稳定，需要用数据集的不同子集进<strong>行反复的验证</strong>。如果只是对特定的子集进行微调，最终可能会<strong>过度拟合（overfitting）模型</strong>。</p><blockquote><p><strong>过度拟合</strong>是指模型在<strong>已知数据集</strong>上拟合得超级好，但是一遇到<strong>未知数据</strong>就挂了。</p></blockquote><p>我们真正想要的，是让机器学习模型能够适用于未知数据。</p><hr><p>当处理机器学习模型时，通常关心3个指标：<strong>精度（precision）、召回率（recall）和F1得分（F1 score）</strong>。可以用参数评分标准（parameter scoring）获得各项指标的得分。</p><ul><li><strong>精度</strong>是指被分类器<strong>正确分类的样本数量</strong>占<strong>分类器总分类样本数量</strong>的百分比（分类器分类结果中，有一些样本分错了）</li><li><strong>召回率</strong>是指被<strong>应正确分类的样本数量</strong>占<strong>某分类总样本数量的百分比</strong>（有一些样本属于某分类，但分类器却没有分出来）</li><li><strong>F1 score</strong>是精度和召回率的合成指标，实际上是<strong>精度和召回率的调和均值（harmonic mean）</strong>，计算方式为F1 score＝2×精度×召回率 / (精度＋召回率)</li></ul><p>通过一个例子来详细说明这三个指标：</p><p>假设数据集有100个样本，其中有82个样本是我们感兴趣的，现在想用分类器选出这82个样本。最终，分类器选出了73个样本，它认为都是我们感兴趣的。在这73个样本中，其实只有65个样本是我们感兴趣的，剩下的8个样本我们不感兴趣，是分类器分错了。可以如下方法计算分类器的精度：</p><ul><li>分类正确的样本数量 = 65</li><li>总分类样本数量 = 73</li><li>精度 = 65 / 73 = 89.04%</li></ul><p>召回率的计算过程如下：</p><ul><li>数据集中我们感兴趣的样本数量 = 82</li><li>分类正确的样本数量 = 65</li><li>召回率 = 65 / 82 = 79.26%</li></ul><p>一个给力的机器学习模型需要同时具备良好的精度和召回率。这两个指标是<strong>二律背反</strong>的，<b>一个指标达到100%，那么另一个指标就会非常差！</b>我们需要保持两个指标能够同时处于合理高度。为了量化两个指标的均衡性，引入了 F1得分指标，是精度和召回率的合成指标，实际上是精度和召回率的调和均值（harmonic mean）：</p><p>F1 score＝2×精度×召回率 / (精度＋召回率)</p><p>上面示例中 F1得分的计算过程如下：</p><p>F1 score＝2×0.89×0.79 / (0.89＋0.79)＝0.8370</p><hr><p>来个代码实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.naive_bayes import GaussianNB</span><br><span class="line">from sklearn import model_selection</span><br><span class="line"></span><br><span class="line">classifier_gaussiannb = GaussianNB()</span><br><span class="line"></span><br><span class="line">num_validations = 5</span><br><span class="line"></span><br><span class="line"># 计算精度</span><br><span class="line">precision = model_selection.cross_val_score(classifier_gaussiannb, X, y, scoring=&apos;precision_weighted&apos;, cv=num_validations)</span><br><span class="line">print(&quot;Precision: &quot; + str(round(100*precision.mean(), 2)) + &quot;%&quot;)</span><br><span class="line"></span><br><span class="line"># 计算召回率</span><br><span class="line">recall = model_selection.cross_val_score(classifier_gaussiannb, X, y, scoring=&apos;recall_weighted&apos;, cv=num_validations)</span><br><span class="line">print(&quot;Recall: &quot; + str(round(100*recall.mean(), 2)) + &quot;%&quot;)</span><br><span class="line"></span><br><span class="line"># 计算F1 得分</span><br><span class="line">f1 = model_selection.cross_val_score(classifier_gaussiannb, X, y, scoring=&apos;f1_weighted&apos;, cv=num_validations)</span><br><span class="line">print(&quot;F1 score: &quot; + str(round(100*f1.mean(), 2)) + &quot;%&quot;)</span><br></pre></td></tr></table></figure><p>（上述代码来自书本《Python 机器学习经典实例》）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;交叉验证&lt;/strong&gt;是机器学习的重要概念。&lt;/p&gt;
&lt;p&gt;为了能够让模型更加稳定，需要用数据集的不同子集进&lt;strong&gt;行反复的验证&lt;/strong&gt;。如果只是对特定的子集进行微调，最终可能会&lt;strong&gt;过度拟合（overfitting）模型&lt;/
      
    
    </summary>
    
      <category term="Machine Learning" scheme="http://www.duanmuxu.top/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://www.duanmuxu.top/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop Streaming中reduce的多路输出</title>
    <link href="http://www.duanmuxu.top/20190924/multiple-output-of-reduce-in-hadoop-streaming.html"/>
    <id>http://www.duanmuxu.top/20190924/multiple-output-of-reduce-in-hadoop-streaming.html</id>
    <published>2019-09-23T17:03:15.834Z</published>
    <updated>2019-09-23T17:04:54.194Z</updated>
    
    <content type="html"><![CDATA[<p>上一章说到，Hadoop Streaming能使用任何编程语言编写MR程序，使MR计算框架不再拘泥于Java这一单独的语言，但是这也有一定的局限性，比如说Hadoop Streaming需要有该编程语言的标准输入输出，对多路输出不够友好。一般reduce输出的文件格式为：part-00000,part-00001…，文件个数为reduce的任务个数。</p><p>但是有时候我们需要用到多路输出的需求，比如输出的数据可能一部分要作为下一个MR任务的输入文件，另一部分直接供下游任务抓取。那么就一定不能实现reduce多路输出吗，答案是否定的，我们可以使用 <strong>-outputformat org.apache.hadoop.mapred.lib.SuffixMultipleTextOutputFormat</strong> 或者 <strong>-outputformat<br>org.apache.hadoop.mapred.lib.SuffixMultipleSequenceFileOutputFormat</strong>指定使用带多输出的OutputFormat，前者对应于文本输入，后者于二进制输入。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>reduce输出文件格式一般为part-xxxxx-X文件，其中X是A-Z的字母之一，使用方式是在输出key,value对的时候，在value的后面追加”#X”两个字节后缀，后缀不同的key,value输出到不同的part-xxxxx-X文件，value的后缀”#X”在kv输入文件时会自动删除。</p><p>此时，需要特别注意的是，由于value之后 #X 才会识别为输出文件标示，而reduce的输出默认以”\t”分割key和value，因此，如果reduce的输出是一行中间没有”\t”，我们就需要在#X后缀前面添加”\t”使它变成value的一部分而不是key的一部分，也可以通过 <strong>-D stream.reduce.output.field.separator</strong>指定reduce输出分割符的类型。 </p><blockquote><p>题外话：-D stream.reduce.output.field.separator 和 -jobconf suffix.multiple.outputformat.separator 的区别</p></blockquote><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-D stream.reduce.output.field.separator</td><td>reduce中key与value的分隔符</td></tr><tr><td>-jobconf suffix.multiple.outputformat.separator</td><td>value与文件名的分割符，默认为“#”，如果value本身含有“#”，则可以通过该参数设置其他的分隔符</td></tr></tbody></table><h3 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># run.sh</span><br><span class="line">$&#123;HADOOP_BIN&#125; streaming \</span><br><span class="line">    -input &quot;$&#123;INPUT&#125;&quot; \</span><br><span class="line">    -output &quot;$&#123;OUT_DIR&#125;&quot; \</span><br><span class="line">    -cacheArchive &quot;$&#123;TOOL_DIR&#125;/python2.7.2.tgz&quot;&quot;#.&quot; \</span><br><span class="line">    -file &quot;mapper_worker.sh&quot; \</span><br><span class="line">    -file &quot;reducer_worker.py&quot; \</span><br><span class="line">    -mapper &quot;python2.7.2/bin/python mapper_worker.sh&quot; \</span><br><span class="line">    -reducer &quot;python2.7.2/bin/python reducer_worker.py&quot; \</span><br><span class="line">    -inputformat &quot;org.apache.hadoop.mapred.TextInputFormat&quot; \</span><br><span class="line">    -outputformat &quot;org.apache.hadoop.mapred.lib.SuffixMultipleTextOutputFormat&quot; \</span><br><span class="line">    -jobconf mapred.job.priority=&quot;NORMAL&quot; \</span><br><span class="line">    -jobconf mapred.job.name=&quot;$&#123;TASK_NAME&#125;&quot; \</span><br><span class="line">    -jobconf mapred.map.tasks=&quot;$&#123;MAP_NUM&#125;&quot; \</span><br><span class="line">    -jobconf mapred.reduce.tasks=&quot;$&#123;REDUCE_NUM&#125;&quot; \</span><br><span class="line">    -jobconf mapred.max.split.size=134217728 \</span><br><span class="line">    -jobconf mapred.map.memory.limit=&quot;800&quot; \</span><br><span class="line">    -jobconf mapred.reduce.memory.limit=&quot;500&quot; \</span><br><span class="line">    -jobconf mapred.job.map.capacity=&quot;3500&quot; \</span><br><span class="line">    -jobconf mapred.job.reduce.capacity=&quot;2000&quot; \</span><br><span class="line">    -jobconf mapred.job.keep.files.hours=12 \</span><br><span class="line">    -jobconf mapred.max.map.failures.percent=1 \</span><br><span class="line">    -jobconf mapred.reduce.tasks.speculative.execution=&quot;false&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mapper_worker.py</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    print line</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># reducer_worker.py</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    record = line.strip()</span><br><span class="line">    fields = record.split(&apos;\t&apos;)</span><br><span class="line">    if len(fields) != 7:</span><br><span class="line">        continue</span><br><span class="line">    vcpurl, playurl, title, poster, duration, pubtime, accept = fields</span><br><span class="line">    duration = int(duration)</span><br><span class="line">    pubtime = int(pubtime)</span><br><span class="line">    accept = int(accept)</span><br><span class="line">    if duration &lt; 60:</span><br><span class="line">        print &apos;\t&apos;.join(record) + &quot;#A&quot;</span><br><span class="line">        # sys.stdout.write(&apos;%s#A\n&apos; %(record))</span><br><span class="line">    elif duration &lt; 300：</span><br><span class="line">        print &apos;\t&apos;.join(record) + &quot;#B&quot;</span><br><span class="line">        # sys.stdout.write(&apos;%s#B\n&apos; %(record))</span><br><span class="line">    else:</span><br><span class="line">        print &apos;\t&apos;.join(record) + &quot;#C&quot;</span><br><span class="line">        # sys.stdout.write(&apos;%s#C\n&apos; %(record))</span><br></pre></td></tr></table></figure><p>参考文献：<a href="https://blog.csdn.net/xiaolang85/article/details/8641137" target="_blank" rel="noopener">Hadoop Streaming实战： 多路输出</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一章说到，Hadoop Streaming能使用任何编程语言编写MR程序，使MR计算框架不再拘泥于Java这一单独的语言，但是这也有一定的局限性，比如说Hadoop Streaming需要有该编程语言的标准输入输出，对多路输出不够友好。一般reduce输出的文件格式为：p
      
    
    </summary>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop Streaming详解</title>
    <link href="http://www.duanmuxu.top/20190922/detailed-hadoop-streaming.html"/>
    <id>http://www.duanmuxu.top/20190922/detailed-hadoop-streaming.html</id>
    <published>2019-09-22T10:44:41.617Z</published>
    <updated>2019-09-22T10:48:00.581Z</updated>
    
    <content type="html"><![CDATA[<p>刚来公司的时候就发现大家都在使用Hadoop Streaming 来执行任务，当时还在想名字里有Streaming，Hadoop也拿来做实时计算工具了吗？后来发现原来只是我学得太少，对编程工具的理解太片面了。</p><p>那么接下来就来看看什么是Hadoop Streaming，为什么要使用Hadoop Streaming、Hadoop Streaming的原理以及怎么使用Hadoop Streaming。</p><h2 id="什么是Hadoop-Streaming"><a href="#什么是Hadoop-Streaming" class="headerlink" title="什么是Hadoop Streaming"></a>什么是Hadoop Streaming</h2><p>Hadoop Streaming是Hadoop提供的一个编程工具，由Hadoop提供。</p><h2 id="为什么使用Hadoop-Streaming"><a href="#为什么使用Hadoop-Streaming" class="headerlink" title="为什么使用Hadoop Streaming"></a>为什么使用Hadoop Streaming</h2><p>之前习惯了使用Hadoop框架来进行数据处理，Hadoop框架是用Java语言写的，也就是说如果想用Hadoop框架来执行MR任务，那么需要开发者会Java编程语言，这样子让不会Java语言的开发者怎么办？重新学习一门新语言吗，好像也不是不行(-，但是太麻烦啦，时间成本很高，因此Hadoop Streaming就出现啦！</p><p>Hadoop Streaming允许用户使用<strong>任何程序语言</strong>来编写mapreduce里的Mapper 和 Reducer函数，无论你会不会Java，只要会<strong>某种编程语言</strong>，都能通过Hadoop Streaming来编写MR程序（公司用的都是Python，为了合群只能先学习Python！）</p><h2 id="Hadoop-Streaming-局限性"><a href="#Hadoop-Streaming-局限性" class="headerlink" title="Hadoop Streaming 局限性"></a>Hadoop Streaming 局限性</h2><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>上面说到Hadoop Streaming支持任何语言来编写MR程序，这固然对开发者是十分友好的，但是它也有一定的局限性，即map/reduce函数的数据流必须遵循<strong>相应编程语言的标准输入输出</strong>（stdin、stdout），用什么编程语言实现业务逻辑，就必须要通过该语言的标准输入stdin读取数据，通过该语言的标准输出stdout输出数据。比方说如下的几种编程语言的输入输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># python标准输入输出</span><br><span class="line">import sys</span><br><span class="line">for line in sys.stdin:</span><br><span class="line">    后续操作</span><br><span class="line">    </span><br><span class="line">print (输出内容)</span><br><span class="line"></span><br><span class="line"># shell标准输入输出</span><br><span class="line">while read LINE; do</span><br><span class="line">    后续操作</span><br><span class="line">    </span><br><span class="line">echo &quot;输出内容&quot;</span><br><span class="line"></span><br><span class="line"># c语言标准输入输出</span><br><span class="line">char buffer[BUF_SIZE];</span><br><span class="line">while(fgets(buffer, BUF_SIZE - 1, stdin))&#123;</span><br><span class="line">  int len = strlen(buffer);</span><br><span class="line">  后续操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(输出内容)</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这种规定标准的输入输出，不能方便地处理<strong>多路输出</strong>。</p><h4 id="处理文本数据"><a href="#处理文本数据" class="headerlink" title="处理文本数据"></a>处理文本数据</h4><p>Hadoop Streaming默认只能处理<strong>文本数据Textfile</strong>，而对于二进制数据，较好的方法是将二进制的key、value进行base64编码，转化为文本在进行操作。</p><h4 id="多余的开销"><a href="#多余的开销" class="headerlink" title="多余的开销"></a>多余的开销</h4><p>用Java编写的MR程序直接处理框架从输入数据中得到的key/value对，而在Hadoop Streaming中Java程序不直接处理kv对，而是通过<strong>管道</strong>写到mapper的标准输入，mapper程序再从kv中解析出kv对，这个过程<strong>多了两次数据拷贝和解析（分割）</strong>，这会带来一定的开销。同理，对于reducer也一样。</p><h2 id="Hadoop-Streaming-原理"><a href="#Hadoop-Streaming-原理" class="headerlink" title="Hadoop Streaming 原理"></a>Hadoop Streaming 原理</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190920153532943.png" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><p>Streaming原理是用Java实现一个包装用户程序的MR程序，该程序负责调用MapReduce Java接口获取key/value键值对输入，创建一个新的进程启动包装的用户程序，将数据通过管道传递给包装的用户程序处理，然后调用MapReduce Java接口将用户程序的输出切分成kv对输出。</p><p>如上图所示，Streaming Java Mapper通过管道将key/value输入传递给用户mapper的标准输入，并获取mapper的标准输出；Streaming Java Reducer调用Java接口通过InputFormat从HDFS获取输入数据，从管道将kv传递给用户reducer程序的标准输入，获取reducer的标准输出并调用Java接口通过OutputFormat输出数据。</p><p>shuffle和sort阶段，和一般的MapReduce作业流程一样,经过此阶段的操作然后到达Reducer。</p><h2 id="怎么使用Hadoop-Streaming"><a href="#怎么使用Hadoop-Streaming" class="headerlink" title="怎么使用Hadoop Streaming"></a>怎么使用Hadoop Streaming</h2><p>参数说明：</p><ul><li>-input <path></path>：指定作业输入，path可以是文件或者目录，可以使用*通配符，-input选项可以使用多次指定多个文件或目录作为输入</li><li>-output <path></path>：指定作业输出目录，path必须不存在，而且执行作业的用户必须有创建该目录的权限，-output只能使用一次</li><li>-mapper：指定mapper可执行程序，必须指定且唯一</li><li>-reducer：指定reducer可执行程序，必须指定且唯一</li><li>-file, -cacheFile, -cacheArchive：分别用于向计算节点分发本地文件、HDFS文件和HDFS压缩文件</li><li>-numReduceTasks：指定reducer的个数，如果设置-numReduceTasks 0或者-reducer NONE则没有reducer程序，mapper的输出直接作为整个作业的输出</li><li>-combiner：指定combiner Java类，对应的Java类文件打包成jar文件后用-file分发</li><li>-inputformat, -outputformat：指定inputformat和outputformat Java类，用于读取输入数据和写入输出数据，分别要实现InputFormat和OutputFormat接口。如果不指定，默认使用TextInputFormat和TextOutputFormat</li><li>-partitioner：指定partitioner Java类，Streaming提供了一些实用的partitioner实现，参考KeyBasedFiledPartitoner和IntHashPartitioner</li><li>-cmdenv NAME=VALUE：给mapper和reducer程序传递额外的环境变量，NAME是变量名，VALUE是变量值</li><li>-mapdebug, -reducedebug：分别指定mapper和reducer程序失败时运行的debug程序</li><li>-verbose：指定输出详细信息，例如分发哪些文件，实际作业配置参数值等，可以用于调试</li><li>-jobconf || -D NAME=VALUE ：指定作业参数，NAME是参数名，VALUE是参数值，可以指定的参数参考hadoop-default.xml。作业参数详解：</li></ul><table><thead><tr><th>配置参数</th><th>参数详情</th></tr></thead><tbody><tr><td>mapred.job.name</td><td>作业名</td></tr><tr><td>mapred.job.priority</td><td>作业优先级</td></tr><tr><td>mapred.job.map.capacity</td><td>最多同时运行map任务数</td></tr><tr><td>mapred.job.reduce.capacity</td><td>最多同时运行reduce任务数</td></tr><tr><td>hadoop.job.ugi</td><td>作业执行权限</td></tr><tr><td>mapred.map.tasks</td><td>map任务个数</td></tr><tr><td>mapred.reduce.tasks</td><td>reduce任务个数</td></tr><tr><td>mapred.job.groups</td><td>作业可运行的计算节点分组</td></tr><tr><td>mapred.task.timeout</td><td>任务没有响应（输入输出）的最大时间</td></tr><tr><td>mapred.compress.map.output</td><td>map的输出是否压缩</td></tr><tr><td>mapred.map.output.compression.codec</td><td>map的输出压缩方式</td></tr><tr><td>mapred.output.compress</td><td>reduce的输出是否压缩</td></tr><tr><td>mapred.output.compression.codec</td><td>reduce的输出压缩方式</td></tr><tr><td>stream.map.output.field.separator</td><td>map输出分隔符</td></tr></tbody></table><p>这其中特别建议用-jobconf mapred.job.name=’My Job Name’设置作业名，使用-jobconf mapred.job.priority=VERY_HIGH | HIGH | NORMAL | LOW | VERY_LOW设置作业优先级，使用-jobconf mapred.job.map.capacity=M设置同时最多运行M个map任务，使用-jobconf mapred.job.reduce.capacity=N设置同时最多运行N个reduce任务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚来公司的时候就发现大家都在使用Hadoop Streaming 来执行任务，当时还在想名字里有Streaming，Hadoop也拿来做实时计算工具了吗？后来发现原来只是我学得太少，对编程工具的理解太片面了。&lt;/p&gt;
&lt;p&gt;那么接下来就来看看什么是Hadoop Stream
      
    
    </summary>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/categories/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记07</title>
    <link href="http://www.duanmuxu.top/20190812/python-study-notes-07.html"/>
    <id>http://www.duanmuxu.top/20190812/python-study-notes-07.html</id>
    <published>2019-08-12T15:47:51.284Z</published>
    <updated>2019-08-12T15:49:04.153Z</updated>
    
    <content type="html"><![CDATA[<p>convert_types.py 脚本中保存了一个列表，列表中存放的是pv行为，如：[‘离线动作-列表页-到这里去    1’,’离线动作-图区-搜周边    2’,’离线动作-图区-到这里去    1’…]</p><p>今天想要将 convert_types.py 里的pv行为全部都放在excel表里，行为名称和行为编号分开存放，于是使用pandas 中的dataframe结构存放数据，再将dataframe的数据写入excel文件中，代码写好后运行程序却报了以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe5 in position 7: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>查阅资料后解决了以下两个问题</p><h2 id="dataframe-如何写入数据到excel-文件中"><a href="#dataframe-如何写入数据到excel-文件中" class="headerlink" title="dataframe 如何写入数据到excel 文件中"></a>dataframe 如何写入数据到excel 文件中</h2><h3 id="单个dataframe-写入数据到excel-文件中"><a href="#单个dataframe-写入数据到excel-文件中" class="headerlink" title="单个dataframe 写入数据到excel 文件中"></a>单个dataframe 写入数据到excel 文件中</h3><p>将整个dataframe 写入excel 文件，直接调用dataframe的to_excel()函数即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># result 为结果列表，将列表转化为DataFrame类型数据</span><br><span class="line">df = pd.DataFrame(result)</span><br><span class="line">df.to_excel(&apos;filePath&apos;,sheet_name=&apos;sheetname&apos;)</span><br></pre></td></tr></table></figure><p>to_excel()参数解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataFrame.to_excel(excel_writer, sheet_name=&apos;Sheet1&apos;, na_rep=&apos;&apos;,</span><br><span class="line"> float_format=None, columns=None, header=True, index=True, </span><br><span class="line"> index_label=None, startrow=0, startcol=0, engine=None, </span><br><span class="line"> merge_cells=True, encoding=None, inf_rep=&apos;inf&apos;, verbose=True, </span><br><span class="line"> freeze_panes=None)</span><br></pre></td></tr></table></figure><p><strong>excel_writer</strong> : 字符串或ExcelWriter 对象——文件路径或现有的ExcelWriter</p><p><strong>sheet_name</strong> :字符串,默认“Sheet1”——将包含DataFrame的表的名称。</p><p>na_rep : 字符串,默认‘ ’——缺失数据表示方式</p><p>float_format : 字符串,默认None——格式化浮点数的字符串</p><p><strong>columns</strong> : 序列,可选——要编写的列</p><p>header : 布尔或字符串列表，默认为Ture。——写出列名。如果给定字符串列表，则假定它是列名称的别名。</p><p><strong>index</strong> :布尔,默认的Ture——写行名（索引）</p><p>index_label : 字符串或序列，默认为None。——如果需要，可以使用索引列的列标签。如果没有给出，标题和索引为true，则使用索引名称。如果数据文件使用多索引，则需使用序列。</p><p><strong>startrow</strong> :——左上角的单元格行来转储数据框</p><p><strong>startcol</strong> :——左上角的单元格列转储数据帧</p><p>engine : 字符串,默认没有——使用写引擎-也可以通过选项io.excel.xlsx.writer，io.excel.xls.writer和io.excel.xlsm.writer进行设置。</p><p>merge_cells : 布尔,默认为Ture——编码生成的excel文件。只有xlwt需要，其他编写者本地支持unicode。</p><p>inf_rep : 字符串,默认“正”——无穷大的表示(在Excel中不存在无穷大的本地表示)</p><p>freeze_panes : 整数的元组(长度2)，默认为None。——指定要冻结的基于1的最底部行和最右边的列</p><h3 id="多个DataFrame-分为多个表写入同一个excel-文件中"><a href="#多个DataFrame-分为多个表写入同一个excel-文件中" class="headerlink" title="多个DataFrame 分为多个表写入同一个excel 文件中"></a>多个DataFrame 分为多个表写入同一个excel 文件中</h3><p>需要通过ExcelWriter()方法打开一个已经存在的excel表格作为writer，然后通过to_excel()方法将需要保存的数据逐个写入excel，最后关闭writer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write = pd.ExcelWriter(&apos;filePath&apos;)</span><br><span class="line">df = pd.DataFrame(result)</span><br><span class="line">df1 = df.copy()</span><br><span class="line">df.to_excel(write, sheet_name=&apos;data1&apos;)</span><br><span class="line">df1.to_excel(write, sheet_name=&apos;data2&apos;)</span><br><span class="line">write.save()</span><br></pre></td></tr></table></figure><p>结果为excel 表中有表名为’data1’和’data2’的两张小表</p><h3 id="多个DataFrame-写入一个excel-文件同一个表中"><a href="#多个DataFrame-写入一个excel-文件同一个表中" class="headerlink" title="多个DataFrame 写入一个excel 文件同一个表中"></a>多个DataFrame 写入一个excel 文件同一个表中</h3><p>数据定义与上一个相同，只不过需要更改to_excel()函数中的参数而已</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write = pd.ExcelWriter(&apos;filePath&apos;)</span><br><span class="line">df = pd.DataFrame(result)</span><br><span class="line">df1 = df.copy()</span><br><span class="line">df.to_excel(write, sheet_name=&apos;data&apos;,startrow = 10)</span><br><span class="line">df1.to_excel(write, sheet_name=&apos;data&apos;, startrow = 30, startcol = 10)</span><br><span class="line">write.save()</span><br></pre></td></tr></table></figure><p>df数据从表格的第十行开始插入</p><p>df1数据从表格的第三十行和第十列开始插入</p><p>注意第二个数据插入的地方不能有其他数据，否则数据会覆盖。</p><h2 id="sys-setdefaultencoding-‘utf-8’-的使用"><a href="#sys-setdefaultencoding-‘utf-8’-的使用" class="headerlink" title="sys.setdefaultencoding(‘utf-8’)的使用"></a>sys.setdefaultencoding(‘utf-8’)的使用</h2><p>Python 里面的编码和解码也就是 unicode 和 str 这两种形式的相互转化。编码是 unicode -&gt; str，相反的，解码就是 str -&gt; unicode。剩下的问题就是确定何时需要进行编码或者解码了。</p><p>关于文件开头的”编码指示”，也就是 # -*- coding: -*- 这个语句。Python 默认脚本文件都是 UTF-8 编码的，当文件中有非 UTF-8 编码范围内的字符的时候就要使用”编码指示”来修正。关于 sys.defaultencoding，这个在<strong>解码没有明确指明解码方式</strong>的时候使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env python </span><br><span class="line"># -*- coding: utf-8 -*- </span><br><span class="line"># 注意这里的 s 是 str 类型的，而不是 unicode </span><br><span class="line">s = &apos;中文&apos;  </span><br><span class="line">s.encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure><p>这句代码将 s 重新编码为 gb18030 的格式，即进行 unicode -&gt; str 的转换。因为 s 本身就是 str 类型的，因此 Python 会自动的先将 s 解码为 unicode ，然后再编码成 gb18030。因为解码是python自动进行的，我们没有指明解码方式，python 就会使用 sys.defaultencoding 指明的方式来解码。很多情况下 sys.defaultencoding 是<br>ANSCII，如果 s 不是这个类型就会出错。拿上面的情况来说，sys.defaultencoding 是 anscii，而 s 的编码方式和文件的编码方式一致，是 utf8 的，所以出错了: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure><p>出现这种情况时有两种方法来解决：</p><h4 id="明确的指示出-s-的编码方式"><a href="#明确的指示出-s-的编码方式" class="headerlink" title="明确的指示出 s 的编码方式"></a>明确的指示出 s 的编码方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># 注意这里的 s 是 str 类型的，而不是 unicode</span><br><span class="line">s = &apos;中文&apos;  </span><br><span class="line">s.decode(&apos;utf8&apos;).encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure><p>先用 utf-8 解码，再用 gb18030 编码，就不会出错了</p><h4 id="更改-sys-defaultencoding-为文件的编码方式"><a href="#更改-sys-defaultencoding-为文件的编码方式" class="headerlink" title="更改 sys.defaultencoding 为文件的编码方式"></a>更改 sys.defaultencoding 为文件的编码方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf-8&apos;)</span><br><span class="line"></span><br><span class="line"># 注意这里的 s 是 str 类型的，而不是 unicode</span><br><span class="line">s = &apos;中文&apos;  </span><br><span class="line">s.encode(&apos;gb18030&apos;)</span><br></pre></td></tr></table></figure><p>这是个固定用法，Python2.5 初始化后删除了 sys.setdefaultencoding 方法，所以需要重新载入 sys </p><h2 id="dataframe-read-excel"><a href="#dataframe-read-excel" class="headerlink" title="dataframe.read_excel()"></a>dataframe.read_excel()</h2><p>顺带说一下使用dataframe读取excel文件的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_excel(io, sheetname=0, header=0, skiprows=None, skip_footer=0, index_col=None,names=None, parse_cols=None, parse_dates=False,date_parser=None,na_values=None,thousands=None, convert_float=True, has_index_names=None, converters=None,dtype=None, true_values=None, false_values=None, engine=None, squeeze=False, **kwds)</span><br></pre></td></tr></table></figure><p>常用参数解析：</p><ul><li>io : string, path object ; excel 路径。</li><li>sheetname : string, int, mixed list of strings/ints, or None, default 0 返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe</li><li>header : int, list of ints, default 0 指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None</li><li>skiprows : list-like,Rows to skip at the beginning，省略指定行数的数据</li><li>skip_footer : int,default 0, 省略从尾部数的int行数据</li><li>index_col : int, list of ints, default None指定列为索引列，也可以使用u’strings’</li><li>names : array-like, default None, 指定列的名字。</li></ul><p>附上完整代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/env python</span><br><span class="line"># -*- coding=utf-8 -*-</span><br><span class="line">import pandas as pd</span><br><span class="line">import convert_types</span><br><span class="line">import sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf8&apos;)</span><br><span class="line"></span><br><span class="line">key = []</span><br><span class="line">value = []</span><br><span class="line">list = convert_types.list</span><br><span class="line">for i in range(len(list)):</span><br><span class="line">    key.append(list[i].strip().split(&apos;\t&apos;)[0])</span><br><span class="line">    value.append(list[i].strip().split(&apos;\t&apos;)[1])</span><br><span class="line"></span><br><span class="line">result=&#123;&quot;名称&quot;:key, &quot;数值&quot;:value&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(result)</span><br><span class="line">df.to_excel(&apos;/Users/v_huruijie/Documents/sug/sug.xlsx&apos;,sheet_name=&apos;convert_types.py&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;convert_types.py 脚本中保存了一个列表，列表中存放的是pv行为，如：[‘离线动作-列表页-到这里去    1’,’离线动作-图区-搜周边    2’,’离线动作-图区-到这里去    1’…]&lt;/p&gt;
&lt;p&gt;今天想要将 convert_types.py 里的
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记06</title>
    <link href="http://www.duanmuxu.top/20190805/python-study-notes-06.html"/>
    <id>http://www.duanmuxu.top/20190805/python-study-notes-06.html</id>
    <published>2019-08-05T14:16:23.309Z</published>
    <updated>2019-08-05T14:17:11.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-JSON"><a href="#Python-JSON" class="headerlink" title="Python JSON"></a>Python JSON</h1><h2 id="JSON函数"><a href="#JSON函数" class="headerlink" title="JSON函数"></a>JSON函数</h2><p>使用 JSON 函数需要导入 json 库：<strong>import json</strong></p><ul><li>json.dumps:将 Python 对象编码成 JSON 字符串</li><li>json.loads:将已编码的 JSON 字符串解码为 Python 对象</li><li>encode:将 Python 对象编码成 JSON 字符串</li><li>decode:将已编码的 JSON 字符串解码为 Python 对象</li></ul><h3 id="json-dumps"><a href="#json-dumps" class="headerlink" title="json.dumps"></a>json.dumps</h3><p>json.dumps 用于将 Python 对象编码成 JSON 字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>obj: Python 对象</li><li>skipkeys: skipkeys可以跳过那些非string对象当作key的处理。在encoding过程中，dict对象的key只可以是string对象，如果是其他类型，那么在编码过程中就会抛出ValueError的异常</li><li>ensure_ascii: 如果obj里包括非ASCII码,True时,编成ASCII码;    False时,不进行编码,原样输出。json.dumps 序列化时对中文默认使用的ascii编码，输出的为ascii码值，而不是中文。当设置ensure_ascii==FALSE 时，输出即为中文</li><li>check_circular: 默认为True，值为False时,”循环引用检查”对容器类型跳过检查,并且也可能导致溢出错误/或者更糟</li><li>allow_nan: 默认为True，值为False时,对于序列化超出范围的float值,严格遵守JSON规范,将是一个ValueError而不是使用JavaScript等价物(NaN,Infinity,-Infinity)</li><li>indent: 根据数据格式缩进显示，读起来更加清晰, indent的值，代表缩进空格式</li><li>separators: 去掉‘，’ ‘：’后面的空格，在传输数据的过程中，越精简越好，冗余的东西全部去掉</li><li>default: 是一个函数,该函数能够把自定义类型的对象转换成可序列化的基本类型</li><li>sort_keys: 告诉编码器按照字典key排序(a到z)输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; data = [ &#123; &apos;a&apos; : 1, &apos;b&apos; : 2, &apos;c&apos; : 3, &apos;d&apos; : 4, &apos;e&apos; : 5 &#125; ]</span><br><span class="line">&gt;&gt;&gt; json=json.dumps(data)</span><br><span class="line">&gt;&gt;&gt; print json</span><br><span class="line">[&#123;&quot;a&quot;: 1, &quot;c&quot;: 3, &quot;b&quot;: 2, &quot;e&quot;: 5, &quot;d&quot;: 4&#125;]</span><br><span class="line">&gt;&gt;&gt; data</span><br><span class="line">[&#123;&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2, &apos;e&apos;: 5, &apos;d&apos;: 4&#125;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print json.dumps(data, sort_keys=True, indent=2, separators=(&apos;,&apos;, &apos;: &apos;))</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;a&quot;: 1,</span><br><span class="line">    &quot;b&quot;: 2,</span><br><span class="line">    &quot;c&quot;: 3,</span><br><span class="line">    &quot;d&quot;: 4,</span><br><span class="line">    &quot;e&quot;: 5</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="json-loads"><a href="#json-loads" class="headerlink" title="json.loads"></a>json.loads</h3><p>json.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]])</span><br></pre></td></tr></table></figure><p>参数解释：</p><ul><li>s: 待解码的 JSON 数据</li><li>encoding: 编码方式</li><li>object_hook: 该函数负责把反序列化后的基本类型对象转换成自定义类型的对象</li><li>parse_float: 如果指定，将调用每个JSON浮点的字符串进行解码。默认情况下，这相当于浮点（NUMYSTR）。这可以用于使用另一个数据类型或解析器用于JSON浮点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; jData=&apos;&#123;&apos;username&apos;:&apos;李华&apos;,&apos;sex&apos;:&apos;male&apos;,&apos;age&apos;:16&#125;&apos;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    jData=&apos;&#123;&apos;username&apos;:&apos;李华&apos;,&apos;sex&apos;:&apos;male&apos;,&apos;age&apos;:16&#125;&apos;</span><br><span class="line">                    ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; import json</span><br><span class="line">&gt;&gt;&gt; jData=&apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3, &quot;d&quot;:4&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; result=json.loads(jData)</span><br><span class="line">&gt;&gt;&gt; print result</span><br><span class="line">&#123;u&apos;a&apos;: 1, u&apos;c&apos;: 3, u&apos;b&apos;: 2, u&apos;d&apos;: 4&#125;</span><br><span class="line">&gt;&gt;&gt; result</span><br><span class="line">&#123;u&apos;a&apos;: 1, u&apos;c&apos;: 3, u&apos;b&apos;: 2, u&apos;d&apos;: 4&#125;</span><br><span class="line">&gt;&gt;&gt; type(result)</span><br><span class="line">&lt;type &apos;dict&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(jData)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h3><p>Python encode() 函数用于将 Python 对象编码成 JSON 字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demjson.encode(self, obj, nest_level=0)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import demjson</span><br><span class="line">&gt;&gt;&gt; data = [ &#123; &apos;a&apos; : 1, &apos;b&apos; : 2, &apos;c&apos; : 3, &apos;d&apos; : 4, &apos;e&apos; : 5 &#125; ]</span><br><span class="line">&gt;&gt;&gt; result = demjson.encode(data)</span><br><span class="line">&gt;&gt;&gt; print result</span><br><span class="line">[&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;]</span><br><span class="line">&gt;&gt;&gt; type(result)</span><br><span class="line">&lt;type &apos;unicode&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(data)</span><br><span class="line">&lt;type &apos;list&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="decode"><a href="#decode" class="headerlink" title="decode"></a>decode</h3><p>Python 可以使用 demjson.decode() 函数解码 JSON 数据。该函数返回 Python 字段的数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demjson.decode(self, txt)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import demjson</span><br><span class="line">&gt;&gt;&gt; jdata=&apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&apos;</span><br><span class="line">&gt;&gt;&gt; result=demjson.decode(jdata)</span><br><span class="line">&gt;&gt;&gt; print result</span><br><span class="line">&#123;u&apos;a&apos;: 1, u&apos;c&apos;: 3, u&apos;b&apos;: 2, u&apos;e&apos;: 5, u&apos;d&apos;: 4&#125;</span><br><span class="line">&gt;&gt;&gt; type(result)</span><br><span class="line">&lt;type &apos;dict&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; type(jdata)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-JSON&quot;&gt;&lt;a href=&quot;#Python-JSON&quot; class=&quot;headerlink&quot; title=&quot;Python JSON&quot;&gt;&lt;/a&gt;Python JSON&lt;/h1&gt;&lt;h2 id=&quot;JSON函数&quot;&gt;&lt;a href=&quot;#JSON函数&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记05</title>
    <link href="http://www.duanmuxu.top/20190804/python-study-notes-05.html"/>
    <id>http://www.duanmuxu.top/20190804/python-study-notes-05.html</id>
    <published>2019-08-04T07:52:58.444Z</published>
    <updated>2019-08-04T07:54:11.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="re-match函数"><a href="#re-match函数" class="headerlink" title="re.match函数"></a>re.match函数</h2><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.match(pattern, string, flags=0)</span><br></pre></td></tr></table></figure><ul><li>pattern：匹配的正则表达式</li><li>string：要匹配的字符串。</li><li>flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</li></ul><p>匹配成功re.match方法返回一个匹配的对象，否则返回None。</p><p>使用group(num) 或 groups() 匹配对象函数来获取匹配表达式</p><ul><li>group(num=0):匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。</li><li>groups():返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">print(re.match(&apos;www&apos;, &apos;www.baidu.com&apos;).span())  # 在起始位置匹配</span><br><span class="line">print(re.match(&apos;com&apos;, &apos;www.baidu.com&apos;))         # 不在起始位置匹配</span><br><span class="line"></span><br><span class="line">line = &quot;Cats are smarter than dogs&quot;</span><br><span class="line"> </span><br><span class="line">matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I)</span><br><span class="line"> </span><br><span class="line">if matchObj:</span><br><span class="line">   print &quot;matchObj.group() : &quot;, matchObj.group()</span><br><span class="line">   print &quot;matchObj.group(1) : &quot;, matchObj.group(1)</span><br><span class="line">   print &quot;matchObj.group(2) : &quot;, matchObj.group(2)</span><br><span class="line">else:</span><br><span class="line">   print &quot;No match!!&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">(0, 3)</span><br><span class="line">None</span><br><span class="line">matchObj.group() :  Cats are smarter than dogs</span><br><span class="line">matchObj.group(1) :  Cats</span><br><span class="line">matchObj.group(2) :  smarter</span><br></pre></td></tr></table></figure><h3 id="r-39-are-39-解析"><a href="#r-39-are-39-解析" class="headerlink" title="r&#39;(.*) are (.*?) .*&#39; 解析"></a>r&#39;(.*) are (.*?) .*&#39; 解析</h3><ul><li>r 表示字符串为非转义的原始字符串，让编译器忽略反斜杠，也就是忽略转义字符。但是这个字符串里没有反斜杠，所以这个 r 可有可无。</li><li>(.*) 第一个匹配分组，.* 代表匹配除换行符之外的所有字符</li><li>(.*?) 第二个匹配分组，.*? 后面多个问号，代表非贪婪模式，也就是说只匹配符合条件的最少字符</li><li>后面的一个 .* 没有括号包围，所以不是分组，匹配效果和第一个一样，但是不计入匹配结果中。</li><li>matchObj.group() 等同于 matchObj.group(0)，表示匹配到的完整文本字符</li><li>matchObj.group(1) 得到第一组匹配结果，也就是(.*)匹配到的</li><li>matchObj.group(2) 得到第二组匹配结果，也就是(.*?)匹配到的</li></ul><p>因为只有匹配结果中只有两组，所以如果填 3 时会报错。</p><h2 id="re-search方法"><a href="#re-search方法" class="headerlink" title="re.search方法"></a>re.search方法</h2><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern, string, flags=0)</span><br></pre></td></tr></table></figure><p>匹配成功re.search方法返回一个匹配的对象，否则返回None</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">print(re.search(&apos;www&apos;, &apos;www.baidu.com&apos;).span())  # 在起始位置匹配</span><br><span class="line">print(re.search(&apos;com&apos;, &apos;www.baidu.com&apos;).span())  # 不在起始位置匹配</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输出：</span><br><span class="line">(0, 3)</span><br><span class="line">(11, 14)</span><br></pre></td></tr></table></figure><h2 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h2><p>re.match<strong>只匹配字符串的开始</strong>，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">line = &quot;Cats are smarter than dogs&quot;;</span><br><span class="line"> </span><br><span class="line">matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)</span><br><span class="line">if matchObj:</span><br><span class="line">   print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group()</span><br><span class="line">else:</span><br><span class="line">   print &quot;No match!!&quot;</span><br><span class="line"> </span><br><span class="line">matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)</span><br><span class="line">if matchObj:</span><br><span class="line">   print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group()</span><br><span class="line">else:</span><br><span class="line">   print &quot;No match!!&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输出：</span><br><span class="line">No match!!</span><br><span class="line">search --&gt; matchObj.group() :  dogs</span><br></pre></td></tr></table></figure><h2 id="检索和替换"><a href="#检索和替换" class="headerlink" title="检索和替换"></a>检索和替换</h2><p>re.sub用于替换字符串中的匹配项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern, repl, string, count=0, flags=0)</span><br></pre></td></tr></table></figure><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">phone = &quot;2004-959-559 # 这是一个国外电话号码&quot;</span><br><span class="line"> </span><br><span class="line"># 删除字符串中的 Python注释 </span><br><span class="line">num = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone)</span><br><span class="line">print &quot;电话号码是: &quot;, num</span><br><span class="line"> </span><br><span class="line"># 删除非数字(-)的字符串 </span><br><span class="line">num = re.sub(r&apos;\D&apos;, &quot;&quot;, phone)</span><br><span class="line">print &quot;电话号码是 : &quot;, num</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输出：</span><br><span class="line">电话号码是:  2004-959-559 </span><br><span class="line">电话号码是 :  2004959559</span><br></pre></td></tr></table></figure><h2 id="re-compile-函数"><a href="#re-compile-函数" class="headerlink" title="re.compile 函数"></a>re.compile 函数</h2><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.compile(pattern[, flags])</span><br></pre></td></tr></table></figure><h2 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h2><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。<strong>match 和 search 是匹配一次 findall 匹配所有</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findall(string[, pos[, endpos]])</span><br></pre></td></tr></table></figure><ul><li>string : 待匹配的字符串。</li><li>pos : 可选参数，指定字符串的起始位置，默认为 0。</li><li>endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line"> </span><br><span class="line">pattern = re.compile(r&apos;\d+&apos;)   # 查找数字，用于匹配至少一个数字</span><br><span class="line">result1 = pattern.findall(&apos;baidu 123 google 456&apos;)</span><br><span class="line">result2 = pattern.findall(&apos;bai88bai123google456&apos;, 0, 10)</span><br><span class="line"> </span><br><span class="line">print(result1)</span><br><span class="line">print(result2)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 输出</span><br><span class="line">[&apos;123&apos;, &apos;456&apos;]</span><br><span class="line">[&apos;88&apos;, &apos;12&apos;]</span><br></pre></td></tr></table></figure><h2 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h2><p>和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个<strong>迭代器</strong>返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern, string, flags=0)</span><br></pre></td></tr></table></figure><h2 id="re-split"><a href="#re-split" class="headerlink" title="re.split"></a>re.split</h2><p>split 方法按照能够匹配的子串将字符串分割后返回列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(pattern, string[, maxsplit=0, flags=0])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import re</span><br><span class="line">&gt;&gt;&gt; re.split(&apos;\W+&apos;, &apos;baidu, baidu, baidu.&apos;)</span><br><span class="line">[&apos;baidu&apos;, &apos;baidu&apos;, &apos;baidu&apos;, &apos;&apos;]</span><br><span class="line">&gt;&gt;&gt; re.split(&apos;(\W+)&apos;, &apos; baidu, baidu, baidu.&apos;) </span><br><span class="line">[&apos;&apos;, &apos; &apos;, &apos;baidu&apos;, &apos;, &apos;, &apos;baidu&apos;, &apos;, &apos;, &apos;baidu&apos;, &apos;.&apos;, &apos;&apos;]</span><br><span class="line">&gt;&gt;&gt; re.split(&apos;\W+&apos;, &apos; baidu, baidu, baidu.&apos;, 1) </span><br><span class="line">[&apos;&apos;, &apos;baidu, baidu, baidu.&apos;]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; re.split(&apos;a*&apos;, &apos;hello world&apos;)   # 对于一个找不到匹配的字符串而言，split 不会对其作出分割</span><br><span class="line">[&apos;hello world&apos;]</span><br></pre></td></tr></table></figure><h2 id="正则表达式对象"><a href="#正则表达式对象" class="headerlink" title="正则表达式对象"></a>正则表达式对象</h2><h3 id="re-RegexObject"><a href="#re-RegexObject" class="headerlink" title="re.RegexObject"></a>re.RegexObject</h3><p>re.compile() 返回 RegexObject 对象。</p><h3 id="re-MatchObject"><a href="#re-MatchObject" class="headerlink" title="re.MatchObject"></a>re.MatchObject</h3><p>group() 返回被 RE 匹配的字符串。</p><ul><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li></ul><h2 id="正则表达式常用符号解释"><a href="#正则表达式常用符号解释" class="headerlink" title="正则表达式常用符号解释"></a>正则表达式常用符号解释</h2><ul><li>\ : 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\“ 而 “\(“ 则匹配 “(“</li><li>^ : 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline(多行匹配) 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置</li><li>$ : 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置</li><li>* : 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}</li><li><ul><li>: 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}</li></ul></li><li>? : 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}</li><li>{n} : n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o</li><li>{n,} : n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’</li><li>{n,m} : m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格，<strong>贪婪模式</strong></li><li>? : 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是<strong>非贪婪</strong>的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’</li><li>. : 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式</li><li>[…] : 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’</li><li>[^…] : 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</li><li>a| b : 匹配a或b</li><li>(?imx) : 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域</li><li>\w : 匹配字母数字及下划线</li><li>\W : 匹配非字母数字及下划线</li><li>\s : 匹配任意空白字符，等价于 [\t\n\r\f].</li><li>\S : 匹配任意非空字符，等价于 [^ \f\n\r\t\v]</li><li>\d : 匹配任意数字，等价于 [0-9].</li><li>\D : 匹配任意非数字，等价于 [^0-9].</li><li>\A : 匹配字符串开始</li><li>\Z : 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</li><li>\z : 匹配字符串结束</li><li>\G : 匹配最后匹配完成的位置。</li><li>\b : 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</li><li>\B : 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</li><li>\n, \t, 等. : 匹配一个换行符。匹配一个制表符。等</li><li>\1…\9 : 匹配第n个分组的内容。</li><li>\10 : 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</li></ul><h2 id="正则表达式修饰符-可选标志"><a href="#正则表达式修饰符-可选标志" class="headerlink" title="正则表达式修饰符 - 可选标志"></a>正则表达式修饰符 - 可选标志</h2><p>修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.L</td><td>做本地化识别（locale-aware）匹配</td></tr><tr><td>re.M</td><td>多行匹配，影响 ^ 和 $</td></tr><tr><td>re.S</td><td>使 . 匹配包括换行在内的所有字符</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</td></tr><tr><td>re.X</td><td>该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;re-match函数&quot;&gt;&lt;a href=&quot;#re-match函数&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记04</title>
    <link href="http://www.duanmuxu.top/20190802/python-study-notes-04.html"/>
    <id>http://www.duanmuxu.top/20190802/python-study-notes-04.html</id>
    <published>2019-08-02T15:20:00.795Z</published>
    <updated>2019-08-02T15:20:38.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><p>其实就是date和time 模块的结合， 常见的属性方法都比较常用<br>比如：<br>datetime.day,datetime.month,datetime.year 分别表示一个datetime对象的日，月，年</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">dt=datetime.now() #创建一个datetime类对象</span><br><span class="line">print dt.year,dt.month,dt.day</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">输出为：</span><br><span class="line">2019 8 1</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><h2 id="strftime-函数"><a href="#strftime-函数" class="headerlink" title="strftime()函数"></a>strftime()函数</h2><p>strftime() 用来格式化datetime 对象, 有时候会十分的方便：<br>先看一下格式： datetime.strftime(‘%’ ) %后面跟一个控制字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">dt = datetime.now()  </span><br><span class="line">print   &apos;时间：(%Y-%m-%d %H:%M:%S %f): &apos; , dt.strftime( &apos;%Y-%m-%d %H:%M:%S %f&apos; )  </span><br><span class="line">print   &apos;时间：(%Y-%m-%d %H:%M:%S %p): &apos; , dt.strftime( &apos;%y-%m-%d %I:%M:%S %p&apos; )  </span><br><span class="line">print   &apos;星期缩写%%a: %s &apos;  % dt.strftime( &apos;%a&apos; )  </span><br><span class="line">print   &apos;星期全拼%%A: %s &apos;  % dt.strftime( &apos;%A&apos; )  </span><br><span class="line">print   &apos;月份缩写%%b: %s &apos;  % dt.strftime( &apos;%b&apos; )  </span><br><span class="line">print   &apos;月份全批%%B: %s &apos;  % dt.strftime( &apos;%B&apos; )  </span><br><span class="line">print   &apos;日期时间%%c: %s &apos;  % dt.strftime( &apos;%c&apos; )  </span><br><span class="line">print   &apos;今天是这周的第%s天 &apos;  % dt.strftime( &apos;%w&apos; )  </span><br><span class="line">print   &apos;今天是今年的第%s天 &apos;  % dt.strftime( &apos;%j&apos; )  </span><br><span class="line">print   &apos;今周是今年的第%s周 &apos;  % dt.strftime( &apos;%U&apos; ) </span><br><span class="line">print   &apos;今天是当月的第%s天 &apos;  % dt.strftime( &apos;%d&apos; )</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">输出如下：</span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">时间：(%Y-%m-%d %H:%M:%S %f):  2019-08-01 19:49:49 347018</span><br><span class="line">时间：(%Y-%m-%d %H:%M:%S %p):  19-08-01 07:49:49 PM</span><br><span class="line">星期缩写%a: Thu </span><br><span class="line">星期全拼%A: Thursday </span><br><span class="line">月份缩写%b: Aug </span><br><span class="line">月份全批%B: August </span><br><span class="line">日期时间%c: Thu Aug  1 19:49:49 2019 </span><br><span class="line">今天是这周的第4天 </span><br><span class="line">今天是今年的第213天 </span><br><span class="line">今周是今年的第30周 </span><br><span class="line">今天是当月的第01天 </span><br><span class="line">---------------------------------------------------</span><br><span class="line">&apos;&apos;&apos;</span><br></pre></td></tr></table></figure><h2 id="Calendar模块"><a href="#Calendar模块" class="headerlink" title="Calendar模块"></a>Calendar模块</h2><p>获取月历日历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import calendar</span><br><span class="line">&gt;&gt;&gt; print calendar.month(2019, 8)</span><br><span class="line">    August 2019</span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">          1  2  3  4</span><br><span class="line"> 5  6  7  8  9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31</span><br></pre></td></tr></table></figure><h2 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h2><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p><h2 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h2><p>一个函数能处理比当初声明时更多的参数</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def functionname([formal_args,] *var_args_tuple ):</span><br><span class="line">   &quot;函数_文档字符串&quot;</span><br><span class="line">   function_suite</span><br><span class="line">   return [expression]</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"> </span><br><span class="line"># 可写函数说明</span><br><span class="line">def printinfo( arg1, *vartuple ):</span><br><span class="line">   &quot;打印任何传入的参数&quot;</span><br><span class="line">   print &quot;输出: &quot;</span><br><span class="line">   print arg1</span><br><span class="line">   for var in vartuple:</span><br><span class="line">      print var</span><br><span class="line">   return;</span><br><span class="line"> </span><br><span class="line"># 调用printinfo 函数</span><br><span class="line">printinfo( 10 );</span><br><span class="line">printinfo( 70, 60, 50 );</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">输出:</span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure><h2 id="os-模块操作文件和目录"><a href="#os-模块操作文件和目录" class="headerlink" title="os 模块操作文件和目录"></a>os 模块操作文件和目录</h2><h3 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h3><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。</p><h4 id="os-rename"><a href="#os-rename" class="headerlink" title="os.rename()"></a>os.rename()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line"># 重命名文件test1.txt到test2.txt。</span><br><span class="line">os.rename( &quot;test1.txt&quot;, &quot;test2.txt&quot; )</span><br></pre></td></tr></table></figure><h4 id="os-remove"><a href="#os-remove" class="headerlink" title="os.remove()"></a>os.remove()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line"># 删除一个已经存在的文件test2.txt</span><br><span class="line">os.remove(&quot;test2.txt&quot;)</span><br></pre></td></tr></table></figure><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><h4 id="mkdir-创建目录"><a href="#mkdir-创建目录" class="headerlink" title="mkdir() 创建目录"></a>mkdir() 创建目录</h4><p>使用os模块的mkdir()方法在当前目录下创建新的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line"># 创建目录test</span><br><span class="line">os.mkdir(&quot;test&quot;)</span><br></pre></td></tr></table></figure><h4 id="chdir-切换目录"><a href="#chdir-切换目录" class="headerlink" title="chdir() 切换目录"></a>chdir() 切换目录</h4><p>用chdir()方法来改变当前的目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line"># getcwd() 获取当前目录</span><br><span class="line">print os.getcwd()</span><br><span class="line"></span><br><span class="line"># 将当前目录改为&quot;/home/newdir&quot;</span><br><span class="line">os.chdir(&quot;/home/newdir&quot;)</span><br></pre></td></tr></table></figure><h4 id="rmdir-删除目录"><a href="#rmdir-删除目录" class="headerlink" title="rmdir() 删除目录"></a>rmdir() 删除目录</h4><p>rmdir()方法删除目录，目录名称以参数传递。</p><p>在删除这个目录之前，它的所有内容应该先被清除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"> </span><br><span class="line"># 删除”/tmp/test”目录</span><br><span class="line">os.rmdir( &quot;/tmp/test&quot;  )</span><br></pre></td></tr></table></figure><h2 id="Python-类属性与方法"><a href="#Python-类属性与方法" class="headerlink" title="Python 类属性与方法"></a>Python 类属性与方法</h2><h3 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h3><p><strong>private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.</strong>private_attrs。</p><h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><p>在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数</p><h3 id="类的私有方法"><a href="#类的私有方法" class="headerlink" title="类的私有方法"></a>类的私有方法</h3><p><strong>private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.</strong>private_methods</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line">class JustCounter:</span><br><span class="line">    __secretCount = 0  # 私有变量</span><br><span class="line">    publicCount = 0    # 公开变量</span><br><span class="line"> </span><br><span class="line">    def count(self):</span><br><span class="line">        self.__secretCount += 1</span><br><span class="line">        self.publicCount += 1</span><br><span class="line">        print self.__secretCount</span><br><span class="line"> </span><br><span class="line">counter = JustCounter()</span><br><span class="line">counter.count()</span><br><span class="line">counter.count()</span><br><span class="line">print counter.publicCount</span><br><span class="line">print counter.__secretCount  # 报错，实例不能访问私有变量</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 17, in &lt;module&gt;</span><br><span class="line">    print counter.__secretCount  # 报错，实例不能访问私有变量</span><br><span class="line">AttributeError: JustCounter instance has no attribute &apos;__secretCount&apos;</span><br></pre></td></tr></table></figure><h3 id="访问私有属性"><a href="#访问私有属性" class="headerlink" title="访问私有属性"></a>访问私有属性</h3><p>Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName（ 对象名._类名__私有属性名 ）访问属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">class private_var:</span><br><span class="line">    __site = &quot;访问私有属性成功&quot;</span><br><span class="line"></span><br><span class="line">my_var = private_var()</span><br><span class="line">print my_var._private_var__site</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">访问私有属性成功</span><br></pre></td></tr></table></figure><h2 id="单下划线、双下划线、头尾双下划线区别"><a href="#单下划线、双下划线、头尾双下划线区别" class="headerlink" title="单下划线、双下划线、头尾双下划线区别"></a>单下划线、双下划线、头尾双下划线区别</h2><ul><li><p>__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。</p></li><li><p>_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *</p></li><li><p>__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;datetime模块&quot;&gt;&lt;a href=&quot;#datetime模块&quot; class=&quot;headerlink&quot; title=&quot;datetime模块&quot;&gt;&lt;/a&gt;datetime模块&lt;/h2&gt;&lt;p&gt;其实就是date和time 模块的结合， 常见的属性方法都比较常用&lt;br&gt;比
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记03</title>
    <link href="http://www.duanmuxu.top/20190801/python-study-notes-03.html"/>
    <id>http://www.duanmuxu.top/20190801/python-study-notes-03.html</id>
    <published>2019-08-01T14:37:52.877Z</published>
    <updated>2019-08-01T14:43:09.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断python字典中key是否存在的两种方法"><a href="#判断python字典中key是否存在的两种方法" class="headerlink" title="判断python字典中key是否存在的两种方法"></a>判断python字典中key是否存在的两种方法</h2><h4 id="使用自带函数实现"><a href="#使用自带函数实现" class="headerlink" title="使用自带函数实现"></a>使用自带函数实现</h4><p>python的字典的属性方法里面有一个has_key()方法，可以直接判断字典中是否有某个key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&quot;name&quot;:&quot;duanmuxu&quot;, &quot;sex&quot;:&quot;male&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; dic.has_key(&quot;name&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; dic.has_key(&quot;address&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><h4 id="in方法做判断"><a href="#in方法做判断" class="headerlink" title="in方法做判断"></a>in方法做判断</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&quot;name&quot;:&quot;duanmuxu&quot;, &quot;sex&quot;:&quot;male&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; &quot;name&quot; in dic.keys()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;address&quot; in dic.keys()</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>同理，not in 方法也可做判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dic = &#123;&quot;name&quot;:&quot;duanmuxu&quot;, &quot;sex&quot;:&quot;male&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; &quot;name&quot; not in dic.keys()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &quot;address&quot; not in dic.keys()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h2 id="input-和raw-input-的区别"><a href="#input-和raw-input-的区别" class="headerlink" title="input()和raw_input()的区别"></a>input()和raw_input()的区别</h2><h4 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h4><ul><li>Python2.X 中input()和raw_input()都可使用</li><li>Python3.X 中只能使用input(),raw_input()已经与input()结合了</li></ul><h4 id="输入格式差异"><a href="#输入格式差异" class="headerlink" title="输入格式差异"></a>输入格式差异</h4><blockquote><p>以下代码使用Python2.X版本实现</p></blockquote><h5 id="raw-input"><a href="#raw-input" class="headerlink" title="raw_input()"></a>raw_input()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name= raw_input(&apos;输入姓名：&apos;)</span><br><span class="line">输入姓名：duanmuxu</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&apos;duanmuxu&apos;</span><br><span class="line">&gt;&gt;&gt; type(name)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; age= raw_input(&apos;输入年龄：&apos;)</span><br><span class="line">输入年龄：21</span><br><span class="line">&gt;&gt;&gt; age</span><br><span class="line">&apos;21&apos;</span><br><span class="line">&gt;&gt;&gt; type(age)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><p>对于任何类型的数据都是直接输入，返回一个字符串类型的变量</p><h5 id="input"><a href="#input" class="headerlink" title="input()"></a>input()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name= input(&apos;输入姓名：&apos;)</span><br><span class="line">输入姓名：duanmuxu</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">NameError: name &apos;duanmuxu&apos; is not defined</span><br><span class="line">&gt;&gt;&gt; name= input(&apos;输入姓名：&apos;)</span><br><span class="line">输入姓名：&apos;duanmuxu&apos;</span><br><span class="line">&gt;&gt;&gt; name</span><br><span class="line">&apos;duanmuxu&apos;</span><br><span class="line">&gt;&gt;&gt; type(name)</span><br><span class="line">&lt;type &apos;str&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; age= input(&apos;输入年龄：&apos;)</span><br><span class="line">输入年龄：21</span><br><span class="line">&gt;&gt;&gt; age</span><br><span class="line">21</span><br><span class="line">&gt;&gt;&gt; type(age)</span><br><span class="line">&lt;type &apos;int&apos;&gt;</span><br></pre></td></tr></table></figure><p>需要根据输入数据的类型进行输入，字符串型数据输入时加上 ‘ ‘，数字就是数字</p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li><p>输入的类型为字符的时候可以用raw_input()，当然不怕麻烦也可以用input()手动加引号</p></li><li><p>int类型的时候最好用input()</p></li></ul><h2 id="Python-随机数函数"><a href="#Python-随机数函数" class="headerlink" title="Python 随机数函数"></a>Python 随机数函数</h2><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。</p><h3 id="choice-函数"><a href="#choice-函数" class="headerlink" title="choice() 函数"></a>choice() 函数</h3><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>choice() 方法返回一个<strong>列表，元组或字符串</strong>的随机项。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.choice(seq)</span><br><span class="line"></span><br><span class="line"># seq -- 可以是一个列表，元组或字符串。</span><br></pre></td></tr></table></figure><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">print &quot;choice([1, 2, &apos;a&apos;, &apos;b&apos;]) : &quot;, random.choice([1, 2, &apos;a&apos;, &apos;b&apos;])</span><br><span class="line">print &quot;choice(&apos;String&apos;) : &quot;, random.choice(&apos;String&apos;)</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">choice([1, 2, &apos;a&apos;, &apos;b&apos;]) :  a</span><br><span class="line">choice(&apos;String&apos;) :  S</span><br></pre></td></tr></table></figure><h3 id="randrange-函数"><a href="#randrange-函数" class="headerlink" title="randrange() 函数"></a>randrange() 函数</h3><h5 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h5><p>randrange() 方法返回指定<strong>递增基数集合</strong>中的一个随机数，基数缺省值为1。</p><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.randrange ([start,] stop [,step])</span><br></pre></td></tr></table></figure><ul><li>start – 指定范围内的开始值，包含在范围内。</li><li>stop – 指定范围内的结束值，不包含在范围内。</li><li>step – 指定递增基数。</li></ul><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line"># 输出 100 &lt;= number &lt; 1000 间的偶数</span><br><span class="line">print &quot;randrange(100, 1000, 2) : &quot;, random.randrange(100, 1000, 2)</span><br><span class="line"></span><br><span class="line"># 输出 100 &lt;= number &lt; 1000 间的其他数</span><br><span class="line">print &quot;randrange(100, 1000, 3) : &quot;, random.randrange(100, 1000, 3)</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">randrange(100, 1000, 2) :  762</span><br><span class="line">randrange(100, 1000, 3) :  532</span><br></pre></td></tr></table></figure><h3 id="random-函数"><a href="#random-函数" class="headerlink" title="random() 函数"></a>random() 函数</h3><h5 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h5><p>random() 方法返回随机生成的一个实数，它在<strong>[0,1)</strong>范围内。</p><h5 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.random()</span><br></pre></td></tr></table></figure><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">for i in range(0, 3):</span><br><span class="line">    print &quot;第%s个随机数:&quot; %(i+1) , random.random()</span><br><span class="line">    </span><br><span class="line"># 输出：</span><br><span class="line">第1个随机数: 0.683753845699</span><br><span class="line">第2个随机数: 0.146315223384</span><br><span class="line">第3个随机数: 0.328288508196</span><br></pre></td></tr></table></figure><h3 id="seed-函数"><a href="#seed-函数" class="headerlink" title="seed() 函数"></a>seed() 函数</h3><h5 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h5><p>seed() 方法改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数。</p><p>Random初始化的时候，可以以一个INT32作为参数，称为seed，MSDN上的解释是：“伪随机数是以相同的概率从一组有限的数字中选取的……随机数的生成是从种子值开始……”</p><p>也就是说，<strong>当seed的值设为一样时，所产生的随机数也是相同的</strong>。</p><h5 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.seed ( [x] )</span><br></pre></td></tr></table></figure><p>x – 改变随机数生成器的种子seed。</p><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">for i in range(0, 3):</span><br><span class="line">    random.seed(5)</span><br><span class="line">    print &quot;第%s个随机数:&quot; %(i+1) , random.random()</span><br><span class="line">    </span><br><span class="line"># 输出：</span><br><span class="line">第1个随机数: 0.62290169489</span><br><span class="line">第2个随机数: 0.62290169489</span><br><span class="line">第3个随机数: 0.62290169489</span><br></pre></td></tr></table></figure><h3 id="shuffle-函数"><a href="#shuffle-函数" class="headerlink" title="shuffle() 函数"></a>shuffle() 函数</h3><h5 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h5><p>shuffle() 方法将序列的所有元素随机排序。</p><h5 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.shuffle (lst )</span><br></pre></td></tr></table></figure><p>lst – 可以是一个列表。</p><h5 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">li = [1, 2, 3, 4, 5]</span><br><span class="line">for i in range(1, 4):</span><br><span class="line">    random.shuffle(li)</span><br><span class="line">    print &quot;第%s次随机排序列表，结果是：&quot; %i , li</span><br><span class="line">    </span><br><span class="line"># 输出：</span><br><span class="line">第1次随机排序列表，结果是： [4, 1, 2, 3, 5]</span><br><span class="line">第2次随机排序列表，结果是： [4, 3, 2, 5, 1]</span><br><span class="line">第3次随机排序列表，结果是： [1, 3, 4, 5, 2]</span><br></pre></td></tr></table></figure><h3 id="uniform-函数"><a href="#uniform-函数" class="headerlink" title="uniform() 函数"></a>uniform() 函数</h3><h5 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h5><p>uniform() 方法将随机生成下一个实数，它在 [x, y] 范围内。</p><h5 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">random.uniform(x, y)</span><br></pre></td></tr></table></figure><ul><li>x – 随机数的最小值，包含该值。</li><li>y – 随机数的最大值，不包含该值。</li><li>返回一个浮点数 N，取值范围为如果 x&lt;y 则 x &lt;= N &lt; y，如果 y&lt;x 则y &lt;= N &lt; x。</li></ul><h5 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#-*- coding:utf-8 -*-</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">print &quot;uniform(3, 6)生成的随机数为：&quot;,random.uniform(3, 6)</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">uniform(3, 6)生成的随机数为： 3.71157971278</span><br></pre></td></tr></table></figure><h2 id="r-R-打印原始字符串"><a href="#r-R-打印原始字符串" class="headerlink" title="r/R 打印原始字符串"></a>r/R 打印原始字符串</h2><p>有时候字符串中带有 \n 、 \t 等特殊字符，会被识别成特殊操作而不被输出。此时在字符串前加上 r/R 即可打印原始字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print &quot;原始字符串\n&quot;</span><br><span class="line">原始字符串</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print r&quot;原始字符串\n&quot;</span><br><span class="line">原始字符串\n</span><br><span class="line">&gt;&gt;&gt; print R&quot;原始字符串\n&quot;</span><br><span class="line">原始字符串\n</span><br></pre></td></tr></table></figure><h2 id="三引号（triple-quotes）"><a href="#三引号（triple-quotes）" class="headerlink" title="三引号（triple quotes）"></a>三引号（triple quotes）</h2><p>python三引号允许一个字符串跨多行，<strong>字符串中可以包含换行符、制表符以及其他特殊字符。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTML_wd = &apos;&apos;&apos;</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span><br><span class="line">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span><br><span class="line">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span><br><span class="line">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span><br><span class="line">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">print HTML_wd</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span><br><span class="line">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</span><br><span class="line">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</span><br><span class="line">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</span><br><span class="line">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</span><br><span class="line">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</span><br><span class="line">&lt;/BODY&gt;&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><p><strong>所见即所得</strong></p><h2 id="直接赋值-、浅拷贝-copy-和深度拷贝-deepcopy"><a href="#直接赋值-、浅拷贝-copy-和深度拷贝-deepcopy" class="headerlink" title="直接赋值(=)、浅拷贝(copy)和深度拷贝(deepcopy)"></a>直接赋值(=)、浅拷贝(copy)和深度拷贝(deepcopy)</h2><ul><li>直接赋值：其实就是对象的引用（别名）。</li><li>浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。</li><li>深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li></ul><p>直接上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*-coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import copy</span><br><span class="line">a = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]] #原始对象</span><br><span class="line"> </span><br><span class="line">b = a                       #赋值，传对象的引用</span><br><span class="line">c = copy.copy(a)            #对象拷贝，浅拷贝</span><br><span class="line">d = copy.deepcopy(a)        #对象拷贝，深拷贝</span><br><span class="line"> </span><br><span class="line">a.append(5)                 #修改对象a</span><br><span class="line">a[4].append(&apos;c&apos;)            #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象</span><br><span class="line"> </span><br><span class="line">print( &apos;a = &apos;, a )</span><br><span class="line">print( &apos;b = &apos;, b )</span><br><span class="line">print( &apos;c = &apos;, c )</span><br><span class="line">print( &apos;d = &apos;, d )</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">(&apos;a = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5])</span><br><span class="line">(&apos;b = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5])</span><br><span class="line">(&apos;c = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]])</span><br><span class="line">(&apos;d = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]])</span><br></pre></td></tr></table></figure><ul><li>b = a: 赋值引用，a 和 b 都指向同一个对象。</li><li>b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。</li><li>b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;判断python字典中key是否存在的两种方法&quot;&gt;&lt;a href=&quot;#判断python字典中key是否存在的两种方法&quot; class=&quot;headerlink&quot; title=&quot;判断python字典中key是否存在的两种方法&quot;&gt;&lt;/a&gt;判断python字典中key是否存
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记02</title>
    <link href="http://www.duanmuxu.top/20190731/python-study-notes-02.html"/>
    <id>http://www.duanmuxu.top/20190731/python-study-notes-02.html</id>
    <published>2019-07-31T15:29:56.330Z</published>
    <updated>2019-07-31T15:31:40.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip()方法"></a>strip()方法</h2><p>strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。<br><strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=&quot;01013434343430101010&quot;</span><br><span class="line">&gt;&gt;&gt; x.strip(&apos;01&apos;)</span><br><span class="line">&apos;343434343&apos;</span><br><span class="line">&gt;&gt;&gt; x.strip(&apos;014&apos;)</span><br><span class="line">&apos;343434343&apos;</span><br><span class="line">&gt;&gt;&gt; x.strip(&apos;013&apos;)</span><br><span class="line">&apos;4343434&apos;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="// 运算符"></a>// 运算符</h2><p>取整除 —— 返回商的整数部分（向下取整）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=13</span><br><span class="line">&gt;&gt;&gt; a/2</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; a//2</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; b=13.5</span><br><span class="line">&gt;&gt;&gt; b/2</span><br><span class="line">6.75</span><br><span class="line">&gt;&gt;&gt; b//2</span><br><span class="line">6.0</span><br><span class="line">&gt;&gt;&gt; c=-9.5</span><br><span class="line">&gt;&gt;&gt; c/2</span><br><span class="line">-4.75</span><br><span class="line">&gt;&gt;&gt; c//2</span><br><span class="line">-5.0</span><br></pre></td></tr></table></figure><h2 id="pow-函数"><a href="#pow-函数" class="headerlink" title="pow() 函数"></a>pow() 函数</h2><p>pow() 方法返回 xy（x的y次方） 的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 3</span><br><span class="line">&gt;&gt;&gt; y = 5</span><br><span class="line">&gt;&gt;&gt; pow(x, y)</span><br><span class="line">243</span><br><span class="line">&gt;&gt;&gt; pow(y, x)</span><br><span class="line">125</span><br></pre></td></tr></table></figure><h2 id="for循环通过序列索引迭代遍历"><a href="#for循环通过序列索引迭代遍历" class="headerlink" title="for循环通过序列索引迭代遍历"></a>for循环通过序列索引迭代遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"></span><br><span class="line">food = [&quot;rise&quot;, &quot;noodle&quot;, &quot;Hamburg&quot;]</span><br><span class="line">for i in range(len(food)):</span><br><span class="line">print &quot;晚饭是：&quot; + food[i]</span><br><span class="line"></span><br><span class="line"># 输出：</span><br><span class="line">晚饭是：rise</span><br><span class="line">晚饭是：noodle</span><br><span class="line">晚饭是：Hamburg</span><br></pre></td></tr></table></figure><h2 id="循环使用-else-语句"><a href="#循环使用-else-语句" class="headerlink" title="循环使用 else 语句"></a>循环使用 else 语句</h2><p>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line">for num in range(10,20):  # 迭代 10 到 20 之间的数字</span><br><span class="line">   for i in range(2,num): # 根据因子迭代</span><br><span class="line">      if num%i == 0:      # 确定第一个因子</span><br><span class="line">         j=num/i          # 计算第二个因子</span><br><span class="line">         print &apos;%d 等于 %d * %d&apos; % (num,i,j)</span><br><span class="line">         break            # 跳出当前循环</span><br><span class="line">   else:                  # 循环的 else 部分</span><br><span class="line">      print num, &apos;是一个质数&apos;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"># 结果：</span><br><span class="line">10 等于 2 * 5</span><br><span class="line">11 是一个质数</span><br><span class="line">12 等于 2 * 6</span><br><span class="line">13 是一个质数</span><br><span class="line">14 等于 2 * 7</span><br><span class="line">15 等于 3 * 5</span><br><span class="line">16 等于 2 * 8</span><br><span class="line">17 是一个质数</span><br><span class="line">18 等于 2 * 9</span><br><span class="line">19 是一个质数</span><br></pre></td></tr></table></figure><h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><p>pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</p><h4 id="运用一"><a href="#运用一" class="headerlink" title="运用一"></a>运用一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: UTF-8 -*- </span><br><span class="line"> </span><br><span class="line"># 输出 Python 的每个字母</span><br><span class="line">for letter in &apos;Python&apos;:</span><br><span class="line">   if letter == &apos;h&apos;:</span><br><span class="line">      pass</span><br><span class="line">      print &apos;这是 pass 块&apos;</span><br><span class="line">   print &apos;当前字母 :&apos;, letter</span><br><span class="line"> </span><br><span class="line"># 输出：</span><br><span class="line">当前字母 : P</span><br><span class="line">当前字母 : y</span><br><span class="line">当前字母 : t</span><br><span class="line">这是 pass 块</span><br><span class="line">当前字母 : h</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : n</span><br></pre></td></tr></table></figure><h3 id="运用二"><a href="#运用二" class="headerlink" title="运用二"></a>运用二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sample(n_samples):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>在 Python 中有时候会看到一个 def 函数，该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;strip-方法&quot;&gt;&lt;a href=&quot;#strip-方法&quot; class=&quot;headerlink&quot; title=&quot;strip()方法&quot;&gt;&lt;/a&gt;strip()方法&lt;/h2&gt;&lt;p&gt;strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。&lt;br
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记01</title>
    <link href="http://www.duanmuxu.top/20190730/python-study-notes-01.html"/>
    <id>http://www.duanmuxu.top/20190730/python-study-notes-01.html</id>
    <published>2019-07-30T15:57:09.952Z</published>
    <updated>2019-07-30T16:01:46.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python头部-usr-bin-python和-usr-bin-env-python-的区别"><a href="#Python头部-usr-bin-python和-usr-bin-env-python-的区别" class="headerlink" title="Python头部 #!/usr/bin/python和 #!/usr/bin/env python 的区别"></a>Python头部 #!/usr/bin/python和 #!/usr/bin/env python 的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br></pre></td></tr></table></figure><p>这样声明的时候，会去取你机器的 PATH 中指定的第一个 python 来执行你的脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br></pre></td></tr></table></figure><p>表示写死了就是要 /usr/bin/python 这个目录下 python 来执行你的脚本。这样写程序的可移植性就差了，如果此路径下python命令不存在就会报错。</p><p>所以一般情况还是用第一种写法。</p><h2 id="Python中文编码"><a href="#Python中文编码" class="headerlink" title="Python中文编码"></a>Python中文编码</h2><p>Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。</p><p>解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 # coding=utf-8 就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line">print &quot;Hello，world&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。</p></blockquote><h2 id="Python-标识符"><a href="#Python-标识符" class="headerlink" title="Python 标识符"></a>Python 标识符</h2><ul><li>在 Python 里，标识符由字母、数字、下划线组成。</li><li>在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</li><li>Python 中的标识符是区分大小写的。</li><li>以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。</li><li>以双下划线开头的 <strong>foo 代表类的私有成员，以双下划线开头和结尾的 __foo</strong> 代表 Python 里特殊方法专用的标识，如 <strong>init</strong>() 代表类的构造函数。</li><li>Python 可以同一行显示多条语句，方法是用分号 ; 分开。</li></ul><h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python语句中一般以新行作为语句的结束符。</p><p>但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/evn python</span><br><span class="line"></span><br><span class="line">my_name = &quot;duan&quot; + \</span><br><span class="line">        &quot;mu&quot; + \</span><br><span class="line">        &quot;xu&quot;</span><br><span class="line">        </span><br><span class="line">print my_name</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">duanmuxu</span><br></pre></td></tr></table></figure><h2 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h2><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h2 id="四种数字类型"><a href="#四种数字类型" class="headerlink" title="四种数字类型"></a>四种数字类型</h2><ul><li>int（有符号整型）</li><li>long（长整型[也可以代表八进制和十六进制]）</li><li>float（浮点型）</li><li>complex（复数）</li></ul><h2 id="字符串（string）截取"><a href="#字符串（string）截取" class="headerlink" title="字符串（string）截取"></a>字符串（string）截取</h2><p>使用 <strong>[头下标:尾下标]</strong> 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。</p><p>[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/evn python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"> </span><br><span class="line">str = &apos;abcdefghijklmn&apos;</span><br><span class="line"> </span><br><span class="line">print str           # 输出完整字符串</span><br><span class="line">print str[0]        # 输出字符串中的第一个字符</span><br><span class="line">print str[2:5]      # 输出字符串中第三个至第六个之间的字符串</span><br><span class="line">print str[2:-2]     # 输出字符串中第三个至倒数第三个的字符串</span><br><span class="line">print str[2:]       # 输出从第三个字符开始的字符串</span><br><span class="line">print str * 2       # 输出字符串两次</span><br><span class="line">print str + &quot;TEST&quot;  # 输出连接的字符串</span><br><span class="line">print str[2::3]     # 输出从第三个字符开始，以3为截取步长的字符串</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 执行结果</span><br><span class="line">abcdefghijklmn</span><br><span class="line">a</span><br><span class="line">cde</span><br><span class="line">cdefghijkl</span><br><span class="line">cdefghijklmn</span><br><span class="line">abcdefghijklmnabcdefghijklmn</span><br><span class="line">abcdefghijklmnTEST</span><br><span class="line">cfil</span><br></pre></td></tr></table></figure><h2 id="Python列表"><a href="#Python列表" class="headerlink" title="Python列表"></a>Python列表</h2><ul><li>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。</li><li>列表用 [ ] 标识，是 python 最通用的复合数据类型。</li><li>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。</li></ul><h2 id="Python-元组"><a href="#Python-元组" class="headerlink" title="Python 元组"></a>Python 元组</h2><p>元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于<strong>只读列表</strong>。</p><h2 id="Python-字典"><a href="#Python-字典" class="headerlink" title="Python 字典"></a>Python 字典</h2><ul><li><p>列表是有序的对象集合，字典是无序的对象集合。</p></li><li><p>两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p></li><li><p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。</p></li></ul><h2 id="int-函数"><a href="#int-函数" class="headerlink" title="int() 函数"></a>int() 函数</h2><p>int() 函数用于将一个字符串或数字转换为整型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class int(x, base=10)</span><br></pre></td></tr></table></figure><ul><li>x – 字符串或数字。</li><li>base – 进制数，默认十进制。</li><li>返回整型数据。</li></ul><p>long(x, base)函数也一样</p><h2 id="tuple-函数"><a href="#tuple-函数" class="headerlink" title="tuple() 函数"></a>tuple() 函数</h2><p>将列表转换为元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;tuple([1,2,3,4])</span><br><span class="line"> </span><br><span class="line">(1, 2, 3, 4)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; tuple(&#123;1:2,3:4&#125;)    #针对字典 会返回字典的key组成的tuple</span><br><span class="line"> </span><br><span class="line">(1, 3)</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; tuple((1,2,3,4))    #元组会返回元组自身</span><br><span class="line"> </span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure><h2 id="set-函数"><a href="#set-函数" class="headerlink" title="set() 函数"></a>set() 函数</h2><ul><li>set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等</li><li>返回新的集合对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x=set(&apos;1234312&apos;)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&#123;&apos;1&apos;, &apos;3&apos;, &apos;2&apos;, &apos;4&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; y=set(&apos;4567657&apos;)</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">&#123;&apos;4&apos;, &apos;5&apos;, &apos;7&apos;, &apos;6&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; x &amp; y  # 交集</span><br><span class="line">&#123;&apos;4&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; x | y  # 并集</span><br><span class="line">&#123;&apos;4&apos;, &apos;7&apos;, &apos;6&apos;, &apos;2&apos;, &apos;1&apos;, &apos;3&apos;, &apos;5&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; x - y  # 差集</span><br><span class="line">&#123;&apos;1&apos;, &apos;3&apos;, &apos;2&apos;&#125;</span><br></pre></td></tr></table></figure><h2 id="chr-函数、ord-函数"><a href="#chr-函数、ord-函数" class="headerlink" title="chr() 函数、ord() 函数"></a>chr() 函数、ord() 函数</h2><ul><li>chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。</li><li>ord() 函数以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chr(48)</span><br><span class="line">&apos;0&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ord(&apos;c&apos;)</span><br><span class="line">99</span><br></pre></td></tr></table></figure><h2 id="hex-函数"><a href="#hex-函数" class="headerlink" title="hex() 函数"></a>hex() 函数</h2><p>hex() 函数用于将10进制整数转换成16进制，以字符串形式表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hex(12)</span><br><span class="line">&apos;0xc&apos;</span><br><span class="line">&gt;&gt;&gt; type(hex(12))</span><br><span class="line">&lt;class &apos;str&apos;&gt;</span><br></pre></td></tr></table></figure><h2 id="oct-函数"><a href="#oct-函数" class="headerlink" title="oct() 函数"></a>oct() 函数</h2><p>oct() 函数将一个整数转换成8进制字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; oct(15)</span><br><span class="line">&apos;017&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Python头部-usr-bin-python和-usr-bin-env-python-的区别&quot;&gt;&lt;a href=&quot;#Python头部-usr-bin-python和-usr-bin-env-python-的区别&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Python" scheme="http://www.duanmuxu.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://www.duanmuxu.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习11：Shell小记</title>
    <link href="http://www.duanmuxu.top/20190630/shell-learning-11-notes.html"/>
    <id>http://www.duanmuxu.top/20190630/shell-learning-11-notes.html</id>
    <published>2019-06-30T09:10:27.777Z</published>
    <updated>2019-06-30T09:11:42.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="echo-e-参数"><a href="#echo-e-参数" class="headerlink" title="echo -e 参数"></a>echo -e 参数</h2><p>若echo的字符串参数中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a 发出警告声； </span><br><span class="line">\b 删除前一个字符； </span><br><span class="line">\c 最后不加上换行符号； </span><br><span class="line">\f 换行但光标仍旧停留在原来的位置； </span><br><span class="line">\n 换行且光标移至行首； </span><br><span class="line">\r 光标移至行首，但不换行； </span><br><span class="line">\t 插入tab； </span><br><span class="line">\v 与\f相同； </span><br><span class="line">\ 插入\字符； </span><br><span class="line">\nnn 插入nnn（八进制）所代表的ASCII字符；</span><br></pre></td></tr></table></figure><h4 id="echo-e实例"><a href="#echo-e实例" class="headerlink" title="echo -e实例"></a>echo -e实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=&quot;test1\n&quot;</span><br><span class="line">str2=&quot;test2&quot;</span><br><span class="line">echo $str1$str2</span><br></pre></td></tr></table></figure><p>没有 -e 输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test1\ntest2</span><br></pre></td></tr></table></figure><p>带 -e 输出为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br><span class="line">test2</span><br></pre></td></tr></table></figure><h2 id="关于-r与-n-以及-r-n-的区别"><a href="#关于-r与-n-以及-r-n-的区别" class="headerlink" title="关于/r与/n 以及 /r/n 的区别"></a>关于/r与/n 以及 /r/n 的区别</h2><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p><p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>\r就是回到行首，\n就是到下一行的，但是一般我们输出程序时，看不到明显的差别的</p><p>‘\r’是回车，’\n’是换行，前者使光标到行首，后者使光标下移一格。通常用的Enter是两个加起来。</p><p>对于cprintf和sprintf来说，你如果要换行的话，你要输入”\r\n”<br>而对于printf不说，换行只要”\r”就可以了。<br>一个是回车，一个是换行<br>ASCII码一个是10一个是13。</p><p>\r\n与\n是有区别的。<br>如果要通用的则是\r\n，因为有些编辑器它不认\n</p><h2 id="echo-中-c-命令"><a href="#echo-中-c-命令" class="headerlink" title="echo 中 -c 命令"></a>echo 中 -c 命令</h2><p>表示不换行，搭配 -e 使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 脚本内容</span><br><span class="line">#!/bin/sh</span><br><span class="line">echo -e &quot;first line！ \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;second line！&quot;</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">first line！second line！</span><br><span class="line"></span><br><span class="line"># 若没有 -c ,则输出结果为</span><br><span class="line">first line！</span><br><span class="line">second line！</span><br></pre></td></tr></table></figure><h2 id="文件检测命令"><a href="#文件检测命令" class="headerlink" title="文件检测命令"></a>文件检测命令</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true</td></tr><tr><td>-S</td><td>判断某文件是否 socket。</td></tr><tr><td>-L</td><td>检测文件是否存在并且是一个符号链接。</td></tr><tr><td>## test 命令</td><td></td></tr><tr><td>test命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试</td><td></td></tr><tr><td>#### 数值与字符检测</td><td></td></tr><tr><td>参数与前面讲的运算符中关系运算符和字符串运算符一样，只是将表达式中外部的[] 换成了 test而已，如以下例子：</td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#！ /bin/bash</span><br><span class="line"></span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &apos;两个数相等！&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个数不相等！&apos;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 输出结果为</span><br><span class="line">两个数相等！</span><br><span class="line"></span><br><span class="line"># 执行结果与将 test 换成 [ ] 后一样</span><br><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if [ $[num1] -eq $[num2] ]</span><br><span class="line">then</span><br><span class="line">    echo &apos;两个数相等！&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个数不相等！&apos;</span><br><span class="line">fi</span><br><span class="line"># 输出结果为</span><br><span class="line">两个数相等！</span><br></pre></td></tr></table></figure><h4 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h4><p>参数为上一条文件检测命令的参数，直接上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#！/bin/bash</span><br><span class="line"></span><br><span class="line">if test -e ./notFile -o -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &apos;至少有一个文件存在!&apos;</span><br><span class="line">else</span><br><span class="line">    echo &apos;两个文件都不存在&apos;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>文件测试中还支持 -o 与 -a 来连接多个表达式。优先级为：！&gt; -a &gt; -o</p><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=5</span><br><span class="line">let &quot;a++&quot; # 这里的变量a加不加双引号都可以</span><br><span class="line">echo $a</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>简单说就是一个脚本中调用其他脚本，直接上例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 脚本one.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">one=&quot;the is one in file one.sh&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 脚本two.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">one=&quot;the is two in file two.sh&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 脚本three.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">#以下包含文件的两种方法等效，推荐使用source关键字</span><br><span class="line">. one.sh # 文件路径</span><br><span class="line">source two.sh</span><br><span class="line"> </span><br><span class="line">echo $one</span><br><span class="line">echo $two</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 执行脚本 three.sh，输出为</span><br><span class="line">the is one in file one.sh</span><br><span class="line">this is two in file two.sh</span><br></pre></td></tr></table></figure><h2 id="连接FTP"><a href="#连接FTP" class="headerlink" title="连接FTP"></a>连接FTP</h2><p>直接上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ftp -i -n $&#123;HOST&#125; &lt;&lt;!</span><br><span class="line">user $&#123;user&#125; $&#123;passwd&#125;</span><br><span class="line">lcd $&#123;local_file&#125;</span><br><span class="line">cd $&#123;tar_file&#125;</span><br><span class="line">mput *</span><br><span class="line">quit</span><br><span class="line">!</span><br></pre></td></tr></table></figure><ul><li>-i 在多个文件传输期间关闭交互提示</li><li>使用 -n 选项连接ftp客户端以阻止ftp客户端立即登录.这样,ftp客户端就不要你输入一个用户名和密码了</li><li>HOST 是要连接的主机号</li><li>user user passwd 输入连接的主机用户名和相应密码</li><li>lcd 表示本地需要传输的文件路径</li><li>cd 表示目标主机需要接收文件的路径</li><li>mput 表示将本地文件路径下的所有文件都传输过去，如果只需要传输一个文件，则使用put命令</li><li>quit 退出本次连接</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;echo-e-参数&quot;&gt;&lt;a href=&quot;#echo-e-参数&quot; class=&quot;headerlink&quot; title=&quot;echo -e 参数&quot;&gt;&lt;/a&gt;echo -e 参数&lt;/h2&gt;&lt;p&gt;若echo的字符串参数中出现以下字符，则特别加以处理，而不会将它当成一般文字输出
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习10：输入、输出重定向</title>
    <link href="http://www.duanmuxu.top/20190630/shell-learning-10-input-and-output-redirection.html"/>
    <id>http://www.duanmuxu.top/20190630/shell-learning-10-input-and-output-redirection.html</id>
    <published>2019-06-30T08:26:34.401Z</published>
    <updated>2020-02-18T17:31:14.498Z</updated>
    
    <content type="html"><![CDATA[<p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到你的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><h2 id="重定向命令列表"><a href="#重定向命令列表" class="headerlink" title="重定向命令列表"></a>重定向命令列表</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件 m 和 n 合并</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td></tr><tr><td><strong>文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</strong></td><td></td></tr><tr><td>## 输出重定向</td><td></td></tr><tr><td>前面讲echo命令的时候有提到过 &gt; 与 &gt;&gt; 的区别。现在清楚了，这就是输出重定向的命令。 &gt; 表示将 conmand 的执行结果存入file中，文件覆盖，&gt;&gt; 表示文件内容追加，不覆盖。</td><td></td></tr><tr><td>## 输入重定向</td><td></td></tr><tr><td>与输出重定向相反，输入重定向就是从文件获取输入</td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &lt; file</span><br></pre></td></tr></table></figure><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 统计文件行数</span><br><span class="line">wc -l users</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">2 users</span><br><span class="line"></span><br><span class="line"># 统计文件行数</span><br><span class="line">wc -l &lt; users</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>以上两个例子都是为了统计users 文件中的行数，区别在于加了 &lt; 符号的例子仅仅从标准输入读取内容，不读取文件名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure><p>以上命令可以同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p><h2 id="标准文件重定向"><a href="#标准文件重定向" class="headerlink" title="标准文件重定向"></a>标准文件重定向</h2><p>上面刚讲过，一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0</li><li>标准输出文件(stdout)：stdout 的文件描述符为1</li><li>标准错误文件(stderr)：stderr的文件描述符为2<br>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file，这两个也是常用的，那么如果想把标准错误文件重定向该怎么办呢？</li></ul><p>可以通过以下命令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># stderr 重定向到 file</span><br><span class="line">command 2 &gt; file</span><br><span class="line"></span><br><span class="line">#  stderr 追加到 file 文件末尾</span><br><span class="line">command 2 &gt;&gt; file</span><br><span class="line"></span><br><span class="line"># stdout 和 stderr 合并后重定向到 file</span><br><span class="line">command &gt; file 2&gt;&amp;1</span><br><span class="line">command &gt;&gt; file 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"># 对 stdin 和 stdout 都重定向</span><br><span class="line">command &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure><h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。基本形式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command</p><p>直接上例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 通过 wc -l 计算文件行数</span><br><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">wc -l &lt;&lt; EOF</span><br><span class="line">    一别都门三改火，天涯踏尽红尘。</span><br><span class="line">    依然一笑作春温。</span><br><span class="line">    无波真古井，有节是秋筠。</span><br><span class="line">    惆怅孤帆连夜发，送行淡月微云。</span><br><span class="line">    尊前不用翠眉颦。</span><br><span class="line">    人生如逆旅，我亦是行人。</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; /dev/null</span><br></pre></td></tr></table></figure><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 屏蔽 stdout 和 stderr</span><br><span class="line"></span><br><span class="line">command &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>最重要的就是要记住<strong>文件描述符 0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到你的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。&lt;/p&gt;
&lt;h2 id=&quot;重定向命令列表&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习09：函数</title>
    <link href="http://www.duanmuxu.top/20190630/shell-learning-09-functions.html"/>
    <id>http://www.duanmuxu.top/20190630/shell-learning-09-functions.html</id>
    <published>2019-06-30T03:58:08.965Z</published>
    <updated>2020-02-18T17:31:14.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>shell 中可以用户定义函数，然后在shell脚本中可以随便调用。<br>函数定义格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以带function fun() 定义，也可以直接fun() 定义,不带任何参数</li><li>参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255)</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 定义函数并调用</span><br><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;-----函数开始执行-----&quot;</span><br><span class="line">demoFun</span><br><span class="line">echo &quot;-----函数执行完毕-----&quot;</span><br><span class="line"></span><br><span class="line"># 执行脚本结果：</span><br><span class="line"></span><br><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure><p>带有返回参数的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></table></figure><p>函数返回值在调用该函数后通过 $? 来获得。</p><p><strong>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</strong></p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure><p>值得注意的是，<strong>$10 不能获取第十个参数，获取第十个参数需要${10}</strong>。当n&gt;=10时，需要使用${n}来获取参数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;shell 中可以用户定义函数，然后在shell脚本中可以随便调用。&lt;br&gt;函数定义格式：&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习08：流程控制</title>
    <link href="http://www.duanmuxu.top/20190630/shell-learning-08-process-control.html"/>
    <id>http://www.duanmuxu.top/20190630/shell-learning-08-process-control.html</id>
    <published>2019-06-30T03:32:43.921Z</published>
    <updated>2019-06-30T03:34:27.741Z</updated>
    
    <content type="html"><![CDATA[<p><strong>shell中的流程控制不能为空</strong></p><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h4 id="if-语句格式"><a href="#if-语句格式" class="headerlink" title="if 语句格式"></a>if 语句格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>写成一行的形式，除了最后一个fi，每个语句后面都需要加上 ;进行语句分割，否则会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;lop&quot; = &quot;lop&quot; ]; then echo &quot;true&quot;; fi</span><br></pre></td></tr></table></figure><h4 id="if-else-语句格式"><a href="#if-else-语句格式" class="headerlink" title="if else 语句格式"></a>if else 语句格式</h4><p>前面说过流程控制不能为空，即如果if条件中else 的值为空，那么else就不要写。因此if 与if else 分开来讲。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="if-else-if-else-语句格式"><a href="#if-else-if-else-语句格式" class="headerlink" title="if else-if else 语句格式"></a>if else-if else 语句格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>语句格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line">The value is: 5</span><br></pre></td></tr></table></figure><p>也可以使用以下形式的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for ((i=1;i&lt;=5;i++))</span><br><span class="line">do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>用于循环判断/读取信息，直到判断条件为假时退出。语句格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>while还可以和read命令连用，用于循环读取信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;</span><br><span class="line">echo -n &apos;输入你的名字： &apos;</span><br><span class="line">while read NAME</span><br><span class="line">do</span><br><span class="line">    echo &quot;你好！$&#123;NAME&#125;!&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这种方法会造成无限死循环，因此需要 CTRL-D 退出</p><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>除了上面讲的通过while与read连用造成无限循环外，还可以使用下面几种方法进入无限循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 2</span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 3</span><br><span class="line">for (( ; ; ))</span><br></pre></td></tr></table></figure><h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p>与while 循环在处理方式上正好相反，until 循环执行一系列命令直至条件为 true 时停止。语句格式：condition条件为假则一直执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>多选择语句，可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。语句格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>举个栗子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;输入 1 到 4 之间的数字:&apos;</span><br><span class="line">echo &apos;你输入的数字为:&apos;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &apos;你选择了 1&apos;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &apos;你选择了 2&apos;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &apos;你选择了 3&apos;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &apos;你选择了 4&apos;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &apos;你没有输入 1 到 4 之间的数字&apos;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>输入不同的内容，会有不同的结果，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入 1 到 4 之间的数字:</span><br><span class="line">你输入的数字为:</span><br><span class="line">2</span><br><span class="line">你选择了 2</span><br></pre></td></tr></table></figure><p>esac作为case 语句的结束标志，与前面if 语句的fi 异曲同工。并且每个case分支用右圆括号，用两个分号表示break。</p><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><h4 id="break-命令"><a href="#break-命令" class="headerlink" title="break 命令"></a>break 命令</h4><p>break命令允许跳出所有循环（终止执行后面的所有循环），直接上例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">while read num</span><br><span class="line">do</span><br><span class="line">    echo &quot;你输入的数字为：$&#123;num&#125;&quot;</span><br><span class="line">    if [ $&#123;num&#125; -eq 2]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;输入正确！&quot;</span><br><span class="line">        break</span><br><span class="line">    else</span><br><span class="line">        echo &quot;输入错误，请重新输入：&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 执行脚本</span><br><span class="line">sh test.sh</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">你输入的数字为：3</span><br><span class="line">输入错误，请重新输入：</span><br><span class="line"></span><br><span class="line"># 执行脚本</span><br><span class="line">sh test.sh</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">你输入的数字为：2</span><br><span class="line">输入正确！</span><br></pre></td></tr></table></figure><h4 id="continue-命令"><a href="#continue-命令" class="headerlink" title="continue 命令"></a>continue 命令</h4><p>与break类似，但是不会跳出所有循环，仅仅跳出当前循环。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read Num</span><br><span class="line">    case $Num in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $Num!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;shell中的流程控制不能为空&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;if-else&quot;&gt;&lt;a href=&quot;#if-else&quot; class=&quot;headerlink&quot; title=&quot;if else&quot;&gt;&lt;/a&gt;if else&lt;/h2&gt;&lt;h4 id=&quot;if-语句
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习07：read、echo和printf命令</title>
    <link href="http://www.duanmuxu.top/20190630/shell-learning-07-read-echo-and-printf-commands.html"/>
    <id>http://www.duanmuxu.top/20190630/shell-learning-07-read-echo-and-printf-commands.html</id>
    <published>2019-06-29T16:47:14.861Z</published>
    <updated>2019-06-29T16:48:58.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>read 命令用于一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。</p><p>实例及参数说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 脚本 test.sh 内容</span><br><span class="line"></span><br><span class="line">read firstStr secondStr</span><br><span class="line">echo &quot;第一个参数:$&#123;firstStr&#125;  第二个参数:$&#123;secondStr&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 执行脚本 test.sh</span><br><span class="line">sh test.sh </span><br><span class="line">one two three</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">第一个参数:one 第二个参数:two three</span><br></pre></td></tr></table></figure><p>read 参数说明：</p><ul><li>-p 输入提示文字</li><li>-n 输入字符长度限制(达到6位，自动结束)</li><li>-t 输入限时</li><li>-s 隐藏输入内容<br>实例：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 脚本 test.sh 内容</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入一段文字:&quot; -n 6 -t 5 -s password</span><br><span class="line">echo -e &quot;\npassword is $password&quot;</span><br><span class="line"></span><br><span class="line"># 执行脚本 test.sh</span><br><span class="line">sh test.sh </span><br><span class="line">请输入一段文字:</span><br><span class="line">123456789</span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">password is 123456789</span><br></pre></td></tr></table></figure><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>从之前学习的例子看来，echo就是用于字符串的输出，这个字符串可以直接是字符串，也可以是变量。</p><p>具体的功能有以下几种：</p><h4 id="显示普通字符串"><a href="#显示普通字符串" class="headerlink" title="显示普通字符串"></a>显示普通字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 这里字符串加不加双引号结果都是一样的</span><br><span class="line"></span><br><span class="line">echo &quot;It is a test&quot;</span><br><span class="line">echo It is a test</span><br><span class="line"></span><br><span class="line"># 输出： </span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></table></figure><h4 id="显示转义字符"><a href="#显示转义字符" class="headerlink" title="显示转义字符"></a>显示转义字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br><span class="line">echo \&quot;It is a test\&quot; # 双引号也可以省略</span><br><span class="line"></span><br><span class="line"># 输出： </span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></table></figure><h4 id="显示变量"><a href="#显示变量" class="headerlink" title="显示变量"></a>显示变量</h4><p>有两种情况，一种是通过read命令读取用户输入的变量，然后输出；一种是脚本内部的变量，相当于字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 用户输入变量</span><br><span class="line">#! /bin/sh</span><br><span class="line">read name </span><br><span class="line">echo &quot;My name is $&#123;name&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 执行</span><br><span class="line">sh test.sh</span><br><span class="line">Jerry</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">My name is Jerry</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 脚本内部变量</span><br><span class="line">#! /bin/sh</span><br><span class="line">time=$(date) </span><br><span class="line">echo &quot;time is $&#123;time&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 直接执行脚本并输出：</span><br><span class="line"></span><br><span class="line">Sat Jun 29 15:41:38 UTC 2019</span><br></pre></td></tr></table></figure><h4 id="显示命令执行结果"><a href="#显示命令执行结果" class="headerlink" title="显示命令执行结果"></a>显示命令执行结果</h4><p>以上通过变量获取时间再输出的方式，可以直接把获取时间的命令放在echo中输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 脚本内容</span><br><span class="line">echo `date`</span><br><span class="line"></span><br><span class="line"># 输出 </span><br><span class="line">Sat Jun 29 15:41:38 UTC 2019</span><br></pre></td></tr></table></figure><h4 id="输出结果到文件中"><a href="#输出结果到文件中" class="headerlink" title="输出结果到文件中"></a>输出结果到文件中</h4><p>通常用在写日志里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 脚本内容</span><br><span class="line">echo &quot;time is `date`&quot; &gt; filename</span><br><span class="line">echo &quot;time is `date`&quot; &gt;&gt; filename</span><br></pre></td></tr></table></figure><ul><li><blockquote><p>表示将echo的内容写进 filename文件中，若文件中已有内容，先删除后添加</p></blockquote></li><li><blockquote><blockquote><p>表示将echo 的内容追加到 filename 文件中，不删除文件原有内容</p></blockquote></blockquote></li></ul><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>学过C语言的应该都知道C的输出命令最常用的就是printf了，Shell中的printf也差不多，可以给输出的内容指定类型，具体语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br><span class="line"></span><br><span class="line">- format-string: 为格式控制字符串</span><br><span class="line">- arguments: 为参数列表</span><br></pre></td></tr></table></figure><p>举个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#！ /bin/bash</span><br><span class="line"></span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; Jerry 男 62.2223</span><br><span class="line"></span><br><span class="line"># 输出为：</span><br><span class="line">Jerry     男      62.22</span><br></pre></td></tr></table></figure><p>%s %c %d %f都是格式替代符</p><ul><li>d: Decimal 十进制整数 – 对应位置参数必须是十进制整数</li><li>s: String 字符串 – 对应位置参数必须是字符串或者字符型</li><li>c: Char 字符 – 对应位置参数必须是字符串或者字符型</li><li>f: Float 浮点 – 对应位置参数必须是数字型</li></ul><p>例子中的%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来；%-4.2f 指格式化为小数，其中.2指保留2位小数。</p><p>更多实例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 1.格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span><br><span class="line">printf &quot;%s %s %s\n&quot; a b c d e f g h i j</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span><br><span class="line"></span><br><span class="line">printf &quot;%s and %d \n&quot; </span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line"> and 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;read&quot;&gt;&lt;a href=&quot;#read&quot; class=&quot;headerlink&quot; title=&quot;read&quot;&gt;&lt;/a&gt;read&lt;/h2&gt;&lt;p&gt;read 命令用于一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习06：运算符汇总</title>
    <link href="http://www.duanmuxu.top/20190628/shell-learning-06-operator-summary.html"/>
    <id>http://www.duanmuxu.top/20190628/shell-learning-06-operator-summary.html</id>
    <published>2019-06-28T15:52:54.730Z</published>
    <updated>2019-06-28T15:55:08.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>原生bash不支持直接的数学运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 若直接执行以下脚本</span><br><span class="line">#！ /bin/bash</span><br><span class="line"></span><br><span class="line">var=$(3 + 4)</span><br><span class="line">echo &quot;两数之和为$&#123;var&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 执行脚本，得到下面报错信息</span><br><span class="line">command not found</span><br></pre></td></tr></table></figure><p>虽然不支持直接的数学运算，但是可以通过命令来实现数学运算。通常使用expr 命令来进行数学运算，expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 执行以下脚本</span><br><span class="line">#！ /bin/bash</span><br><span class="line"></span><br><span class="line">var=$(expr 3 + 4)</span><br><span class="line">echo &quot;两数之和为$&#123;var&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 执行脚本，得到以下结果</span><br><span class="line">两数之和为 : 7</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>表达式和运算符之间要有空格，例如 3+4 是不对的，得出来的结果是“两数之和为 : 3+4”必须写成 3 + 4才能得到正确的运算结果；</li><li>表达式要被$() 或者<code></code> (反引号)包含，表示执行这一运算操作。</li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>与我们平时使用的运算符相同</p><ul><li>加法   +</li><li>减法   -</li><li>乘法   *</li><li>除法   /</li><li>取余   %</li><li>赋值   =</li><li>相等   ==</li><li>不相等   != </li></ul><p>使用算术运算符时也需要注意以下几点：</p><ul><li><strong>条件表达式要放在方括号之间，并且要有空格</strong>，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ];</li><li>乘号(*)前边必须加反斜杠(\ )才能实现乘法运算，[ 4 \ * 5 ];</li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>重点来啦</p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>-eq</td><td>判断两个数是否相等，相等返回 true</td></tr><tr><td>-ne</td><td>判断两个数是否不相等，不相等返回 true</td></tr><tr><td>-gt</td><td>判断左边的数是否大于右边的，如果是，则返回 true</td></tr><tr><td>-lt</td><td>判断左边的数是否小于右边的，如果是，则返回 true</td></tr><tr><td>-ge</td><td>判断左边的数是否大于等于右边的，如果是，则返回 true</td></tr><tr><td>-le</td><td>判断左边的数是否小于等于右边的，如果是，则返回 true</td></tr></tbody></table><p>注意，以上关系运算符<strong>只支持数字或者值为数字的字符串</strong>，不支持除了值为数字以外的字符串。</p><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>！</td><td>非运算，表达式为 true 则返回 false，否则返回 true</td></tr><tr><td>-o</td><td>或运算，有一个表达式为 true 则返回 true</td></tr><tr><td>-a</td><td>与运算，两个表达式都为 true 才返回 true</td></tr></tbody></table><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#！ /bin/bash</span><br><span class="line"></span><br><span class="line">value1=0</span><br><span class="line">value2=5</span><br><span class="line">value3=10</span><br><span class="line"></span><br><span class="line">if [ ! $&#123;value1&#125; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;! 起作用啦&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;! 没有起作用&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $&#123;value2&#125; -o $&#123;value1&#125; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;$&#123;value1&#125; 或 $&#123;value2&#125; 为真&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$&#123;value1&#125; 或 $&#123;value2&#125; 为假&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $&#123;value1&#125; -a $&#123;value2&#125; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;$&#123;value1&#125; 与 $&#123;value2&#125; 为真&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$&#123;value1&#125; 与 $&#123;value2&#125; 为假&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $&#123;value1&#125; -a $&#123;value3&#125; == $&#123;value2&#125; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;$&#123;value1&#125; 与 $&#123;value3&#125; 为真&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;$&#123;value1&#125; 与 $&#123;value3&#125; 为假&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结果为</span><br><span class="line">! 没有起作用</span><br><span class="line">0 或 5 为真</span><br><span class="line">0 与 5 为真</span><br><span class="line">0 与 10 为假</span><br></pre></td></tr></table></figure><p>从结果可以看出，这与我们平时 ！ 运算的要求不大一样，平时编程时 !0 即为真，但在shell里，0 为字符串，真实存在的即为真，所以 !0 为假。因此只有通过其他运算符判断为假的表达式和!共用才能整体判断为真。如if [ ${value1} -a ${value3} == ${value2} ]例子所示。</p><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>=</td><td>判断两个字符串是否相等，相等返回 true</td></tr><tr><td>!=</td><td>判断两个字符串是否相等，不相等返回 true</td></tr><tr><td>-z</td><td>（zero）判断字符串长度是否为0，为0返回 true</td></tr><tr><td>-n</td><td>判断字符串长度是否为0，不为0返回 true</td></tr><tr><td>$</td><td>判断字符串是否为空，不为空返回 true</td></tr></tbody></table><p>与上面布尔运算符不同，字符串运算符的两边为字符串，布尔运算符的两边为判断结果为true 或 false 的布尔变量。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>与Java相同，&amp;&amp; 表示 逻辑与，|| 表示逻辑或</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数学运算&quot;&gt;&lt;a href=&quot;#数学运算&quot; class=&quot;headerlink&quot; title=&quot;数学运算&quot;&gt;&lt;/a&gt;数学运算&lt;/h2&gt;&lt;p&gt;原生bash不支持直接的数学运算&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习05：参数传递</title>
    <link href="http://www.duanmuxu.top/20190626/shell-learning-05-parameter-passing.html"/>
    <id>http://www.duanmuxu.top/20190626/shell-learning-05-parameter-passing.html</id>
    <published>2019-06-26T15:44:57.067Z</published>
    <updated>2019-06-26T15:46:56.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>执行脚本时，可以向脚本里面传递参数，脚本可以根据传递的参数进行进一步操作。</p><p>脚本内获取参数的格式为：$n。n代表一个数字，比如 $1 表示传进来的第一个参数，$2 表示传进来的第二个参数，以此类推。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>创建脚本并添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch chuancan.sh</span><br><span class="line">vim chuancan.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Shell 传递参数&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br></pre></td></tr></table></figure><p>设置可执行权限，并执行脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 设置可执行权限</span><br><span class="line">chmod +x chuancan.sh</span><br><span class="line"></span><br><span class="line"># 执行文件</span><br><span class="line">./chuancan.sh 参数一 参数二 参数三</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">Shell 传递参数</span><br><span class="line">执行的文件名：./chuancan.sh</span><br><span class="line">第一个参数为：参数一</span><br><span class="line">第二个参数为：参数二</span><br><span class="line">第三个参数为：参数三</span><br></pre></td></tr></table></figure><h2 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h2><ul><li>$# : 表示传递参数的个数</li><li>$* : 字符串形式展示传递给脚本的所有参数</li><li>$$ : 当前脚本运行的当前进程ID号</li><li>$@ : 与$* 相同，但是使用时会给每个参数加引号，在引号中返回每个参数</li><li>$? : 显示最后命令的退出状态，0表示没有错误，其他值都表示有错误。</li></ul><h3 id="参数处理实例"><a href="#参数处理实例" class="headerlink" title="参数处理实例"></a>参数处理实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;Shell 传递参数&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br><span class="line"></span><br><span class="line">echo &quot;$#&quot;</span><br><span class="line">echo &quot;$*&quot;</span><br><span class="line">echo &quot;$$&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;$?&quot;</span><br><span class="line"></span><br><span class="line"># 输出结果为：</span><br><span class="line">Shell 传递参数</span><br><span class="line">执行的文件名：./chuancan.sh</span><br><span class="line">第一个参数为：参数一</span><br><span class="line">第二个参数为：参数二</span><br><span class="line">第三个参数为：参数三</span><br><span class="line">3</span><br><span class="line">参数一 参数二 参数三</span><br><span class="line">2437</span><br><span class="line">参数一 参数二 参数三</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="与-详解"><a href="#与-详解" class="headerlink" title="$* 与 $@ 详解"></a>$* 与 $@ 详解</h2><ul><li>相同点：都是引用所有参数</li><li>不同点：$* 是直接以字符串的形式输出参数字符串，$@ 则是将参数先用双引号包含，再引用双引号中的所有参数</li></ul><hr><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$* 测试 ---&quot;</span><br><span class="line">for i in &quot;$*&quot;; do</span><br><span class="line">  echo &quot;$i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$@ 测试 ---&quot;</span><br><span class="line">for i in &quot;$@&quot;; do</span><br><span class="line">  echo &quot;$i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line"></span><br><span class="line">-- $* 测试 ---</span><br><span class="line">参数一 参数二 参数三</span><br><span class="line">-- $@ 测试 ---</span><br><span class="line">参数一</span><br><span class="line">参数二</span><br><span class="line">参数三</span><br></pre></td></tr></table></figure><h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>有时候我们执行带参数的脚本可能只是为了某种特殊情况才需要传入参数进行执行，比如说有个脚本作用是转移每一天的数据，执行一段时间后发现某一天的数据给没了，或者某一天执行失败但是没被发现，那么就需要传入特定的天数参数去执行脚本。</p><p>那么问题来了，既然有时候会用到参数，那么我们怎么判断脚本里是否有参数传递呢？</p><p>其实想一想就能知道，可以用判断，如果传进来的参数不为空，那么就用传进来的参数作为执行条件，若为空，则无事发生，继续执行脚本。</p><h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>创建脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建脚本</span><br><span class="line">touch getTime.sh</span><br><span class="line"></span><br><span class="line"># 给脚本赋权</span><br><span class="line">chmod +x getTime.sh</span><br><span class="line"></span><br><span class="line"># 编辑脚本</span><br><span class="line">vim getTime.sh</span><br></pre></td></tr></table></figure><p>输入脚本内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">now_time=$(date +%Y%m%d)</span><br><span class="line"></span><br><span class="line">if [ $1 ];then</span><br><span class="line">echo &quot;现在时间为$1&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;现在时间为$&#123;now_time&#125;&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>不带参数运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 运行脚本</span><br><span class="line">$  ./getTime.sh</span><br><span class="line"></span><br><span class="line"># 运行结果</span><br><span class="line">现在时间为20190626</span><br></pre></td></tr></table></figure><p>带参数运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 运行脚本</span><br><span class="line">$  ./getTime.sh 20190505</span><br><span class="line"></span><br><span class="line"># 运行结果</span><br><span class="line">现在时间为20190505</span><br></pre></td></tr></table></figure><p>脚本内容使用if进行判断，这里注意两点：一是获取时间，$(date +%Y%m%d) 中，date 与 + 号要用空格隔开，二是判断语句中if与大括号间要用空格隔开，否则会执行失败。具体函数后面会讲，这里不做过多介绍。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;执行脚本时，可以向脚本里面传递参数，脚本可以根据传递的参数进行进一步操作。&lt;/p&gt;
&lt;p&gt;脚本内获取参数的格式为：$n。n代表一个数字，比如
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习04：Shell数据类型</title>
    <link href="http://www.duanmuxu.top/20190625/shell-learning-04-data-type.html"/>
    <id>http://www.duanmuxu.top/20190625/shell-learning-04-data-type.html</id>
    <published>2019-06-25T02:14:09.511Z</published>
    <updated>2020-02-18T17:31:14.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串引用"><a href="#字符串引用" class="headerlink" title="字符串引用"></a>字符串引用</h2><p>Shell中引用字符串可以使用双引号，也可以使用单引号，也可以不使用引号。</p><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>最常使用的引用形式就是加双引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;test&quot;</span><br><span class="line">echo &quot;quote \&quot;$str\&quot;&quot;</span><br></pre></td></tr></table></figure><p>使用双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=&apos;this is a string&apos;</span><br></pre></td></tr></table></figure><p>使用单引号有所限制：</p><ul><li>在echo命令下，单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><h3 id="无引号"><a href="#无引号" class="headerlink" title="无引号"></a>无引号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=this is a string</span><br><span class="line">str=this</span><br></pre></td></tr></table></figure><p>不使用引号只适合引用单个单词变量时使用，空格之后的字符无法识别。</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;Jerry&quot;</span><br><span class="line"># 使用双引号拼接</span><br><span class="line">greeting1=&quot;hello, &quot;$your_name&quot; !\r&quot;</span><br><span class="line">greeting2=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo -e $greeting1$greeting2</span><br><span class="line"># 使用单引号拼接</span><br><span class="line">greeting3=&apos;hello, &apos;$your_name&apos; !\r&apos;</span><br><span class="line">greeting4=&apos;hello, $&#123;your_name&#125; !&apos;</span><br><span class="line">echo -e $greeting3$greeting4</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello, Jerry !</span><br><span class="line">hello, Jerry !</span><br><span class="line">hello, Jerry !</span><br><span class="line">hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure><p>证明单引号中直接引用变量是无效的。</p><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcdefg&quot;</span><br><span class="line">echo $&#123;#string&#125; </span><br><span class="line"></span><br><span class="line">#输出为7</span><br></pre></td></tr></table></figure><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;I am learning Shell!&quot;</span><br><span class="line">echo $&#123;string:1:5&#125; # 输出 am l</span><br><span class="line">echo $&#123;string:3&#125; # 输出 m learning Shell!</span><br></pre></td></tr></table></figure><p>空格不做字符统计，使用${string:1:5}时包头不包尾。</p><h3 id="反引号使用"><a href="#反引号使用" class="headerlink" title="反引号使用"></a>反引号使用</h3><p>如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和$(命令)是一样的，但是反引号非常容易和单引号搞混，所以推荐大家使用 $(命令) 的方式引用命令的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br><span class="line"></span><br><span class="line">#输出为：Tue Jun 25 01:43:27 UTC 2019</span><br><span class="line">#作用与命令  echo $(date)  相同</span><br></pre></td></tr></table></figure><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;I am learning Shell!&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; Sh`</span><br><span class="line">echo $(expr index &quot;$string&quot; Sh)</span><br><span class="line"></span><br><span class="line">#输出为 15</span><br></pre></td></tr></table></figure><p>查找字符 S 的位置(哪个字母先出现就计算哪个)</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><p>数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><p>用括号来表示数组，数组元素用空格分割开，<strong>等号左边不能加空格</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3 ...)</span><br></pre></td></tr></table></figure><p>也可以使用空行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还可以单独定义数组的各个分量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">...</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure><p><strong>可以不使用连续的下标，而且下标的范围没有限制。</strong></p><h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;array_name[index]&#125;</span><br></pre></td></tr></table></figure><p>通过引用数组的方式进行读取</p><p>使用 @ 获取 * 符号可以获取数组中的所有元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array=(1 2 3 4)</span><br><span class="line">echo $&#123;array[2]&#125;</span><br><span class="line">echo $&#123;array[@]&#125;</span><br><span class="line">echo $&#123;array[*]&#125;</span><br><span class="line"></span><br><span class="line">#输出为</span><br><span class="line">3</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h2><p>获取数组长度的方法与获取字符串长度的方法相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">array=(12 2 3 4)</span><br><span class="line"># 取得数组指定元素的长度</span><br><span class="line">echo $&#123;#array[2]&#125;</span><br><span class="line"># 取得数组元素的个数</span><br><span class="line">echo $&#123;#array[@]&#125;</span><br><span class="line"># 取得数组元素的个数</span><br><span class="line">echo $&#123;#array[*]&#125;</span><br><span class="line"># 取得数组单个元素的长度（取最大）</span><br><span class="line">echo $&#123;#array[n]&#125;</span><br><span class="line"></span><br><span class="line"># 输出为</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;h2 id=&quot;字符串引用&quot;&gt;&lt;a href=&quot;#字符串引用&quot; class=&quot;headerlink&quot; title=&quot;字符串引用&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习03：expect实现自动输入密码登录服务器</title>
    <link href="http://www.duanmuxu.top/20190620/shell-learning-03-expect-to-automatically-enter-a-password-log-in-the-server.html"/>
    <id>http://www.duanmuxu.top/20190620/shell-learning-03-expect-to-automatically-enter-a-password-log-in-the-server.html</id>
    <published>2019-06-20T15:14:46.304Z</published>
    <updated>2019-06-20T15:30:26.758Z</updated>
    
    <content type="html"><![CDATA[<p>我们通过Shell脚本可以实现简单的控制流功能，比如说循环、判断、对本地文件进行一些简单的操作、输入输出写日志等，但都是对于本地机器而言进行的操作。那么当我们<strong>需要在一台机器上操作另一台机器时</strong>，那该怎么办呢？</p><p>expect就是用来实现这种交互功能的工具。</p><h2 id="expect介绍"><a href="#expect介绍" class="headerlink" title="expect介绍"></a>expect介绍</h2><p>expect是Unix系统中用来进行自动化控制和测试的软件工具，作为Tcl脚本语言的一个扩展，应用在交互式软件中如telnet，ftp，Passwd，fsck，rlogin，tip，ssh等等。expect是一个免费的编程工具，用来实现自动的交互式任务，而无需人为干预。说白了，expect就是一套用来实现自动交互功能的软件，比如上面说的一台机子操作另一台机子。</p><p>在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而利用expect，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。这就是expect！</p><h2 id="expect安装"><a href="#expect安装" class="headerlink" title="expect安装"></a>expect安装</h2><p>我用的是Ubuntu发行版，因此执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install expect</span><br></pre></td></tr></table></figure><p>就ok啦，CentOS用户可以通过命令 yum  install expect 安装</p><h2 id="expect相关命令"><a href="#expect相关命令" class="headerlink" title="expect相关命令"></a>expect相关命令</h2><ul><li>spawn：启动新的进程</li><li>expect：从进程接收字符串（换行后系统自动打印的字符串）</li><li>send：用于向进程发送字符串 </li><li>interact：允许用户交互</li><li>exp_continue： 匹配多个字符串在执行动作后加此命令</li></ul><h2 id="expect参数"><a href="#expect参数" class="headerlink" title="expect参数"></a>expect参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name [lindex $argv 0]</span><br></pre></td></tr></table></figure><p>使用[lindex $argv 0]进行读取参数，使用set将参数添加进变量中</p><h2 id="实例详解"><a href="#实例详解" class="headerlink" title="实例详解"></a>实例详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">set timeout 30</span><br><span class="line">set host &quot;10.11.43.90&quot;</span><br><span class="line">set username &quot;root&quot;</span><br><span class="line">set password &quot;123456&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &quot;*password*&quot; </span><br><span class="line">&#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><ul><li>set timeout 30：设置超时时间，单位为秒，默认情况下是10秒，也可设为-1，表示一直运作</li><li>set host/username/password：设置变量</li><li>spawn ssh $username@$host：启动新的进程，spawn主要的功能是给ssh运行进程加个壳，用来传递交互指令。这里变量的引用和Shell脚本中一致，直接使用$或者使用${}都可以</li><li>expect “<em>password</em>“：接受的字符串中是否包含’password’这个子串</li><li>{send “$password\r”}：如果包含，则发送$password过去并回车，即执行交互动作</li><li>interact：执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。</li></ul><h2 id="expect登录其他服务器执行命令"><a href="#expect登录其他服务器执行命令" class="headerlink" title="expect登录其他服务器执行命令"></a>expect登录其他服务器执行命令</h2><p>以下内容是一台机器通过ssh登录另一台机器，并在另一台机器上执行命令将以日期作为分区的文件从一个hdfs集群转移至另一个hdfs集群上。参数为一个日期，如果传了参数，则使用用户传的参数，否则使用前一天的日期作为分区标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/expect</span><br><span class="line"># 设置超时时间 等待三十秒</span><br><span class="line">set timeout 30</span><br><span class="line"># 传入参数</span><br><span class="line">set name [lindex $argv 0]</span><br><span class="line"></span><br><span class="line"># 设置时间</span><br><span class="line">set date [ clock format [ clock seconds ] -format &quot;%Y%m%d&quot; ]</span><br><span class="line">set secon [  clock seconds ]</span><br><span class="line">set yestoday_secon 0</span><br><span class="line"> </span><br><span class="line">set yestoday_secon [expr &#123;$secon - 86400&#125; ]</span><br><span class="line">set yestoday [ clock format [ expr &#123;$yestoday_secon&#125; ] -format &quot;%Y%m%d&quot; ]</span><br><span class="line"></span><br><span class="line">if &#123;&quot;$name&quot; &gt; 0&#125; &#123;</span><br><span class="line">        set time &quot;$name&quot;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        set time &quot;$yestoday&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn ssh hadoop@10.11.43.90</span><br><span class="line">expect &quot;*assword&quot;     </span><br><span class="line">send &quot;123456\r&quot; </span><br><span class="line"></span><br><span class="line">expect &quot;hadoop&quot;</span><br><span class="line">send &quot;hadoop distcp hdfs://10.11.56.29/apps/hive/warehouse/location_stay/dt=$&#123;time&#125;/* /DOMAIN_B/DISNEY/LOCATION/APP/HY/location_stay/dt=$&#123;time&#125;\r&quot;</span><br><span class="line"></span><br><span class="line">expect &quot;hadoop&quot;</span><br><span class="line">send &quot;exit\r&quot;</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们通过Shell脚本可以实现简单的控制流功能，比如说循环、判断、对本地文件进行一些简单的操作、输入输出写日志等，但都是对于本地机器而言进行的操作。那么当我们&lt;strong&gt;需要在一台机器上操作另一台机器时&lt;/strong&gt;，那该怎么办呢？&lt;/p&gt;
&lt;p&gt;expect就是用
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习02：Shell变量</title>
    <link href="http://www.duanmuxu.top/20190619/shell-learning-02-variables.html"/>
    <id>http://www.duanmuxu.top/20190619/shell-learning-02-variables.html</id>
    <published>2019-06-19T13:20:22.650Z</published>
    <updated>2019-06-19T13:22:44.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号($)，并且变量名和等号中不能有空格。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempVar=&quot;variable&quot;</span><br></pre></td></tr></table></figure><p>同时，变量名的命令规则如下：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li><li>中间不能有空格，可以使用下划线 _ </li><li>不能使用标点符号</li><li>不能使用bash里的关键字（可用 <strong>compgen -k</strong> 命令查看保留关键字）。</li></ul><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加$符号即可，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tempVar=&quot;variable&quot;</span><br><span class="line">echo $tempVar</span><br><span class="line">echo $&#123;tempVar&#125;</span><br></pre></td></tr></table></figure><p>变量名外面的大括号是可选的，加大括号是为了帮助解释器识别变量的边界，防止出现识别错误变量。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;shell&quot;</span><br><span class="line">echo &quot;I am learning $&#123;str&#125;skill&quot;</span><br></pre></td></tr></table></figure><p>打印出来就是<strong>I am learning shellskill</strong>，如果没有大括号，则打印出来的内容是<strong>I am learning</strong>，系统识别<em>strskill</em>为一个变量，但并没有此变量，因此打印变量为空。所以使用变量时建议加上大括号，更为规范。</p><h3 id="readonly-只读变量"><a href="#readonly-只读变量" class="headerlink" title="readonly 只读变量"></a>readonly 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myVar=&quot;change&quot;</span><br><span class="line">readonly myVar</span><br><span class="line">myUrl=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure><p>运行时报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令就可以删除变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset myVar</span><br></pre></td></tr></table></figure><p>变量被删除后不能再次使用。并且 unset 命令不能删除<strong>只读变量</strong>。</p><p>（当脚本文件规模不大时，要删除变量的话直接在脚本里把变量去掉就行了。）</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>环境变量</li><li>本地变量</li><li>局部变量</li><li>位置变量</li><li>特殊变量（bash内置变量，也称系统变量）</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export var_name=value    //作用域为当前shell进程及其子进程`</span><br></pre></td></tr></table></figure><p>给Linux系统配置过JDK的同学应该对这个变量很熟悉</p><h4 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_name=value   //本地变量，作用域为当前shell进程，对当前shell外的其他shell进程，v包括当前shell，子shell进程均无效</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local var_name=value  //局部变量，作用域为当前代码段，常用于函数</span><br></pre></td></tr></table></figure><p>局部变量也是一种本地变量</p><h4 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$1,$2,$3, ....  //用来引用脚本的参数</span><br><span class="line">shift [num]     //位置变量使用完以后退出，后面的参数向前推进 </span><br><span class="line">shift 1         //一次往前推，例：$1完成任务后变成$2执行</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$#   //是传给脚本的参数个数</span><br><span class="line">$0   //是脚本本身的名字</span><br><span class="line">$!   //是shell最后运行的后台Process的PID</span><br><span class="line">$@   //是传给脚本的所有参数的列表</span><br><span class="line">$*   //是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</span><br><span class="line">$$   //是脚本运行的当前进程ID号</span><br><span class="line">$?   //是显示上条命令的退出状态，0表示没有错误，其他表示有错误</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash内建环境变量，这些变量不能当作自定义变量使用</span><br><span class="line">PATH</span><br><span class="line">SHELL</span><br><span class="line">UID</span><br><span class="line">HISTSIZE</span><br><span class="line">HOME</span><br><span class="line">PWD</span><br><span class="line">HISTFILE</span><br><span class="line">PS1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义变量&quot;&gt;&lt;a href=&quot;#定义变量&quot; class=&quot;headerlink&quot; title=&quot;定义变量&quot;&gt;&lt;/a&gt;定义变量&lt;/h3&gt;&lt;p&gt;定义变量时，变量名不加美元符号($)，并且变量名和等号中不能有空格。如：&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习01：创建和执行脚本文件</title>
    <link href="http://www.duanmuxu.top/20190618/shell-learning-01-create-and-execute-script-files.html"/>
    <id>http://www.duanmuxu.top/20190618/shell-learning-01-create-and-execute-script-files.html</id>
    <published>2019-06-18T07:51:38.418Z</published>
    <updated>2019-06-18T07:55:02.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建Shell脚本"><a href="#新建Shell脚本" class="headerlink" title="新建Shell脚本"></a>新建Shell脚本</h2><p>进入一个你想要放脚本文件的目录。执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接新建脚本文件并进入编辑</span><br><span class="line">vim ShellTest.sh </span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line"># 先新建脚本文件，再进入编辑页面</span><br><span class="line">touch ShellTest.sh  </span><br><span class="line">vim ShellTest.sh</span><br></pre></td></tr></table></figure><p>在脚本文件编辑页面中放入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure><ul><li>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。一般默认使用Bash进行脚本执行。</li><li>echo 命令用于向窗口输出文本。</li></ul><h2 id="执行Shell脚本"><a href="#执行Shell脚本" class="headerlink" title="执行Shell脚本"></a>执行Shell脚本</h2><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><p>在root用户下新建文件时，文件的默认权限为 <strong>-rw-r–r–</strong>，即文件在root用户下可读写，其他用户只能读不能写，但是<strong>所有用户都无法执行</strong>。因此执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ShellTest.sh</span><br></pre></td></tr></table></figure><p>将脚本文件变为可执行文件，执行后的权限为 <strong>-rwxr-xr-x</strong> ，即所有用户都可执行。然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ShellTest.sh</span><br></pre></td></tr></table></figure><p>控制台输出 “Hello World !”，脚本执行成功。 </p><blockquote><p>./ 表示执行本文件所在目录下的某一文件</p></blockquote><h4 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h4><p>这种运行方式直接运行解释器，把 shell 脚本的文件名作为解释器的参数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh ShellTest.sh</span><br></pre></td></tr></table></figure><p>这种方式运行的脚本，不需要在第一行指定解释器信息，也不需要将脚本文件的权限转为可执行，只要作为参数的脚本文件的路径没错就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建Shell脚本&quot;&gt;&lt;a href=&quot;#新建Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;新建Shell脚本&quot;&gt;&lt;/a&gt;新建Shell脚本&lt;/h2&gt;&lt;p&gt;进入一个你想要放脚本文件的目录。执行&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Storm学习02：八种grouping分组策略</title>
    <link href="http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html"/>
    <id>http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html</id>
    <published>2019-06-11T08:24:43.140Z</published>
    <updated>2019-06-11T08:28:15.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>为拓扑中的每个 Bolt 的<strong>确定输入数据流</strong>是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。</p><p>在 Storm 中有八种内置的数据流分组方式，而且还可以通过 <strong>CustomStreamGrouping</strong>接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式）</p><h2 id="具体分组"><a href="#具体分组" class="headerlink" title="具体分组"></a>具体分组</h2><p>这八种分组分时分别为：</p><hr><ul><li>Shuffle grouping：随机分组。这种方式下元组会被尽可能随机地分配到Bolt的不同任务（tasks）中，使得每个任务所处理元组数量能够保持基本一致，以确保集群的负载均衡。</li><li>Fields grouping：按字段分组。这种方式下数据流根据定义的Field来进行分组。比如，如果某个数据流是基于一个名为“user-id”的字段进行分组的，那么所有包含相同的“user-id”的tuple都会被分配到同一个任务中，这样就可以确保消息处理的一致性。</li><li>Partial Key grouping：部分关键字分组。这种方式与Fields grouping很相似，根据定义的域来对数据流进行分组，不同的是，这种方式会考虑下游Bolt数据处理的均衡性问题，在<strong>输入数据源关键字不平衡</strong>时会有更好的性能。</li><li>All grouping：完全分组。这种方式下数据流会被同时发送到Bolt的所有任务中（也就是说同一个元组会被复制多份然后被所有的任务处理），使用这种分组方式要特别小心。</li><li>Global grouping：全局分组。这种方式下所有的数据流都会被发送到 Bolt 的同一个任务中，也就是id最小的那个任务。</li><li>None grouping：无分组。使用这种方式说明你不关心数据流如何分组。目前这种方式的结果与随机分组完全等效，不过未来Storm社区可能会考虑通过非分组方式来让 Bolt 和它所订阅的 Spout 或 Bolt 在同一个线程中执行。</li><li>Direct grouping：直接分组。这是一种特殊的分组方式。使用这种方式意味着元组的发送者可以指定下游的哪个任务可以接收这个元组。只有在数据流被声明为直接数据流时才能够使用直接分组方式。使用直接数据流发送元组需要使用OutputCollector的其中一个emitDirect方法。Bolt可以通过TopologyContext来获取它的下游消费者的任务id，也可以通过跟踪OutputCollector的emit方法（该方法会返回它所发送元组的目标任务的id）的数据来获取任务 id。</li><li>Local or shuffle grouping：本地或随机分组。如果目标bolt有一个或者多个task与源bolt的task在同一个工作进程中，tuple将会被随机发送给这些同进程中的tasks。否则，和普通的Shuffle Grouping行为一致。</li></ul><hr><p>其中Shuffle grouping、Fields grouping、All grouping、Global grouping四种策略用得较多。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>拿最简单的WordCount来做例子：</p><h3 id="新建wordcount项目"><a href="#新建wordcount项目" class="headerlink" title="新建wordcount项目"></a>新建wordcount项目</h3><h4 id="新建RandomSentenceSpout类来产生数据"><a href="#新建RandomSentenceSpout类来产生数据" class="headerlink" title="新建RandomSentenceSpout类来产生数据"></a>新建RandomSentenceSpout类来产生数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.spout.SpoutOutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichSpout;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class RandomSentenceSpout extends BaseRichSpout &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 6102239192526611945L;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(RandomSentenceSpout.class);</span><br><span class="line"></span><br><span class="line">    private SpoutOutputCollector collector;</span><br><span class="line">    private Random random;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此open方法,</span><br><span class="line">     * 一般都会在此方法中对发送Tuple的对象SpoutOutputCollector和配置对象TopologyContext初始化</span><br><span class="line">     */</span><br><span class="line">    public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">        this.random = new Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个spout类，之前说过，最终会运行在task中，某个worker进程的某个executor线程内部的某个task中</span><br><span class="line">     * 那个task会负责去不断的无限循环调用nextTuple()方法</span><br><span class="line">     * 只要的话呢，无限循环调用，可以不断发射最新的数据出去，形成一个数据流</span><br><span class="line">     */</span><br><span class="line">    public void nextTuple() &#123;</span><br><span class="line">        String[] sentences = new String[]&#123;</span><br><span class="line">                &quot;I used to watch her from my kitchen widow&quot;</span><br><span class="line">                , &quot;she seemed so small as she muscled her way through the crowd of boys on the playground&quot;</span><br><span class="line">                , &quot;The school was across the street from our home and I would often watch the kids as they played during recess&quot;</span><br><span class="line">                , &quot;A sea of children, and yet tome&quot;</span><br><span class="line">                , &quot;she stood out from them all&quot;&#125;;</span><br><span class="line">        String sentence = sentences[random.nextInt(sentences.length)];</span><br><span class="line">        LOGGER.info(&quot;  --- 发射 sentence 数据 ---&gt; &#123;&#125;&quot;, sentence);</span><br><span class="line">        // 这个values，你可以认为就是构建一个tuple,tuple是最小的数据单位，无限个tuple组成的流就是一个stream,通过 emit 发送数据到下游bolt tuple</span><br><span class="line">        this.collector.emit(new Values(sentence));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前Spout的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游</span><br><span class="line">     bolt 中 execute 接收数据 key</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;sentence&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新建SplitSentenceBolt类用来切割单词"><a href="#新建SplitSentenceBolt类用来切割单词" class="headerlink" title="新建SplitSentenceBolt类用来切割单词"></a>新建SplitSentenceBolt类用来切割单词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.task.OutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Tuple;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SplitSentenceBolt extends BaseRichBolt &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -4758047349803579486L;</span><br><span class="line"></span><br><span class="line">    private OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法</span><br><span class="line">     * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化</span><br><span class="line">     */</span><br><span class="line">    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的</span><br><span class="line">     * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行</span><br><span class="line">     * 切分单词</span><br><span class="line">     */</span><br><span class="line">    public void execute(Tuple input) &#123;</span><br><span class="line">        // 接收上游数据</span><br><span class="line">        String sentence = input.getStringByField(&quot;sentence&quot;);</span><br><span class="line">        String[] words = sentence.split(&quot; &quot;);</span><br><span class="line">        for(String word : words)&#123;</span><br><span class="line">            //发射数据</span><br><span class="line">            this.collector.emit(new Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key</span><br><span class="line">     * 定义发射出去的tuple，每个field的名称</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;word&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新建WordCountBolt类用来单词计数"><a href="#新建WordCountBolt类用来单词计数" class="headerlink" title="新建WordCountBolt类用来单词计数"></a>新建WordCountBolt类用来单词计数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.shade.com.google.common.collect.Maps;</span><br><span class="line">import org.apache.storm.task.OutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Tuple;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class WordCountBolt extends BaseRichBolt &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(WordCountBolt.class);</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -7114915627898482737L;</span><br><span class="line"></span><br><span class="line">    private OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Long&gt; countMap = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法</span><br><span class="line">     * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化</span><br><span class="line">     */</span><br><span class="line">    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的</span><br><span class="line">     * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行</span><br><span class="line">     * 统计单词</span><br><span class="line">     */</span><br><span class="line">    public void execute(Tuple input) &#123;</span><br><span class="line">        // 接收上游数据</span><br><span class="line">        String word = input.getStringByField(&quot;word&quot;);</span><br><span class="line">        Long count = countMap.get(word);</span><br><span class="line">        if(null == count)&#123;</span><br><span class="line">            count = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">        countMap.put(word, count);</span><br><span class="line">        LOGGER.info(&quot; ---  单词计数[&#123;&#125;] ---&gt; 出现的次数：&#123;&#125;&quot;, word, count);</span><br><span class="line">        //发射数据</span><br><span class="line">        this.collector.emit(new Values(word,count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key</span><br><span class="line">     * 定义发射出去的tuple，每个field的名称</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;word&quot;,&quot;count&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新建WordCountTopology类用来链接Spout和Bolt，执行主程序"><a href="#新建WordCountTopology类用来链接Spout和Bolt，执行主程序" class="headerlink" title="新建WordCountTopology类用来链接Spout和Bolt，执行主程序"></a>新建WordCountTopology类用来链接Spout和Bolt，执行主程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.Config;</span><br><span class="line">import org.apache.storm.LocalCluster;</span><br><span class="line">import org.apache.storm.StormSubmitter;</span><br><span class="line">import org.apache.storm.topology.TopologyBuilder;</span><br><span class="line">import org.apache.storm.utils.Utils;</span><br><span class="line"></span><br><span class="line">public class WordCountTopology &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //去将spout和bolts组合起来，构建成一个拓扑</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line"></span><br><span class="line">        // 第一个参数的意思，就是给这个spout设置一个名字</span><br><span class="line">        // 第二个参数的意思，就是创建一个spout的对象</span><br><span class="line">        // 第三个参数的意思，就是设置spout的executor有几个</span><br><span class="line">        builder.setSpout(&quot;RandomSentence&quot;, new RandomSentenceSpout(), 2);</span><br><span class="line">        builder.setBolt(&quot;SplitSentence&quot;, new SplitSentenceBolt(), 5)</span><br><span class="line">                //为bolt 设置 几个task</span><br><span class="line">                .setNumTasks(10)</span><br><span class="line">                //设置流分组策略</span><br><span class="line">                .shuffleGrouping(&quot;RandomSentence&quot;);</span><br><span class="line"></span><br><span class="line">        // fieldsGrouping 这个很重要，就是说，相同的单词，从SplitSentenceSpout发射出来时，一定会进入到下游的指定的同一个task中</span><br><span class="line">        // 只有这样子，才能准确的统计出每个单词的数量</span><br><span class="line">        // 比如你有个单词，hello，下游task1接收到3个hello，task2接收到2个hello</span><br><span class="line">        // 通过fieldsGrouping 可以将 5个hello，全都进入一个task</span><br><span class="line">        builder.setBolt(&quot;wordCount&quot;, new WordCountBolt(), 10)</span><br><span class="line">                //为bolt 设置 几个task</span><br><span class="line">                .setNumTasks(20)</span><br><span class="line">                //设置流分组策略</span><br><span class="line">                .shuffleGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.globalGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.allGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.fieldsGrouping(&quot;SplitSentence&quot;, new Fields(&quot;word&quot;));</span><br><span class="line"></span><br><span class="line">        // 运行配置项</span><br><span class="line">        Config config = new Config();</span><br><span class="line"></span><br><span class="line">        //说明是在命令行执行，打算提交到storm集群上去</span><br><span class="line">        if(args != null &amp;&amp; args.length &gt; 0)&#123;</span><br><span class="line">            /**</span><br><span class="line">             *  要想提高storm的并行度可以从三个方面来改造</span><br><span class="line">             *  worker(进程)&gt;executor(线程)&gt;task(实例)</span><br><span class="line">             *  增加work进程，增加executor线程，增加task实例</span><br><span class="line">             *  对应 supervisor.slots.port 中配置个数</span><br><span class="line">             *  这里可以动态设置使用个数</span><br><span class="line">             *  最好一台机器上的一个topology只使用一个worker,主要原因时减少了worker之间的数据传输</span><br><span class="line">             *</span><br><span class="line">             *  注意：如果worker使用完的话再提交topology就不会执行，因为没有可用的worker，只能处于等待状态，把之前运行的topology停止一个之后这个就会继续执行了</span><br><span class="line">             */</span><br><span class="line">            config.setNumWorkers(3);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 将Topolog提交集群</span><br><span class="line">                StormSubmitter.submitTopology(args[0], config, builder.createTopology());</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 用本地模式运行1个拓扑时，用来限制生成的线程的数量</span><br><span class="line">            config.setMaxTaskParallelism(20);</span><br><span class="line"></span><br><span class="line">            // 将Topolog提交本地集群</span><br><span class="line">            LocalCluster cluster = new LocalCluster();</span><br><span class="line">            cluster.submitTopology(&quot;wordCountTopology&quot;, config, builder.createTopology());</span><br><span class="line"></span><br><span class="line">            // 为了测试模拟等待</span><br><span class="line">            Utils.sleep(60000);</span><br><span class="line">            // 执行完毕，关闭cluster</span><br><span class="line">            cluster.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="shuffleGrouping运行结果"><a href="#shuffleGrouping运行结果" class="headerlink" title="shuffleGrouping运行结果"></a>shuffleGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611161427796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="shuffleGrouping运行结果" title>                </div>                <div class="image-caption">shuffleGrouping运行结果</div>            </figure><p>随机分组，不自觉间做到了负载均衡。</p><h4 id="globalGrouping运行结果"><a href="#globalGrouping运行结果" class="headerlink" title="globalGrouping运行结果"></a>globalGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611161449921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="globalGrouping运行结果" title>                </div>                <div class="image-caption">globalGrouping运行结果</div>            </figure><p>只往一个里面发,发送到id最小的那个任务。</p><h4 id="allGrouping运行结果"><a href="#allGrouping运行结果" class="headerlink" title="allGrouping运行结果"></a>allGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611161502207.png" alt="allGrouping运行结果" title>                </div>                <div class="image-caption">allGrouping运行结果</div>            </figure><p>两个spot并行 所有都分发。</p><h4 id="fieldsGrouping运行结果"><a href="#fieldsGrouping运行结果" class="headerlink" title="fieldsGrouping运行结果"></a>fieldsGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2019061116151598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="fieldsGrouping运行结果" title>                </div>                <div class="image-caption">fieldsGrouping运行结果</div>            </figure><p>相同的名称的fields分发到一个bolt里面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;为拓扑中的每个 Bolt 的&lt;strong&gt;确定输入数据流&lt;/strong&gt;是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Storm/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>Ambari集群搭建（HDP离线安装版）</title>
    <link href="http://www.duanmuxu.top/20190604/ambari-cluster-build-hdp-offline-installation-version.html"/>
    <id>http://www.duanmuxu.top/20190604/ambari-cluster-build-hdp-offline-installation-version.html</id>
    <published>2019-06-04T10:57:20.241Z</published>
    <updated>2020-02-18T17:31:14.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装环境部署"><a href="#安装环境部署" class="headerlink" title="安装环境部署"></a>安装环境部署</h2><h4 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h4><ul><li>Ubuntu：ubuntu-16.04.6-server-amd64</li><li>Ambari：ambari-2.5.0.3-ubuntu16</li><li>HDP：HDP-2.6.0.3-ubuntu16</li><li>HDP-UTILS：HDP-UTILS-1.1.0.21-ubuntu16</li></ul><h4 id="设置每台主机的host"><a href="#设置每台主机的host" class="headerlink" title="设置每台主机的host"></a>设置每台主机的host</h4><p>首先修改每一台主机的hostname<br>输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>命名随意，不重复就行。</p><p>输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>进入hosts编辑页面<br>每台主机host的配置都要相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 127.0.0.1     localhost ambari01</span><br><span class="line">192.168.2.93    ambari01</span><br><span class="line">192.168.2.94    ambari02</span><br><span class="line">192.168.2.95    ambari03</span><br></pre></td></tr></table></figure><p>ip地址后的名称与hostname中的名称相同</p><p>修改完后ping其他不同的主机，看能不能ping通</p><h4 id="链接Xshell"><a href="#链接Xshell" class="headerlink" title="链接Xshell"></a>链接Xshell</h4><p>安装Ubuntu的时候，勾选安装OpenSSH，系统打开后就能直接使用ssh服务了。</p><p>登录每台主机，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>将该文件下的 <strong>PermitRootLogin</strong>的值改为 <strong>yes</strong></p><p>输入以下命令重启一下SSH服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>重启成功后就能使用xShell连接虚拟机进行操作了。</p><h4 id="免密登录从机"><a href="#免密登录从机" class="headerlink" title="免密登录从机"></a>免密登录从机</h4><p>首先在主机上运行 <strong>sudo ssh-keygen</strong> ，然后一路回车，生成本机公私密钥。 <strong>注意要一路回车，不用输入任何字符。</strong> 然后执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@ambari01</span><br><span class="line">ssh-copy-id root@ambari02</span><br><span class="line">ssh-copy-id root@ambari03</span><br></pre></td></tr></table></figure><p>注意也要对自己本机也操作一次，不然后面在ambari服务器上安装组件的时候本机会显示<strong>permision denied</strong> 的情况。</p><p>执行以上命令时，会依次提示输入每台从机的root密码，然后主机就会自动将公钥发送给各个从机的机器中并立即生效。</p><p>执行后可以通过执行<strong>ssh root@ambari02</strong> 进行测试，可以直接登陆从机，无需密码。</p><h4 id="保存主机的私钥"><a href="#保存主机的私钥" class="headerlink" title="保存主机的私钥"></a>保存主机的私钥</h4><p>复制一份刚才主机生成的私钥，后面ambari搭建集群的时候会需要用到，密钥的文件位于 <strong>/root/.ssh/id_rsa</strong>，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/.ssh/id_rsa /root</span><br></pre></td></tr></table></figure><p>将密钥复制到root文件目录下，然后通过<strong>xftp</strong>将文件下载到Windows本地。因为xftp不能直接访问.ssh目录。</p><h4 id="安装yum和ntp"><a href="#安装yum和ntp" class="headerlink" title="安装yum和ntp"></a>安装yum和ntp</h4><p>每个从机、主机都需要安装yum、ntp，否则后面Ambari部署有些会不通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install yum</span><br><span class="line">apt-get install ntp</span><br></pre></td></tr></table></figure><h4 id="python版本-gt-2-6"><a href="#python版本-gt-2-6" class="headerlink" title="python版本 &gt; 2.6"></a>python版本 &gt; 2.6</h4><p>一般Ubuntu默认都会安装python2.7，此条可以忽略。</p><hr><p>准备工作完毕。下面开始集群的搭建。</p><h2 id="下载HDP与HDP-UTILS离线安装包"><a href="#下载HDP与HDP-UTILS离线安装包" class="headerlink" title="下载HDP与HDP-UTILS离线安装包"></a>下载HDP与HDP-UTILS离线安装包</h2><p>前面一个安装包大约5.9G，如果选择在线安装则太费时间，因此下载已经编译好的HDP安装包进行离线安装。</p><p>首先进入 <a href="https://docs.hortonworks.com/" target="_blank" rel="noopener">https://docs.hortonworks.com/</a> 找到ambari，选择自己想要的版本。本文使用的是Ambari-2.5.0.3版本。选择好版本后，找到<strong>Apache Ambari Installation</strong> ，点击进入后，通过点击 <strong>Getting Ready -&gt; Using a Local Repository -&gt; Obtaining the Repositories -&gt; HDP Stack Repositories</strong> 找到HDP离线版下载，我使用的版本为 HDP-2.6.0.3，具体网址为下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.hortonworks.com/HDPDocuments/Ambari-2.5.0.3/bk_ambari-installation/content/hdp_26_repositories.html</span><br></pre></td></tr></table></figure><p>然后就是漫长的下载之路了，一共6G左右，记住要选择对应的Ambari和虚拟机版本。下载HDP和HDP-UTILS两个文件。</p><h2 id="安装-Ambari"><a href="#安装-Ambari" class="headerlink" title="安装 Ambari"></a>安装 Ambari</h2><p>Ambari只需要在主机上安装，而后安装组件时其他从机会自动部署。</p><p>继续在刚才的网站上，找到 <strong>Download the Ambari Repository</strong>，选择对应的虚拟机版本，然后按照官方手册指引，root用户登录主机后依次执行以下三句命令即可完成安装源的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/apt/sources.list.d/ambari.list http://public-repo-1.hortonworks.com/ambari/ubuntu16/2.x/updates/2.5.0.3/ambari.list</span><br><span class="line">apt-key adv --recv-keys --keyserver keyserver.ubuntu.com B9733A7A07513CAD</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>要注意ambari版本的问题，不要版本不一致。</p><p>具体操作可以查看<a href="https://docs.hortonworks.com/HDPDocuments/Ambari-2.5.0.3/bk_ambari-installation/content/download_the_ambari_repo_ubuntu16.html" target="_blank" rel="noopener">官方操作手册</a>。</p><p>然后进行ambari-server 的安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ambari-server</span><br></pre></td></tr></table></figure><p>一共七百多MB，大概安装个二十分钟左右，视网速而定。</p><h2 id="配置-Ambari"><a href="#配置-Ambari" class="headerlink" title="配置 Ambari"></a>配置 Ambari</h2><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambari-server setup</span><br></pre></td></tr></table></figure><p>进行配置ambari-server，一路回车进行配置，途中会安装JDK，选择JDK1.8继续安装。</p><p>中途也会遇到选择安装数据库，默认选择安装MySQL，继续安装。</p><p>ambari的用户名和密码如果不进行设置则默认都为admin。</p><p>安装好后将JDK1.8安装包发送给每个从机，都将JDK1.8安装一遍。</p><h2 id="启动-Ambari"><a href="#启动-Ambari" class="headerlink" title="启动 Ambari"></a>启动 Ambari</h2><p>操作手册上如是说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Run the following command on the Ambari Server host:</span><br><span class="line">ambari-server start</span><br><span class="line"></span><br><span class="line">- To check the Ambari Server processes:</span><br><span class="line">ambari-server status</span><br><span class="line"></span><br><span class="line">- To stop the Ambari Server:</span><br><span class="line">ambari-server stop</span><br></pre></td></tr></table></figure><p>执行 <strong>ambari-server start</strong> ，稍候片刻启动服务。然后进入网址 <strong>http://&lt;主机IP&gt;:8080</strong> 就可以进入Ambari的登录界面。账号密码如果刚才没有配置，则均为admin。</p><h2 id="部署HDP离线安装包"><a href="#部署HDP离线安装包" class="headerlink" title="部署HDP离线安装包"></a>部署HDP离线安装包</h2><h4 id="安装Nignx"><a href="#安装Nignx" class="headerlink" title="安装Nignx"></a>安装Nignx</h4><p>也不一定是要nignx，只要能提供Http服务，来作为HDP离线包的下载服务器就行。</p><p>主机上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nignx</span><br></pre></td></tr></table></figure><p>安装完成后浏览器进入 <strong>http://&lt;主机IP&gt;:80</strong> 查看是否有Nignx欢迎页面。</p><h4 id="上传HDP离线安装包"><a href="#上传HDP离线安装包" class="headerlink" title="上传HDP离线安装包"></a>上传HDP离线安装包</h4><p>使用xftp进行文件传输，xftp连接主机后进入 <strong>/var/www/html</strong> 目录，将HDP-UTILS-1.1.0.21-ubuntu16.tar.gz和HDP-2.6.0.3-ubuntu16-deb.tar.gz两个文件传到该目录下。</p><p>在linux终端下新建文件夹HDP-UTILS-1.1.0.21，将压缩包HDP-2.6.0.3-ubuntu16-deb.tar.gz直接解压，将压缩包HDP-UTILS-1.1.0.21-ubuntu16.tar.gz解压到新建的文件夹HDP-UTILS-1.1.0.21下</p><p>执行以下命令将默认的欢迎页面重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/www/html/index.nginx-debian.html /var/www/html/index.nginx-debian.html.bak</span><br></pre></td></tr></table></figure><p>进入nignx的配置页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><p>在 <strong>server{…}</strong> 里添加一句 <strong>autoindex on;</strong> 即打开目录浏览功能。</p><p>以上步骤做完后，再次访问 <strong>http://&lt;主机IP&gt;:80</strong> 时，能看到目录结构，同时能找到HDP以及HDP-UTILS，能够从页面上下载，HDP离线安装包就配置好了。</p><h2 id="开始创建集群"><a href="#开始创建集群" class="headerlink" title="开始创建集群"></a>开始创建集群</h2><ul><li>进入 <strong>http://&lt;主机IP&gt;:8080</strong> Ambari登录页面，账号密码均为admin；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160632726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="ambari登录界面" title>                </div>                <div class="image-caption">ambari登录界面</div>            </figure></li><li>登陆后选择<strong>Launch Install Wizard</strong>；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160657570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>命名你的集群，好听点就行；</li><li>下一步，选择本地Repository，选择对应的虚拟机版本，链接填刚才配置好的Nignx的服务器路径址，即<strong>http://&lt;主机IP&gt;/HDP/ubuntu16/</strong> 和 <strong>http://&lt;主机IP&gt;/HDP-UTILS-1.1.0.21/</strong>；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160730196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>进入install options，输入集群机器的ip，选择之前下载到本地的id_rsa文件。点击Register and confirm 进入下一步；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160714458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>confirm host 之后，进行选择服务，即要安装的大数据组件，进行安装</li><li>进行到Customize Services时可能会让你进行一些密码的设置，比如hive组件之类的，设置好不报错后继续安装；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160746440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>安装成功即完成部署。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2019060416075651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li></ul><hr><p>完结撒花！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160902366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><hr><hr><p>参考文章：<a href="https://www.jianshu.com/p/af50f3e8b8b2" target="_blank" rel="noopener">如何优雅地使用Apache Ambari安装HDFS、HBase等分布式应用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装环境部署&quot;&gt;&lt;a href=&quot;#安装环境部署&quot; class=&quot;headerlink&quot; title=&quot;安装环境部署&quot;&gt;&lt;/a&gt;安装环境部署&lt;/h2&gt;&lt;h4 id=&quot;使用版本&quot;&gt;&lt;a href=&quot;#使用版本&quot; class=&quot;headerlink&quot; title=&quot;使
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Ambari" scheme="http://www.duanmuxu.top/tags/Ambari/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转化为阿拉伯数字</title>
    <link href="http://www.duanmuxu.top/20190602/roman-numerals-converted-into-arabic.html"/>
    <id>http://www.duanmuxu.top/20190602/roman-numerals-converted-into-arabic.html</id>
    <published>2019-06-02T04:28:32.282Z</published>
    <updated>2020-02-18T17:31:14.415Z</updated>
    
    <content type="html"><![CDATA[<p>题目简述：</p><hr><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. </p><hr><p>简而言之，从I到M七个字母分别代表着1~1000的七种不同大小。当所给罗马数字的字母顺序为从M到I的顺序排列时，它的值即为其字母所代表的值相加，比如’XXVII’，即表示X+X+V+I+I。当所给罗马数字字符串中有一个字母比这个字母其后的字母所表示的值小时，这两个字母结合起来代表一个数值，其值为（后一个字母的值-前一个字母的值），比如’MCD’，C的值比D小，因此等于M+CD=1000+500-100=1400。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实经过分析过后思路就很明确了，比较所给字符串中当前字母和下一个字母的数值大小，如果当前字母的值比下一个字母的值大，直接相加，反之则后一个字母的值减去当前字母的值，并将这两个字母当作一个整体。</p><p>有了思路，就得有解题方法。既然是涉及到前后两个字母进行比较，那么就有两种情况，<strong>一种是获取当前字母的值，与后一个字母进行比较；一种是保存前一个字母的值，与当前字母的值进行比较。</strong></p><hr><h4 id="当前字母与前一个字母相比较"><a href="#当前字母与前一个字母相比较" class="headerlink" title="当前字母与前一个字母相比较"></a>当前字母与前一个字母相比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        a[&apos;I&apos; - &apos;A&apos;] = 1;</span><br><span class="line">        a[&apos;V&apos; - &apos;A&apos;] = 5;</span><br><span class="line">        a[&apos;X&apos; - &apos;A&apos;] = 10;</span><br><span class="line">        a[&apos;L&apos; - &apos;A&apos;] = 50;</span><br><span class="line">        a[&apos;C&apos; - &apos;A&apos;] = 100;</span><br><span class="line">        a[&apos;D&apos; - &apos;A&apos;] = 500;</span><br><span class="line">        a[&apos;M&apos; - &apos;A&apos;] = 1000;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        char prev = &apos;A&apos;;</span><br><span class="line">        for (char str : s.toCharArray()) &#123;</span><br><span class="line">            if(a[str - &apos;A&apos;] &gt; a[prev - &apos;A&apos;])&#123;</span><br><span class="line">                sum = sum - 2*a[prev - &apos;A&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            sum = sum + a[str - &apos;A&apos;];</span><br><span class="line">            prev = str;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法foreach中，当前值为str，保存的前一个字母为prev。当当前字母的值大于前一个字母的值时，整体总数sum减去前一个字母的值的两倍（一倍拿来消除之前加过的前一个字母的值，一倍拿来做整体两个字母的减数）。从而得出结果。</p><hr><h4 id="当前字母与后一个字母相比较"><a href="#当前字母与后一个字母相比较" class="headerlink" title="当前字母与后一个字母相比较"></a>当前字母与后一个字母相比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; chara = new HashMap&lt;&gt;();</span><br><span class="line">        chara.put(&apos;I&apos;, 1);</span><br><span class="line">        chara.put(&apos;V&apos;, 5);</span><br><span class="line">        chara.put(&apos;X&apos;, 10);</span><br><span class="line">        chara.put(&apos;L&apos;, 50);</span><br><span class="line">        chara.put(&apos;C&apos;, 100);</span><br><span class="line">        chara.put(&apos;D&apos;, 500);</span><br><span class="line">        chara.put(&apos;M&apos;, 1000);</span><br><span class="line"></span><br><span class="line">        int sum = 0; //定义总数</span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(i &lt; s.length()-1 &amp;&amp; chara.get(s.charAt(i)) &lt; chara.get(s.charAt(i+1)))&#123;</span><br><span class="line">                sum = sum - chara.get(s.charAt(i));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum = sum + chara.get(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Map进行存储，当时使用数组也可以，只是为了<strong>存储多元化</strong>。这种方法要注意charAt的界限，防止越界。当当前的字母的值大于下一个字母的值时，正常相加；反之则总数sum减去当前字母的值。</p><p>有一点值得注意的是if的条件中有个<em>i &lt; s.length()-1</em>，即为了防止越界我们作比较只比较到了字符串的倒数第二个字母，最后一个字母的值是直接相加的。因为最后一个字母无需与其后的字母相比较，因此此种方法可行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目简述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Symbol&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>两个字符串中含有几个相同字符的几种解法</title>
    <link href="http://www.duanmuxu.top/20190602/several-solutions-to-the-same-characters-in-two-strings.html"/>
    <id>http://www.duanmuxu.top/20190602/several-solutions-to-the-same-characters-in-two-strings.html</id>
    <published>2019-06-02T04:28:32.281Z</published>
    <updated>2020-02-18T17:31:14.236Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。<br><br><br>进入正题，题目如下：</p><blockquote><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br><br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.<br><br>Example 1:<br>Input: <br>J = “aA”,<br> S = “aAAbbbb”<br>Output: 3<br><br>Example 2:<br>Input: <br>J = “z”,<br> S = “ZZ”<br>Output: 0<br><br>Note:<br>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p></blockquote><h4 id="简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。"><a href="#简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。" class="headerlink" title="简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。"></a>简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。</h4><hr><blockquote><p><em>以下方法全是基于Java进行实现</em></p></blockquote><p>先放我的方法：</p><h3 id="方法一：将字符串转化成数组"><a href="#方法一：将字符串转化成数组" class="headerlink" title="方法一：将字符串转化成数组"></a>方法一：将字符串转化成数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        char[] Ja = J.toCharArray();</span><br><span class="line">        char[] Sa = S.toCharArray();</span><br><span class="line">        int r = 0;</span><br><span class="line">        for (int i = 0;i &lt; Ja.length ; i ++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; Sa.length; j++)&#123;</span><br><span class="line">                if(Ja[i] == Sa[j])</span><br><span class="line">                    r ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先将J和S字符串转化成两个数组</li><li>对J的数组进行遍历，再对S的数组进行遍历</li><li>如果J中的字母与S中的字母相等（区分大小写），累加器r就加一</li><li>最后输出r即可</li></ul><br>&nbsp;&nbsp;&nbsp;&nbsp;很简单的一道题，当时想着继续刷题吧，反正刷题网站的意义就在于刷刷刷。不过还好打开了这道题的评论区，让我看到了一个新的世界。评论里有着许许多多其他不同的解题方法。这才是刷题网站的意义，**给一道题以不同的解题思路，让每个人都能有多种不同的思考。**<br>&nbsp;&nbsp;&nbsp;&nbsp;以下是本道题评论区中给出的其他解题方法，亲测有效<h3 id="方法二：字符串直接进行比较"><a href="#方法二：字符串直接进行比较" class="headerlink" title="方法二：字符串直接进行比较"></a>方法二：字符串直接进行比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for (int i=0;i&lt;J.length();i++)&#123;</span><br><span class="line">            for (int j=0;j&lt;S.length();j++)&#123;</span><br><span class="line">                if (S.charAt(j) == J.charAt(i))&#123;</span><br><span class="line">                    count+=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其实和方法一差不大多，直接<strong>对字符串进行循环比较</strong>。最开始我也想用这方法，不过忘了charAt方法，不能确定字符串某个位置上的字母，于是换成了方法一。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;另一种直接比较方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        int count =0;</span><br><span class="line">        for (int i =0;i&lt;S.length();i++)&#123;</span><br><span class="line">            if (J.contains(String.valueOf(S.charAt(i))))&#123;</span><br><span class="line">                count++;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是循环比较，少了层for循环而已，不再赘述。</p><h3 id="方法三：正则表达式"><a href="#方法三：正则表达式" class="headerlink" title="方法三：正则表达式"></a>方法三：正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">    return S.replaceAll(&quot;[^&quot; + J + &quot;]&quot;, &quot;&quot;).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太狠了，这方法太狠了，一行解决事情。先介绍一下什么是正则表达式：</p><blockquote><p>正则表达式是对字符串（包括普通字符（例如，a到z之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。</p></blockquote><p>判断S字符串中有多少能被J字符串所替换的字符，将这些字符的长度输出就是答案。太狠了。<br><br><strong>不过这种方法时间会占用更多。</strong></p><h3 id="方法四：Hash-Set方法"><a href="#方法四：Hash-Set方法" class="headerlink" title="方法四：Hash Set方法"></a>方法四：Hash Set方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (char c : J.toCharArray()) </span><br><span class="line">            set.add(c);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (char c : S.toCharArray()) </span><br><span class="line">            if (set.contains(c)) </span><br><span class="line">                res++;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Hash Set就是用来提高查找效率的</strong>，将J字符串中的字母放在set中，判断S字符串中的字母知否包含在set中，是则累加器res加一，最后输出。<strong>这种方法运行效率也高。</strong></p><hr><p>问：为什么不是将S字符串的字符存入set中？<br><br>答：Hash Set不能存入相同的元素。以例子一为例，S字符串为：S = “aAAbbbb”，”A”有两个，”b”有四个，最后存入set后，set的长度为3，即存入元素为”a”,”A,”b”，因为字符串直接存入set里时，相同元素的HashCode是一样的，就会跳过重复的字符。这时与J字符串相比较，就只有”a”,”A”相匹配，输出结果为2，答案错误。</p><h3 id="方法五：ASCII值转换"><a href="#方法五：ASCII值转换" class="headerlink" title="方法五：ASCII值转换"></a>方法五：ASCII值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int[] arr = new int[&apos;z&apos; - &apos;A&apos; + 1];</span><br><span class="line">    for (char c : J.toCharArray()) </span><br><span class="line">        arr[c - &apos;A&apos;] = 1;</span><br><span class="line">    for (char c : S.toCharArray()) </span><br><span class="line">        count += arr[c - &apos;A&apos;];</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个arr数组，大小为A的ASCII的值（65）到z的ASCII的值（122）的范围，中间有些特殊字符也占用了空间，不过没关系，不碍事。然后将J字符串中的字符也转成ASCII值，并将以该字符的ASCII值（与A相减过后的值，不然会溢出）为角标的数组值设为1，再对S字符串进行循环，累加器count一直与角标为S串中的字符的ASCII值的arr数组的值相加，最后结果输出即可。也是一种转换思维。</p><h3 id="方法六：Hash-Map方法"><a href="#方法六：Hash-Map方法" class="headerlink" title="方法六：Hash Map方法"></a>方法六：Hash Map方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(char s : S.toCharArray())</span><br><span class="line">            map.put(s, map.getOrDefault(s, 0) + 1);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; J.length(); i++)</span><br><span class="line">            count += map.getOrDefault(J.charAt(i), 0);</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashSet方法更简洁，详情参见方法四。</p><hr><p>暂时放这一些方法，有看到新的再更新，继续学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。&lt;br&gt;&lt;br&gt;&lt;br&gt;进入正题，题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You’re given strings J represen
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://www.duanmuxu.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第k个结点</title>
    <link href="http://www.duanmuxu.top/20190602/the-last-kth-node-in-list.html"/>
    <id>http://www.duanmuxu.top/20190602/the-last-kth-node-in-list.html</id>
    <published>2019-06-02T04:28:32.279Z</published>
    <updated>2020-02-18T17:31:14.137Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p>链表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由链表结构就能知道由此基础建立的链表不能直接知道该链表的长度，需要通过node = node.next 一步一步遍历链表才能获取链表长度。</p><p>因此最先想到的方法就是<strong>先遍历一遍链表，获取链表长度，然后通过链表长度和k数值的差得出目标地址</strong>。实现方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        ListNode newHead = head, pre = head;</span><br><span class="line">        int count = 0; // 获取链表长度</span><br><span class="line">        while(pre != null)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count &lt; k) // 不存在倒数第k个链表</span><br><span class="line">            return null;</span><br><span class="line">        else&#123;</span><br><span class="line">            int num = count - k; // num为正数的目的地址，与倒数第k个链表值一致</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            return newHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了基础思路，下一步就是简化代码，用更简洁的表达将效果呈现出来。以下使用for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123; //5,&#123;1,2,3,4,5&#125;</span><br><span class="line">        ListNode p, q;</span><br><span class="line">        p = q = head;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; p != null; i++) &#123;</span><br><span class="line">            if (i &gt;= k) </span><br><span class="line">                q = q.next;</span><br><span class="line">            p = p.next; // p相当于上面的pre链表，用于测量链表长度</span><br><span class="line">        &#125;</span><br><span class="line">        return i &lt;= k ? null : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<strong>while一次遍历</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        ListNode pre=null,p=null;</span><br><span class="line">        //两个指针都指向头结点</span><br><span class="line">        p=head;</span><br><span class="line">        pre=head;</span><br><span class="line">        //记录k值</span><br><span class="line">        int a=k;</span><br><span class="line">        //记录节点的个数</span><br><span class="line">        int count=0;</span><br><span class="line">        //p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span><br><span class="line">        //当p指针跑到最后时，pre所指指针就是倒数第k个节点</span><br><span class="line">        while(p!=null)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">            count++;</span><br><span class="line">            if(k&lt;1)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果节点个数小于所求的倒数第k个节点，则返回空</span><br><span class="line">        if(count&lt;a) return null;</span><br><span class="line">        return pre;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实思路是一致的，就是<strong>通过得到链表长度，再得到n-k位置的链表值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链表结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>括号匹配消除</title>
    <link href="http://www.duanmuxu.top/20190602/bracket-matching-elimination.html"/>
    <id>http://www.duanmuxu.top/20190602/bracket-matching-elimination.html</id>
    <published>2019-06-02T04:28:32.278Z</published>
    <updated>2019-05-16T08:08:39.154Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><hr><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><blockquote><p>input : ()[]{}<br>output : true</p></blockquote><blockquote><p>input : ({[]})<br>output : true</p></blockquote><blockquote><p>input : ({)}<br>output : false</p></blockquote><hr><p>简单得说就是括号相匹配，同一个类型的括号连在一起。同一对括号可以嵌套在其他括号中，但只能一对括号都嵌套进去（如（{}）），不能只嵌套一边的括号（如（{）}）。</p><p>有看过<strong>二叉树的前中后序遍历进行加减乘除操作</strong>的应该一看到这一题就知道怎么做了。运算中有有括号的先算括号中的数的原则，那么就需要对运算中的括号进行识别与约束，与这道题一个道理。因此一看到这道题就应该想到可以用栈去求解。解法如下：</p><h4 id="使用栈-Stack-的解法"><a href="#使用栈-Stack-的解法" class="headerlink" title="使用栈(Stack)的解法"></a>使用栈(Stack)的解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (Character chara:s.toCharArray()) &#123;</span><br><span class="line">            if (chara == &apos;(&apos; || chara == &apos;[&apos; || chara == &apos;&#123;&apos;)</span><br><span class="line">                stack.push(chara);</span><br><span class="line">            else &#123;</span><br><span class="line">                if (stack.isEmpty())&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    Character charPop = stack.pop();</span><br><span class="line">                    if (charPop == &apos;(&apos; &amp;&amp; chara != &apos;)&apos; || charPop == &apos;[&apos; &amp;&amp; chara != &apos;]&apos; || charPop == &apos;&#123;&apos; &amp;&amp; chara != &apos;&#125;&apos;)&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (stack.isEmpty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：所给字符串第一个字符必为”(“,”[“,”{“中的一种，如果不是，那必然无法必配成功，return false。按字符串顺序识别字符将字符串push进栈中。当字符为”)”,”]”,”}”中的一种时，pop一个字符与上面三种字符向匹配，如果匹配成功，继续执行程序，匹配成功的括号自动消除。反之return false，说明这个“右”括号的前面一个括号也是“右”括号，即前面一个括号无法匹配成功。最后判断这个栈是否为空，如果全部都匹配消除完成，栈为空。</p><h4 id="优化后的使用栈的方法"><a href="#优化后的使用栈的方法" class="headerlink" title="优化后的使用栈的方法"></a>优化后的使用栈的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">for (char c : s.toCharArray()) &#123;</span><br><span class="line">if (c == &apos;(&apos;)</span><br><span class="line">stack.push(&apos;)&apos;);</span><br><span class="line">else if (c == &apos;&#123;&apos;)</span><br><span class="line">stack.push(&apos;&#125;&apos;);</span><br><span class="line">else if (c == &apos;[&apos;)</span><br><span class="line">stack.push(&apos;]&apos;);</span><br><span class="line">else if (stack.isEmpty() || stack.pop() != c)</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>太简洁了！！！</strong> 字符如果是“左”括号，那么栈中保存相应的“右”括号。字符如果是“右”括号，与pop出的值相比，如果不相等则说明前一个括号不是相对应的“左”括号，即无法匹配，return false。</p><p>除了上面用栈的方法外，还有一种<strong>值替换法</strong>，实现如下：</p><h4 id="目标值替换法"><a href="#目标值替换法" class="headerlink" title="目标值替换法"></a>目标值替换法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int length;</span><br><span class="line">    </span><br><span class="line">        do &#123;</span><br><span class="line">            length = s.length();</span><br><span class="line">            s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;);</span><br><span class="line">        &#125; while(length != s.length());</span><br><span class="line">    </span><br><span class="line">        return s.length() == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：暴力替换目标值，符合一整对括号的值直接替换成空值，以替换前的字符串长度和替换后的字符串长度作比较条件，建立循环。最后判断字符串长度是否为零，即整对括号是否被替换完全。</p><p>还有Map的方法：</p><h4 id="使用Key-Value匹配进行求解"><a href="#使用Key-Value匹配进行求解" class="headerlink" title="使用Key-Value匹配进行求解"></a>使用Key-Value匹配进行求解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    Map&lt;Character,Character&gt; pairs = new HashMap&lt;Character,Character&gt;();</span><br><span class="line">    pairs.put(&apos;(&apos;, &apos;)&apos;);</span><br><span class="line">    pairs.put(&apos;&#123;&apos;, &apos;&#125;&apos;);</span><br><span class="line">    pairs.put(&apos;[&apos;, &apos;]&apos;);</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">    for (char c:chars) &#123;</span><br><span class="line">    if (pairs.containsKey(c)) &#123;</span><br><span class="line">    stack.push(pairs.get(c));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    if (stack.isEmpty() || c != stack.pop()) </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：将“左”括号作为key，“右”括号作为值放在Map中，其他思路与优化后的使用栈的方法一致。</p><hr><p>无论是用栈还是数组还是Hash Map，都只是一种工具，最主要的是思路，有了思路就有了目标，各种存储方法只是帮助达到目标的工具罢了。（当然，有些工具是独轮车，有些工具是飞机哈哈哈哈哈哈哈）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.duanmuxu.top/20190602/reverse-linked-list.html"/>
    <id>http://www.duanmuxu.top/20190602/reverse-linked-list.html</id>
    <published>2019-06-02T04:28:32.276Z</published>
    <updated>2020-02-18T17:31:14.139Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p>最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，<strong>暴力</strong>反转链表。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre, result = new ListNode(0);</span><br><span class="line">        pre = result;</span><br><span class="line"></span><br><span class="line">        if(head == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(cur != null)&#123; //循环读取链表数值，存在array链表中</span><br><span class="line">            array.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = array.size() - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            pre = new ListNode(array.get(i));</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法很美好，现实很骨感。运行时报出如下错误：</p><blockquote><p>Exception in thread “main” java.lang.NullPointerException</p></blockquote><p>咋肥事，还会有空指针报错？马上Debug，发现一个漏洞。</p><p>最开始定义了ListNode pre, result两个新链表，pre用于循环，每次增加新的next节点，因为每次pre.next = new ListNode(num)时，pre.val会赋予新的值，不能成为一条完整的逆序链表，因此定义了result链表来与pre每次添加的值相等，因为result = pre，因此两个<strong>内存地址相等</strong>，也就是result每次会以链表形式添加pre所添加的新元素，从而达到逆序操作。</p><p>不过问题就出在pre = new ListNode(array.get(i));这上，<strong>每次new一个值时，pre的内存地址就改变一次</strong>，但是result的内存地址不会变，因此result不会与pre产生联系，也就是最后return result的时候，<strong>result的值在最开始定义result时就已经确定了</strong>，与后续pre的操作无关，因此无法得到反转链表的目的。</p><p>所以上述代码是些辣鸡。那就换个思路吧，直接从<strong>链表本身</strong>入手。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        if(head==null)</span><br><span class="line">            return null;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啥意思呢，pre表示所给链表的前一个节点，next表示所给链表的下一个节点。代码解释如下:</p><ol><li>next = head.next 表示next保存head的下一个节点，<strong>保证head.next不会丢失</strong>；</li><li>head.next = pre 表示head指向了pre,也就是head<strong>从后指向前</strong>；</li><li>pre = head 表示pre现在已经是在next前面的数值中，由后指向前的一个链表；</li><li>head = next 表示head找回原先的head的下一节点，也就是第一步中被next保存的节点；</li><li>继续以上操作，直至head遍历完成，此时pre也反转完成。</li></ol><p>举个栗子最直观：</p><p><strong>输入链表 1-&gt;2-&gt;3-&gt;4-&gt;5</strong></p><ol><li>next = head.next = 2-&gt;3-&gt;4-&gt;5</li><li>head.next = pre =null</li><li>pre = head = 1</li><li>head = next = 2-&gt;3-&gt;4-&gt;5</li><li>—新一轮循环—</li><li>next = head.next = 3-&gt;4-&gt;5</li><li>head.next = pre = 1  （<strong>此时head.val = 2，因此head 表示2-&gt;1</strong>）</li><li>pre = head = 2-&gt;1 （<strong>达到反转的目的</strong>）</li><li>head = next = 3-&gt;4-&gt;5</li><li>—新一轮循环—</li><li>……</li><li>head = null</li><li>pre = 5-&gt;4-&gt;3-&gt;2-&gt;1</li></ol><p><strong>输出链表 5-&gt;4-&gt;3-&gt;2-&gt;1</strong></p><p>任务完成，值得品味。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，&lt;strong&gt;暴力&lt;/strong&gt;反转链表。实现如下：&lt;/p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>对所有员工的薪水按照salary进行按照1-N的排名</title>
    <link href="http://www.duanmuxu.top/20190602/the-salary-of-all-employees-is-ranked-according-to-1n.html"/>
    <id>http://www.duanmuxu.top/20190602/the-salary-of-all-employees-is-ranked-according-to-1n.html</id>
    <published>2019-06-02T04:28:32.273Z</published>
    <updated>2020-02-18T17:31:14.227Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列</p></blockquote><p>建表语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">`emp_no` int(11) NOT NULL,</span><br><span class="line">`salary` int(11) NOT NULL,</span><br><span class="line">`from_date` date NOT NULL,</span><br><span class="line">`to_date` date NOT NULL,</span><br><span class="line">PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure><p>输出描述：</p><table><thead><tr><th>emp_no</th><th>salary</th><th>rank</th></tr></thead><tbody><tr><td>10005</td><td>94692</td><td>1</td></tr><tr><td>10002</td><td>94409</td><td>2</td></tr><tr><td>10010</td><td>94409</td><td>2</td></tr><tr><td>10001</td><td>88958</td><td>3</td></tr><tr><td>10007</td><td>88958</td><td>3</td></tr><tr><td>10004</td><td>74057</td><td>4</td></tr></tbody></table><p>不看最后一个rank排名，那么这道题特别简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s.emp_no, s.salary</span><br><span class="line">from salaries s</span><br><span class="line">where s.to_date = &apos;9999-01-01&apos;</span><br><span class="line">order by s.salary desc, s.emp_no asc</span><br></pre></td></tr></table></figure><p>但是题目偏偏加了一个rank工资排名。那么怎样才能获得这个排名呢？</p><p>在Java中我们可以直接使用循环来给目标值加排名，SQL查询语句中看来行不通。仅仅使用一张表似乎达不到目的，那就使用两张表吧。</p><p>既然不能使用循环，那么可以通过什么方法来表示排名，或者说是<strong>表示在自己的前面还有多少人（包括自己）</strong>。</p><p>很明显了，我们可以通过两张表中salary的大小不同来获取在自己前面的人的个数，即<strong>s1.salary &lt;= s2.salary</strong>。举个栗子：<br><br>有三个salary（6000，5000，4000， 4000），输出为s1.salary，那么当s1.salary = 6000时，s1.salary &lt;= s2.salary 的值为6000，也就是一个，当s1.salary = 5000时，s1.salary &lt;= s2.salary 的值为6000和5000两个。但是当s1.salary = 4000时，s1.salary &lt;= s2.salary 的值就为（6000，5000，4000， 4000）四个，且4000是重复的，因此我们使用<strong>count(distinct s2.salary) rank</strong> 来去重，并计算个数，即排名，以此类推，<strong>输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary就是s1.salary的排名</strong></p><p>当然不要忘了<strong>group by s1.emp_no</strong> ，用来将员工编号分组，计算count()</p><p>最后结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s1.emp_no, s1.salary, count(distinct s2.salary) rank</span><br><span class="line">from salaries s1, salaries s2</span><br><span class="line">where s1.salary &lt;= s2.salary and s1.to_date = &apos;9999-01-01&apos; and s2.to_date = &apos;9999-01-01&apos;</span><br><span class="line">group by s1.emp_no</span><br><span class="line">order by rank</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建表语句：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>单向链表小记</title>
    <link href="http://www.duanmuxu.top/20190602/oneway-linked-list.html"/>
    <id>http://www.duanmuxu.top/20190602/oneway-linked-list.html</id>
    <published>2019-06-02T04:28:32.272Z</published>
    <updated>2020-02-18T17:31:14.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。　　</p><h3 id="什么是单向链表？"><a href="#什么是单向链表？" class="headerlink" title="什么是单向链表？"></a>什么是单向链表？</h3><p>单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。（其实就是上一篇中提到的ListNode）</p><p>单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p><h3 id="单向链表的具体实现"><a href="#单向链表的具体实现" class="headerlink" title="单向链表的具体实现"></a>单向链表的具体实现</h3><p>这边放上练习用的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package LinkedList;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">private int size;</span><br><span class="line">private Node head;</span><br><span class="line"></span><br><span class="line">public SingleLinkedList() &#123;</span><br><span class="line">size = 0;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class Node&#123;</span><br><span class="line">private Object data;//每个节点的数据</span><br><span class="line">private Node next; //每个节点指向下一个节点的连接</span><br><span class="line"></span><br><span class="line">public Node(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在链表头添加元素</span><br><span class="line">public Object addhead(Object obj) &#123;</span><br><span class="line">Node newHead = new Node(obj);</span><br><span class="line">if(size == 0)</span><br><span class="line">head = newHead;</span><br><span class="line">else &#123;</span><br><span class="line">newHead.next = head;</span><br><span class="line">head = newHead;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在链表头删除元素</span><br><span class="line">public Object deleteHead() &#123;</span><br><span class="line">Object obj = head.data;</span><br><span class="line">head = head.next;</span><br><span class="line">size--;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找指定元素，找到了返回节点Node，找不到返回null</span><br><span class="line">public Node find(Object obj) &#123;</span><br><span class="line">Node current = head;</span><br><span class="line">int tempSize = size;</span><br><span class="line">while(tempSize &gt; 0)&#123;</span><br><span class="line"> if(obj.equals(current.data))&#123;</span><br><span class="line"> return current;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> current = current.next;</span><br><span class="line">     &#125;</span><br><span class="line">    tempSize--;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     //删除指定的元素，删除成功返回true</span><br><span class="line">     public boolean delete(Object value)&#123;</span><br><span class="line">         if(size == 0)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">         Node current = head;</span><br><span class="line">         Node previous = head;</span><br><span class="line">         while(current.data != value)&#123;</span><br><span class="line">         if(current.next == null)&#123;</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 previous = current;</span><br><span class="line">                 current = current.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //如果删除的节点是第一个节点</span><br><span class="line">         if(current == head)&#123;</span><br><span class="line">             head = current.next;</span><br><span class="line">             size--;</span><br><span class="line">         &#125;else&#123;//删除的节点不是第一个节点</span><br><span class="line">             previous.next = current.next;</span><br><span class="line">             size--;</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    //判断链表是否为空</span><br><span class="line">     public boolean isEmpty() &#123;</span><br><span class="line">     return (size == 0);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //在链表尾部添加元素</span><br><span class="line">     public Object addTail(Object obj) &#123;</span><br><span class="line">     Node newTail = new Node(obj);</span><br><span class="line">     Node current = head;</span><br><span class="line">     int temSize = size;</span><br><span class="line">     while (temSize &gt; 0) &#123;</span><br><span class="line">if (current.next == null) &#123;</span><br><span class="line">//需要先增加链表的容量，才能进行添加</span><br><span class="line">size++;</span><br><span class="line">current.next = newTail;</span><br><span class="line">newTail.next = null;</span><br><span class="line"></span><br><span class="line">return current;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">temSize--;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">     return obj;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //显示节点信息</span><br><span class="line">     public void display() &#123;</span><br><span class="line">     if (size &gt; 0) &#123;</span><br><span class="line">Node node = head;</span><br><span class="line">int tempSize = size;</span><br><span class="line">if (tempSize == 1) &#123;</span><br><span class="line">System.out.print(&quot;[&quot; + node.data + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">while (tempSize &gt; 0) &#123;</span><br><span class="line">if (node.equals(head)) &#123;</span><br><span class="line">System.out.print(&quot;[&quot; + node.data + &quot;-&gt;&quot;);</span><br><span class="line">&#125;else if (node.next == null) &#123;</span><br><span class="line">System.out.print(node.data+&quot;]&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.print(node.data+&quot;-&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node = node.next;</span><br><span class="line">tempSize--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;[]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">SingleLinkedList sLinkedList  = new SingleLinkedList();</span><br><span class="line">sLinkedList.addhead(&quot;A&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;B&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;C&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;D&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.addTail(&quot;O&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.deleteHead();</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.delete(&quot;B&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[D-&gt;C-&gt;B-&gt;A]</span><br><span class="line">[D-&gt;C-&gt;B-&gt;A-&gt;O]</span><br><span class="line">[C-&gt;B-&gt;A-&gt;O]</span><br><span class="line">[C-&gt;A-&gt;O]</span><br></pre></td></tr></table></figure><p>这边注意一个地方，addTail()是往链表的末尾添加一个元素，在进行判断current.next == null 后，<strong>要先将整体链表的size + 1</strong>，不要将size + 1放在循环外进行,才能够使current.next = newTail,否则将无法添加成功，因为容量不够。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是链表？&quot;&gt;&lt;a href=&quot;#什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;什么是链表？&quot;&gt;&lt;/a&gt;什么是链表？&lt;/h3&gt;&lt;p&gt;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer 替换字符串中的空格</title>
    <link href="http://www.duanmuxu.top/20190602/stringbuffer-replaces-spaces-in-a-string.html"/>
    <id>http://www.duanmuxu.top/20190602/stringbuffer-replaces-spaces-in-a-string.html</id>
    <published>2019-06-02T04:28:32.269Z</published>
    <updated>2020-02-18T17:31:14.461Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将一个字符串中的空格替换成 &quot;%20&quot;。</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="将String-Buffer转换为String类型，再进行操作"><a href="#将String-Buffer转换为String类型，再进行操作" class="headerlink" title="将String Buffer转换为String类型，再进行操作"></a>将String Buffer转换为String类型，再进行操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    String str1 = str.toString();</span><br><span class="line">str1 = str1.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">    return str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别简单，不过好像不是出题者的原意</p><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><h4 id="先填充字符串再进行遍历替换"><a href="#先填充字符串再进行遍历替换" class="headerlink" title="先填充字符串再进行遍历替换"></a>先填充字符串再进行遍历替换</h4><blockquote><p>解题思路：<br>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。<br>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。<br>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    int P1 = str.length() - 1;</span><br><span class="line">    for (int i = 0; i &lt;= P1; i++)</span><br><span class="line">        if (str.charAt(i) == &apos; &apos;)</span><br><span class="line">            str.append(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line">    int P2 = str.length() - 1;</span><br><span class="line">    while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        char c = str.charAt(P1--);</span><br><span class="line">        if (c == &apos; &apos;) &#123;</span><br><span class="line">            str.setCharAt(P2--, &apos;0&apos;);</span><br><span class="line">            str.setCharAt(P2--, &apos;2&apos;);</span><br><span class="line">            str.setCharAt(P2--, &apos;%&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://www.duanmuxu.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Single Number 找出数组中的单一数字</title>
    <link href="http://www.duanmuxu.top/20190602/single-number-find-in-an-array.html"/>
    <id>http://www.duanmuxu.top/20190602/single-number-find-in-an-array.html</id>
    <published>2019-06-02T04:28:32.252Z</published>
    <updated>2020-02-18T17:31:14.537Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.<br><br>给定一个非空的整数数组，除了一个元素外，每个元素都会出现两次。找出那个单一的整数。</p></blockquote><p>最常规的思路就是进行循环，统计出现的数字，只出现一次的就是我们要的答案了</p><h4 id="for循环统计数字出现次数"><a href="#for循环统计数字出现次数" class="headerlink" title="for循环统计数字出现次数"></a>for循环统计数字出现次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int[] result = new int[nums.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i &lt; nums.length; i++)&#123;</span><br><span class="line">            for (int j = 0;j &lt;= count;j++)&#123;</span><br><span class="line">                if (j == count)&#123;</span><br><span class="line">                    result[j] = -1;</span><br><span class="line">                    count++;</span><br><span class="line">                    j = count +1;</span><br><span class="line">                &#125;else if (nums[i] == nums[j])&#123;</span><br><span class="line">                    result[j]++;</span><br><span class="line">                    count++;</span><br><span class="line">                    j = count + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k = 0; k &lt; result.length ;k++)&#123;</span><br><span class="line">            if (result[k] == -1)</span><br><span class="line">                return nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个result数组用来存放统计的次数，初始值为-1，进行双重循环，以后每找到一个与nums数组中相同的数字，就在result数组中+1，即值变为0。最后根据result中值为-1（即在nums数组中没找到相同数值的数字）的数字就是我们要找的数字。</p><p>这种方法逻辑很顺，但是<strong>时间复杂度为O(n^2)</strong>，运行时间会消费很多。<br>那么要降低时间复杂度，就得<strong>减少一层循环</strong>。怎么才能实现呢？既要实现统计次数，又要遍历数组，有应用过<strong>Map Reducer</strong>方法的同学应该很容易就能想到<strong>word count</strong>程序好像就是这么一个道理，因此我们可以使用Map进行存值判断。</p><h4 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        int resultNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            if(result.containsKey(num))&#123;</span><br><span class="line">                result.remove(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.put(num, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int res : result.keySet()) &#123;</span><br><span class="line">            resultNum = res;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为nums数组中的重复数字只有两个，因此判断数字是否已经存在于Map中，若已经存在，则remove该数字，此时Map和nums数组中都已不存在该数字，若Map中不存在该数字，则put该数字。最后Map只剩下单一的数字，即我们想要的结果。</p><p>Map中需要插入<strong>key-value</strong>两个值，但是value的值对我们没有什么帮助，因此可以使用HashSet进一步优化。</p><h4 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if(!result.add(num))</span><br><span class="line">                result.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; it = result.iterator();</span><br><span class="line">        return it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断nums中的数字是否已经存在与HashSet中，若已经存在，则remove，若不存在，则直接add。这步与Map类似，不过只需要插入一个nums数组中的值就够了。</p><p>上面都是常规的一些存储方法，可没想到还有一个<strong>更加简洁帅气</strong>的方法。就是使用异或 ^ 的方法。</p><h4 id="XOR异或方法"><a href="#XOR异或方法" class="headerlink" title="XOR异或方法"></a>XOR异或方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            result = result ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么意思呢，^ 异或满足下面的转化：</p><table><thead><tr><th>a</th><th>b</th><th>result</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>所以两个数字进行 ^ 运算时，先将数字转化为二进制，再进行 ^ 操作，<strong>当两个数字相同时，则对应的二进制数的位数也都相同，因此运算结果为0</strong>。当<strong>0与任意数字进行异或运算时，运算结果为该任意数字</strong>，因此最终的结果就是nums数组中出现的单一数字。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a non-empty array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;&lt;br&gt;给
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级真题—福尔摩斯的约会</title>
    <link href="http://www.duanmuxu.top/20190602/pat-grade-b-zhentisherlock-holmes-dating.html"/>
    <id>http://www.duanmuxu.top/20190602/pat-grade-b-zhentisherlock-holmes-dating.html</id>
    <published>2019-06-02T04:28:32.251Z</published>
    <updated>2020-02-18T17:31:14.247Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p></blockquote><p>输入描述:</p><blockquote><p>输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p></blockquote><p>输出描述:</p><blockquote><p>在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p></blockquote><p>输入例子:</p><blockquote><p>3485djDkxh4hhGE<br>2984akDfkkkkggEdsb<br>s&amp;hgsfdk<br>d&amp;Hyscvnm</p></blockquote><p>输出例子:</p><blockquote><p>THU 14:04</p></blockquote><hr><p>这边注意几点，如果前两个输入中出现<strong>连续相同的字母</strong>怎么办？如果<strong>代表小时的相同字母/数字出现得比代表日期的相同字母要早</strong>怎么办？如果后两个输入中有多组相同的字母怎么办？输出中碰到个位数的小时/分钟时前面不带”0”（<strong>输出不规范</strong>）怎么办？</p><p>这些都不是问题，下面贴出通过的代码，并且有详细注释。可能会显得有些冗长，但是看起来一目了然，毫无难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Holmes &#123;</span><br><span class="line">    //定义日期</span><br><span class="line">    private static char[] day = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">    //定义当天的小时</span><br><span class="line">    private static char[] hour =&#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        //循环读取四个输入</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            //获取四个字符串</span><br><span class="line">            String str1 = scanner.nextLine();</span><br><span class="line">            String str2 = scanner.nextLine();</span><br><span class="line">            String str3 = scanner.nextLine();</span><br><span class="line">            String str4 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            //判断前两个字符串哪一个最短</span><br><span class="line">            int daytime = shortest(str1, str2);</span><br><span class="line">            boolean isDay = true;//判断相同的字母是否是代表“天”</span><br><span class="line">            String result = &quot;&quot;;//结果字符串</span><br><span class="line">            int sum = 0; //前两个字符串中相同字母/数字的个数</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; daytime; i++)&#123;</span><br><span class="line">                if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInDay(str1.toCharArray()[i]) &amp;&amp; isDay)&#123;</span><br><span class="line">                    result += getDay(str1.toCharArray()[i]);</span><br><span class="line">                    /**</span><br><span class="line">                     * isDay有两个作用：</span><br><span class="line">                     * 一是防止下一次有字母出现时将字母当作成“天”的字母；</span><br><span class="line">                     * 二是供else if 中做判断，防止识别时间在识别周几之前</span><br><span class="line">                     */</span><br><span class="line">                    isDay = false;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;else if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInHour(str1.toCharArray()[i]) &amp;&amp; !isDay )&#123;</span><br><span class="line">                    //输出规范化，防止出现输出为 “THU 2:12”的情况</span><br><span class="line">                    if (getHour(str1.toCharArray()[i]) &lt; 10)&#123;</span><br><span class="line">                        result += &quot; 0&quot;+ getHour(str1.toCharArray()[i]);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        result += &quot; &quot;+ getHour(str1.toCharArray()[i]);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //防止已经识别周几和小时之后还有相同又符合判断条件的字母出现</span><br><span class="line">                if (sum == 2)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取str3，str4中最小的字符串长度</span><br><span class="line">            int minute = shortest(str3, str4);</span><br><span class="line">            for (int i = 0; i &lt; minute ; i++)&#123;</span><br><span class="line">                if (str3.toCharArray()[i] == str4.toCharArray()[i] &amp;&amp; isEnglishChar(str3.toCharArray()[i]))&#123;</span><br><span class="line">                    //输出规范化，与上同</span><br><span class="line">                    if (i &lt; 10 ) &#123;</span><br><span class="line">                        result += &quot;:0&quot; + i;</span><br><span class="line">                        break; //有相同的字母直接退出for循环</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        result += &quot;:&quot; + i;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回两个字符串长度最小的字符串长度</span><br><span class="line">     * @param str1</span><br><span class="line">     * @param str2</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int shortest(String str1, String str2)&#123;</span><br><span class="line">        return str1.length() &lt; str2.length() ? str1.length() : str2.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断输入字符是否存在与day的数组中</span><br><span class="line">     * @param character</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isInDay(Character character)&#123;</span><br><span class="line">        for (int i = 0; i &lt; day.length; i++)&#123;</span><br><span class="line">            if (character == day[i])</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断输入字符是否存在与hour数组中</span><br><span class="line">     * @param character</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isInHour(Character character)&#123;</span><br><span class="line">        for (int i = 0; i &lt; hour.length; i++)&#123;</span><br><span class="line">            if (character == hour[i])</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据输入字符获取星期几的简写</span><br><span class="line">     * @param dayChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getDay(Character dayChar)&#123;</span><br><span class="line">        switch (dayChar)&#123;</span><br><span class="line">            case &apos;A&apos;:</span><br><span class="line">                return &quot;MON&quot;;</span><br><span class="line">            case &apos;B&apos;:</span><br><span class="line">                return &quot;TUE&quot;;</span><br><span class="line">            case &apos;C&apos;:</span><br><span class="line">                return &quot;WED&quot;;</span><br><span class="line">            case &apos;D&apos;:</span><br><span class="line">                return &quot;THU&quot;;</span><br><span class="line">            case &apos;E&apos;:</span><br><span class="line">                return &quot;FRI&quot;;</span><br><span class="line">            case &apos;F&apos;:</span><br><span class="line">                return &quot;SAT&quot;;</span><br><span class="line">            case &apos;G&apos;:</span><br><span class="line">                return &quot;SUN&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Not Found This Day&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据输入字符获取小时时间</span><br><span class="line">     * @param hourChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int getHour(Character hourChar)&#123;</span><br><span class="line">        for (int i = 0; i &lt; hour.length; i++)&#123;</span><br><span class="line">            if (hourChar == hour[i])</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断输入字符是否是一个英文字母（包含大小写）</span><br><span class="line">     * @param engChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isEnglishChar(Character engChar)&#123;</span><br><span class="line">        if (engChar &gt;= &apos;a&apos; &amp;&amp; engChar &lt;= &apos;z&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        else if(engChar &gt;= &apos;A&apos; &amp;&amp; engChar &lt;= &apos;Z&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="http://www.duanmuxu.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>往微信图文中插入外链视频的方法（包含几种失败方法）</title>
    <link href="http://www.duanmuxu.top/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.html"/>
    <id>http://www.duanmuxu.top/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.html</id>
    <published>2019-06-02T04:28:32.249Z</published>
    <updated>2020-02-29T11:17:24.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种不同方法"><a href="#几种不同方法" class="headerlink" title="几种不同方法"></a>几种不同方法</h1><h2 id="最常见方法"><a href="#最常见方法" class="headerlink" title="最常见方法"></a>最常见方法</h2><p>我们平时转发图文时，往往转发的图文中会带有视频，一般的解决方法就是在浏览器中打开<br>腾讯视频，找到原图文中的原视频，然后进行分享复制链接，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/1.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>再把链接复制粘贴到后台视频链接的地方就会有视频显示出来</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/2.jpg" alt="在这里插入图片描述"></p><p>再点击确定就可以在图文中看见插入的视频了。<br>但是！！前几天在进行转发一篇图文中的视频时我发现了一个新的问题，有些视频点击分享时无法复制视频地址链接，怎么整都不行！<br>所以我先试了以下方法，但都<strong>无法实现</strong>！为了不让大家走弯路，我先把我用过的<strong>行不通</strong>的方法列出来。</p><h2 id="失败方法一："><a href="#失败方法一：" class="headerlink" title="失败方法一："></a>失败方法一：</h2><p>下载视频上传后台</p><p>该视频只有 57 秒，不足 <strong>20M</strong>（微信公众号后台要求上传的视频大小要小于20M），那我就下载腾讯视频客户端，再下载原视频，然后把视频上传到后台就行了呗，但是问题又出现了，腾讯视频的下载格式是<strong>qlv</strong>，公众号后台<strong>不支持该格式</strong>的视频。</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/3.jpg" alt="在这里插入图片描述"></p><p>不过问题不大，将原视频进行格式转换成 <strong>MP4</strong>，再上传到后台，还是美滋滋，但是问题又来了，格式工厂无法支持该格式，无法进行转换，那就从网上找吧，可是市面上的格式转换器（对我使用过的而言）转换后的 MP4 格式上传到后台后，公众号后台却无法解码，</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/4.jpg" alt="公众号后台转码失败"></p><p>因此视频还是无法成功上传，这条路，卒。</p><h2 id="利用windows-系统命令行对视频缓存的合成及转换"><a href="#利用windows-系统命令行对视频缓存的合成及转换" class="headerlink" title="利用windows 系统命令行对视频缓存的合成及转换"></a>利用windows 系统命令行对视频缓存的合成及转换</h2><p>我们每次在浏览器或是客户端进行视频查看时，系统会<strong>自动生成缓存</strong>保存在电脑中，下次查看视频时就会方便很多，因此我们先找到电脑本地视频缓存区，</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/5.jpg" alt="本地缓存目录"></p><p>腾讯视频将一整段完整的视频进行分段缓存，还都是<strong>ts</strong>的文件，这个格式第一次见，问题不<br>大，打开 <strong>cmd 命令行</strong>，使用 <strong>copy/b</strong> 命令进行分段视频的合成和转换，</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/6.jpg" alt="利用命令行进行合成"><br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/7.jpg" alt="合成并转换后的视频文件" title>                </div>                <div class="image-caption">合成并转换后的视频文件</div>            </figure></p><p>视频转换成功，美滋滋。可是问题又来了，点击打开只能在腾讯视频进行播放，其他视频软件出现解码错误（又是解码错误！！）</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/8.jpg" alt="迅雷影音播放画面"></p><p>而且腾讯视频里只有音频，没有视频图像，这条路，卒。</p><h2 id="检查网页元素进行视频捕捉和保存"><a href="#检查网页元素进行视频捕捉和保存" class="headerlink" title="检查网页元素进行视频捕捉和保存"></a>检查网页元素进行视频捕捉和保存</h2><p>知乎上的一个方法，利用浏览器播放视频，检查网页元素进行视频捕捉和保存 <a href="https://www.zhihu.com/question/23805794/answer/55527454" target="_blank" rel="noopener">如何下载网页上的视频？ - 习惯秋落的回答 - 知乎</a> 有兴趣的可以根据里面详细的介绍试一试</p><p><img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/9.jpg" alt="在这里插入图片描述"></p><p>当我开开心心地进行视频保存时，却发现保存的视频格式是<strong>ts</strong> 文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/10.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>又是<strong>ts</strong>文件！！！这条路，卒。</p><h2 id="手机端UC浏览器进行视频保存"><a href="#手机端UC浏览器进行视频保存" class="headerlink" title="手机端UC浏览器进行视频保存"></a>手机端UC浏览器进行视频保存</h2><p>平时我们用<strong>手机 UC 浏览器</strong>进行看视频时，右上角会有一个下载视频的图标，我们可以进行视频下载，一般来说是 <strong>MP4</strong> 格式，但是前两天我在试验的时候那个图标不见了，我也就没有去深究。</p><h2 id="成功方法"><a href="#成功方法" class="headerlink" title="成功方法"></a>成功方法</h2><h3 id="查找浏览器视频元素"><a href="#查找浏览器视频元素" class="headerlink" title="查找浏览器视频元素"></a>查找浏览器视频元素</h3><p>既然团中央学校部的图文中可以播放该视频，那这篇<strong>图文的信息中肯定有该视频的信息</strong>，所以重点来啦，下面都是要记笔记的地方！<br>首先在浏览器中打开我们要转发的图文，我用的是谷歌浏览器，也建议大家使用。</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/11.jpg" alt="浏览器打开图文" title>                </div>                <div class="image-caption">浏览器打开图文</div>            </figure></p><p><br>然后打开网页检查元素，一种方法是<strong>右击鼠标，选择检查</strong>即可，另一种方法是 <strong>shift+ctrl+I快捷键</strong>进入检查</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/12.jpg" alt="进入检查页面" title>                </div>                <div class="image-caption">进入检查页面</div>            </figure></p><p><br>点击右边框框中的 <strong>element</strong> 元素 </p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/13.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>键入 <strong>ctrl+F</strong> 进行元素检索</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/14.jpg" alt="进行检索" title>                </div>                <div class="image-caption">进行检索</div>            </figure></p><p><br>搜索 <strong>v.qq.com</strong>,因为这个是所有腾讯视频链接中所包含的特定元素</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/15.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>此时网页自动找到页面中的视频元素（左半边），以及该视频的链接地址（右半边中的<strong>黄色部分</strong>所在区域），然后呢，我们有了该视频链接的总地址，此时我们复制 <strong>src=…后的部分，从 v.qq.com 一直到 false</strong></p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/16.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>然后将我们复制的这段链接再粘贴到后台</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/method-for-inserting-outlink-video-into-wechat-graphic-including-several-failure-methods.htm/17.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>以上就是从<strong>原图文找原视频链接地址</strong>的方法，十分简便，为什么我之前会试那么多复杂的方法！！</p><p><strong>当然如果腾讯视频可以直接复制视频地址链接，那就不要整这些花里胡哨的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几种不同方法&quot;&gt;&lt;a href=&quot;#几种不同方法&quot; class=&quot;headerlink&quot; title=&quot;几种不同方法&quot;&gt;&lt;/a&gt;几种不同方法&lt;/h1&gt;&lt;h2 id=&quot;最常见方法&quot;&gt;&lt;a href=&quot;#最常见方法&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="新媒体运营" scheme="http://www.duanmuxu.top/categories/%E6%96%B0%E5%AA%92%E4%BD%93%E8%BF%90%E8%90%A5/"/>
    
    
      <category term="新媒体" scheme="http://www.duanmuxu.top/tags/%E6%96%B0%E5%AA%92%E4%BD%93/"/>
    
      <category term="视频" scheme="http://www.duanmuxu.top/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>使用MultipleOutputs方法将mapreduce分组输出</title>
    <link href="http://www.duanmuxu.top/20190602/use-the-multipleoutputs-method-to-output-mapreduce-in-groups.html"/>
    <id>http://www.duanmuxu.top/20190602/use-the-multipleoutputs-method-to-output-mapreduce-in-groups.html</id>
    <published>2019-06-02T04:28:32.247Z</published>
    <updated>2020-02-18T17:31:14.311Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-00000文件），那么我们如果需要将这一个输出文件分为多个输出文件该怎么办呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190513215448825.png" alt="一个输出" title>                </div>                <div class="image-caption">一个输出</div>            </figure><p>这里就用到了MR框架中的MultipleOutputs函数（MultipleOutputs是2.0之后的新API，是对老版本中MultipleOutputs与MultipleOutputFormat的一个整合）。<br>先来看段完整代码熟悉一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class dateFormat &#123;</span><br><span class="line">    static class MyMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value,Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span><br><span class="line">            String time = simpleDateFormat.format(new Date());</span><br><span class="line">            String line = value.toString().trim();</span><br><span class="line">            for (int i =0; i&lt; line.length(); i++)&#123;</span><br><span class="line">                char newChar = line.charAt(i);</span><br><span class="line">                context.write(new Text(time), new Text(String.valueOf(newChar)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyReducer extends Reducer&lt;Text,Text,Text,Text&gt;&#123;</span><br><span class="line">        private MultipleOutputs&lt;Text, Text&gt; multipleOutputs;</span><br><span class="line"></span><br><span class="line">        protected void setup(Context context)&#123;</span><br><span class="line">            multipleOutputs = new MultipleOutputs&lt;Text, Text&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values,Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            for (Text value : values) &#123;</span><br><span class="line">                multipleOutputs.write((Text) null, value, key.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        protected void cleanup(Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">            multipleOutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(dateFormat.class);</span><br><span class="line"></span><br><span class="line">        job.setJobName(&quot;MultipleOutputTest&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(NullWritable.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line">//      MultipleOutputs.addNamedOutput(job, TextOutputFormat.class, NullWritable.class, Text.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, new Path(args[0]));</span><br><span class="line">        Path outPath = new Path(args[1]);</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">        if(fs.exists(outPath)) &#123;</span><br><span class="line">            fs.delete(outPath, true);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outPath);</span><br><span class="line"></span><br><span class="line">        job.waitForCompletion(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multipleOutputs.write的输出规范如下：<br><strong>multipleOutputs.write((namedOutput,) key, value, baseOutputPath)</strong><br>这里需要注意的一点在是map中的输出值会作为reduce中输出文件的文件命名（<em>map.key</em>-r-00000），即<strong>baseOutputPath</strong>的值确定了分组输出文件的命名规范。</p><p><strong>namedOutput</strong>为可选项，为当前输出Job的名称，如果有多于一个multipleOutputs.write时，需指定namedOutput名称，并在Driver里添加 <strong>MultipleOutputs.addNamedOutput(job,</strong> <strong>“namedOutput”</strong> , <strong>TextOutputFormat.class, NullWritable.class, Text.class)</strong>;作为作业的入口。</p><p>上述的代码段是我根据获取系统时间作为reducer的输入key值，命名时也根据map的执行时间进行命名，输出到同一文件夹之下，具体结果如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190513220838373.png" alt="分组输出到同一文件下" title>                </div>                <div class="image-caption">分组输出到同一文件下</div>            </figure><p>如果需要将这些文件分别输出到不同的文件夹下，那么只需要将 multipleOutputs.write((Text) null, value, key.toString());中的key.toString()改为key+”/“,即改为<strong>multipleOutputs.write((Text) null, value, key+”/“)</strong>; 即可，输出结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190513220914542.png" alt="分组输出到不同文件夹下" title>                </div>                <div class="image-caption">分组输出到不同文件夹下</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/tags/Hadoop/"/>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Map Reduce" scheme="http://www.duanmuxu.top/tags/Map-Reduce/"/>
    
  </entry>
  
  <entry>
    <title>只爱一点点</title>
    <link href="http://www.duanmuxu.top/20190602/just-love-a-little-bit.html"/>
    <id>http://www.duanmuxu.top/20190602/just-love-a-little-bit.html</id>
    <published>2019-06-02T04:28:32.246Z</published>
    <updated>2020-02-29T11:21:19.754Z</updated>
    
    <content type="html"><![CDATA[<p>不爱那么多，<br>只爱一点点。<br>别人的爱情像海深，<br>我的爱情浅。<br>不爱那么多，<br>只爱一点点。<br>别人的爱情像天长，<br>我的爱情短。<br>不爱那么多，<br>只爱一点点。<br>别人眉来又眼去，<br>我只偷看你一眼。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/just-love-a-little-bit.htm/1.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人的爱情像海深，&lt;br&gt;我的爱情浅。&lt;br&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人的爱情像天长，&lt;br&gt;我的爱情短。&lt;br&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人眉来又眼去，&lt;br&gt;我只偷看你一眼。&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.duanmuxu.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="现代诗" scheme="http://www.duanmuxu.top/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java实现从尾到头打印链表（ListNode）每个节点的值</title>
    <link href="http://www.duanmuxu.top/20190602/the-java-implementation-prints-value-of-each-node-linked-list-listnode-from-end-to.html"/>
    <id>http://www.duanmuxu.top/20190602/the-java-implementation-prints-value-of-each-node-linked-list-listnode-from-end-to.html</id>
    <published>2019-06-02T04:28:32.243Z</published>
    <updated>2020-03-14T10:22:52.824Z</updated>
    
    <content type="html"><![CDATA[<p>进行做题之前，先来看看什么是ListNode。</p><blockquote><p>ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    public ListNode(int x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>val表示当前ListNode的值，next指向下一个ListNode。在进行ListNode<strong>初始化时必须传值</strong>，如下面main函数中进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ListNode listNode = new ListNode(1);</span><br><span class="line">listNode.next = new ListNode(3);</span><br><span class="line">listNode.next.next = new ListNode(4);</span><br><span class="line">listNode.next.next.next = new ListNode(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时生成链表：1-&gt;3-&gt;4-&gt;1</p><hr><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</span><br></pre></td></tr></table></figure><h3 id="方法一：利用栈的思想"><a href="#方法一：利用栈的思想" class="headerlink" title="方法一：利用栈的思想"></a>方法一：利用栈的思想</h3><p>一个链表从头到尾输入，要求输出的是从尾到头。符合栈<strong>先进后出</strong>的思想，因此可以用下面方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">while (listNode != null) &#123;</span><br><span class="line">stack.push(listNode.val);</span><br><span class="line">listNode = listNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList  = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">arrayList.add(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      return arrayList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList  = new ArrayList&lt;Integer&gt;();</span><br><span class="line">if (listNode != null) &#123;</span><br><span class="line">arrayList.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">arrayList.add(listNode.val);</span><br><span class="line">&#125;</span><br><span class="line">return arrayList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下addAll()和all()的区别：</p><blockquote><p>add（）是将传入的的参数作为当前 List 中d的一个项目（Item）来存储，即使你传入一个 list 也只会另当前的List集合增加 1 个元素。<br><br><br>addAll（）是传入一个List，将此前List集合中的所有元素加入到当前的 List 中，当前 List 集合会增加的元素个数是传入的 List 的大小。</p></blockquote><h3 id="方法三：头插法"><a href="#方法三：头插法" class="headerlink" title="方法三：头插法"></a>方法三：头插法</h3><p>利用链表头插法为逆序的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ListNode head = new ListNode(-1);</span><br><span class="line">while (listNode != null) &#123;</span><br><span class="line">ListNode q = listNode.next;</span><br><span class="line">listNode.next = head.next;</span><br><span class="line">head.next = listNode;</span><br><span class="line">listNode = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = head.next;</span><br><span class="line">while (head != null) &#123;</span><br><span class="line">arrayList.add(head.val);</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：链表翻转"><a href="#方法四：链表翻转" class="headerlink" title="方法四：链表翻转"></a>方法四：链表翻转</h3><ul><li>利用函数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    while(listNode != null)&#123;</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Collections.reverse(list);//使用Collections的reverse方法，直接将list反转</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>强行进行逆序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(listNode == null)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    while(listNode.next != null)&#123;</span><br><span class="line">        arr.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.add(listNode.val);</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int inx=0, end=arr.size()-1; inx&lt;end; inx++, end--)&#123;</span><br><span class="line">        temp = arr.get(inx);</span><br><span class="line">        arr.set(inx, arr.get(end));</span><br><span class="line">        arr.set(end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行做题之前，先来看看什么是ListNode。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;f
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找二叉树的下一个节点（中序遍历）</title>
    <link href="http://www.duanmuxu.top/20190602/find-the-next-node-of-a-binary-tree-inorder-traversal.html"/>
    <id>http://www.duanmuxu.top/20190602/find-the-next-node-of-a-binary-tree-inorder-traversal.html</id>
    <published>2019-06-02T04:28:32.229Z</published>
    <updated>2020-02-18T17:31:14.228Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们先了解一下二叉树的三种遍历方法：</p><ul><li>前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；</li><li>中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面；</li><li>后序遍历：也是从最左节点开始，根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面。</li></ul><p>比如下面一张图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/find-the-next-node-of-a-binary-tree-inorder-traversal.htm/1.jpg" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><ul><li>前序遍历为：ABDGHECKFIJ</li><li>中序遍历为：GDHBEAKCIJF</li><li>后序遍历为：GHDEBKJIFCA</li></ul><p>了解了二叉树的大致遍历方式，我们来看下题目：</p><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p>通过中序遍历我们可以知道一个节点的下一个节点有两种情况：</p><ul><li>如果一个节点的右子树不为空，那么该节点的下一个节点是<strong>右子树的最左节点</strong>，比如上图中C的后一个节点是I；</li><li>如果一个节点的右子树为空，那么向上找<strong>第一个左链接</strong>指向的树包含该节点的<strong>父节点</strong>。比如上图H的下一个节点是B。</li></ul><p>接下来看代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义一棵树</span><br><span class="line"></span><br><span class="line">public class TreeLinkNode &#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode next = null;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        //判断该节点是否存在右子节点</span><br><span class="line">        if(pNode.right != null)&#123;</span><br><span class="line">        //如果有右子树，则找右子树的最左节点</span><br><span class="line">            TreeLinkNode rightNode = pNode.right;</span><br><span class="line">            while(rightNode.left != null)</span><br><span class="line">                rightNode = rightNode.left;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        //没右子树，则找第一个当前节点是父节点左孩子的节点</span><br><span class="line">            while(pNode.next != null)&#123;</span><br><span class="line">                TreeLinkNode parentNode = pNode.next;</span><br><span class="line">                if(parentNode.left == pNode)</span><br><span class="line">                    return parentNode;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们先了解一下二叉树的三种遍历方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；&lt;/li&gt;
&lt;li&gt;中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer中关于斐波那契数列的分析和运用</title>
    <link href="http://www.duanmuxu.top/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.html"/>
    <id>http://www.duanmuxu.top/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.html</id>
    <published>2019-06-02T04:28:32.227Z</published>
    <updated>2020-02-18T17:31:14.307Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。</p><blockquote><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br>——《百度百科》</p></blockquote><p>具体函数表达参考下面这张图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.htm/1.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h4 id="那么我们该如何求解与斐波那契数列相关的问题呢？"><a href="#那么我们该如何求解与斐波那契数列相关的问题呢？" class="headerlink" title="那么我们该如何求解与斐波那契数列相关的问题呢？"></a>那么我们该如何求解与斐波那契数列相关的问题呢？</h4><p>先看一下题目描述：</p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p></blockquote><p>具体可以用以下几种方法求解：</p><h5 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h5><p>递归能将一个问题划分成多个子问题进行求解。求F(n)时会转化成求F(n-1)、F(n-2),以此类推，最后转化成几个F(0)、F(1)相加的结果。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result = Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.htm/2.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可是使用递归会有一个问题，会重复计算一些子问题。比如计算F(5)需要计算F(4)和F(3)，计算F(4)需要计算F(3)和F(2)，可以看到F(3)被重复计算了。造成了资源浪费。</p><p>所以我们换个思路。</p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>递归是将一个问题划分成多个子问题进行求解。动态规划相当于是个相反的过程，将子问题的解存储起来，用来解决大问题，比如已知F(0)、F(1)，进行求F(2)，再进一步求F(3)，以此类推，直至求到F(n)。这样子就不会有重复求解子问题的烦恼产生。<br>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int[] fib = new int[n+1];</span><br><span class="line">        fib[0] = 0;</span><br><span class="line">        fib[1] = 1;</span><br><span class="line">        for(int i = 2;i &lt; n + 1; i++)&#123;</span><br><span class="line">            fib[i] = fib[i - 1] + fib[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return fib[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.htm/3.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><p>这么做比递归好很多，但是考虑到第i项只与第i-1和第i-2项有关，因此只需要存储前两项的值就能求解第i项，从而将空间复杂度由O(N)降低为O(1)。所以我们可以进一步优化。</p><h5 id="动态规划的进一步优化"><a href="#动态规划的进一步优化" class="headerlink" title="动态规划的进一步优化"></a>动态规划的进一步优化</h5><p>使用两个值存储i-1和i-2，避免使用数组，浪费更多的空间。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne = 1; //存储i-1</span><br><span class="line">        int preTwo = 0; //存储i-2</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 2;i &lt; n + 1; i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.htm/4.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><hr><p>接下来我们来看看剑指Offer中其他关于斐波那契数列的运用的题目：</p><h6 id="题目一：跳台阶"><a href="#题目一：跳台阶" class="headerlink" title="题目一：跳台阶"></a>题目一：跳台阶</h6><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p>简单分析一下，就可以知道还是上面斐波那契数列的变化，青蛙跳1级台阶有1种跳法，2级台阶有2种跳法，3级台阶时可以从1级台阶跳上来也可以从2级台阶跳上来，即等于1级台阶的跳法加2级台阶的跳法因此n级台阶共有n-2级台阶跳法数+n-1级台阶跳法数。</p><p>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)</span><br><span class="line">            return target;</span><br><span class="line"></span><br><span class="line">        int preOne = 2;</span><br><span class="line">        int preTwo = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target+1 ;i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="题目二：变态跳台阶"><a href="#题目二：变态跳台阶" class="headerlink" title="题目二：变态跳台阶"></a>题目二：变态跳台阶</h6><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p></blockquote><p>上一题的升级版，跳n级台阶时可以允许跳1~n任意阶级的台阶。<br><br>先来分析一下</p><ul><li>跳n级台阶，那么第一步有n种跳法：跳1级、跳2级、到跳n级</li><li>跳1级，剩下n-1级，则剩下跳法是F(n-1)；</li><li>跳2级，剩下n-2级，则剩下跳法是F(n-2)；</li><li>所以F(n)=F(n-1)+F(n-2)+…+F(1)+1，最后的+1是因为直接跳n级台阶只有一种方法；</li><li>因为F(n-1)=F(n-2)+F(n-3)+…+F(1)+1;</li><li>以此类推，得F(n)=2*F(n-1)。</li></ul><p>分析后变得比上面一提还要简单。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)&#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int preNum = 2;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target + 1;i++)&#123;</span><br><span class="line">            result = 2 * preNum;</span><br><span class="line">            preNum = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="题目三：矩阵覆盖"><a href="#题目三：矩阵覆盖" class="headerlink" title="题目三：矩阵覆盖"></a>题目三：矩阵覆盖</h6><blockquote><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p></blockquote><p>再来分析一下</p><ul><li>首先从n=1开始，小矩阵只能竖着放，只有一种方法；</li><li>n=2时，大矩阵为2 * 2，小矩阵既可以竖着放也可以横着放，有两种方法；</li><li>当n越来越大时，如果第一步选择竖着放，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.htm/5.jpg" alt="第一步：竖着放" title>                </div>                <div class="image-caption">第一步：竖着放</div>            </figure>那么大矩阵的规模缩小成2 * (n-1)；</li><li>如果第一步选择竖着放，那么第二排也只能横着放，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/20190602/analysis-and-application-of-fibonacci-sequence-in-jianzhi-offer.htm/6.jpg" alt="第一步：横着放" title>                </div>                <div class="image-caption">第一步：横着放</div>            </figure>那么大矩阵的规模缩小成2 * (n-2)；</li><li>因此，题目又转化成了与题目一一样的斐波那契数列了。<br>实现如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)</span><br><span class="line">            return target;</span><br><span class="line"></span><br><span class="line">        int preOne = 2;</span><br><span class="line">        int preTwo = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target+1 ;i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是关于斐波那契数列的含义和使用方式，题目一二三都是剑指Offer中的真题，示例中关于运行时间和占用内存是根据牛客网的测试用例得来的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Storm学习01：Storm简介</title>
    <link href="http://www.duanmuxu.top/20190602/storm-learning-01-introduction-to.html"/>
    <id>http://www.duanmuxu.top/20190602/storm-learning-01-introduction-to.html</id>
    <published>2019-06-02T04:28:32.198Z</published>
    <updated>2019-06-30T08:47:45.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Storm"><a href="#什么是Storm" class="headerlink" title="什么是Storm"></a>什么是Storm</h1><p>Apache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批处理相类似，Storm可以对大量的数据流进行可靠的实时处理，这一过程也称为“流式处理”，是分布式大数据处理的一个重要方向。Storm支持多种类型的应用，包括：实时分析、在线机器学习、连续计算、分布式 RPC（ DRPC）、ETL等。Strom的一个重要特点就是“快速”的数据处理，有benchmark示显示Storm级能够达到单个节点每秒百万级tuple处理（tuple是Storm的最小数据单元）的速度。快速的数据是处理、优秀的可扩展性与容错性、便捷的可操作性与维护性、活跃的社区技术支持，这就是 Storm 。</p><hr><h1 id="Hadoop与Storm的比较"><a href="#Hadoop与Storm的比较" class="headerlink" title="Hadoop与Storm的比较"></a>Hadoop与Storm的比较</h1><h3 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h3><table><thead><tr><th></th><th>Hadoop</th><th>Storm</th></tr></thead><tbody><tr><td>系统角色</td><td>JobTracker</td><td>Nimbus</td></tr><tr><td></td><td>TaskTracker</td><td>Supervisor</td></tr><tr><td></td><td>Child</td><td>Worker</td></tr><tr><td>应用名称</td><td>Job</td><td>Topology</td></tr><tr><td>组件接口</td><td>Mapper/Reducer</td><td>Spout/Bolt</td></tr></tbody></table><ul><li><strong>Nimbus</strong>：Nimbus在Storm中用于资源分配和作业调度，类比Hadoop中的Job Tracker</li><li><strong>Supervisor</strong>：Supervisor在Storm中用于接收Nimbus分配的任务，并且启动和停止用于完成这些任务对的Worker进程。Supervisor类比Hadoop中的TaskTracker</li><li><strong>Worker</strong>：运行Storm中具体组件逻辑的进程。这里的组件指的是Spout或者Bolt，对比Hadoop.x的Child进程。</li><li><strong>Topology</strong>：Topology是Storm中运行的一个任务，类比Hadoop.x中的一个作业（Job）</li><li><strong>Spout</strong>：在一个Topology中产生源数据流的组件</li><li><strong>Bolt</strong>：在一个Topology中接收数据，并进行逻辑处理的组件，称为Transformation</li></ul><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><table><thead><tr><th></th><th>Hadoop</th><th>Storm</th></tr></thead><tbody><tr><td>数据来源</td><td>Hadoop处理的是HDFS上TB级别的数据（历史数据）</td><td>Storm处理的是实时新增的某一笔数据（实时数据）</td></tr><tr><td>处理过程</td><td>Hadoop是分Map阶段和Reduce阶段</td><td>Storm是由用户定义处理流程，流程中可以包含多个步骤，每个步骤可以是数据源（Spout）或处理逻辑（Bolt）</td></tr><tr><td>是否结束</td><td>Hadoop最后是要结束的</td><td>Storm没有结束状态，到最后一步时，就停在那，直到有新数据进入时再从头开始</td></tr><tr><td>处理速度</td><td>Hadoop是以处理HDFS上大量数据为目的的，处理速度慢</td><td>Storm是只要处理新增的某一笔数据即可，可以做到很快</td></tr><tr><td>适用场景</td><td>Hadoop是在要处理批量数据时用的，不讲究时效性</td><td>Storm是要处理某一新增数据时使用的，讲究时效性</td></tr></tbody></table><p>ps：在Hadoop集群上运行MapReduce jobs，在Storm集群上运行topologies。jobs和topologies有很大的不同。一个关键区别是：一个Map Reduce jobs最终可以完成，而topologies处理过程将永远执行（除非Kill it）</p><hr><h1 id="Storm组件"><a href="#Storm组件" class="headerlink" title="Storm组件"></a>Storm组件</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611162336868.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><h5 id="Storm集群中包含两类节点：主控节点（Master-Node）和工作节点（Work-Node）"><a href="#Storm集群中包含两类节点：主控节点（Master-Node）和工作节点（Work-Node）" class="headerlink" title="Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node）"></a>Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node）</h5><ul><li>主控节点上运行着Nimbus，负责在Storm集群内分发代码，分配任务给工作机器，并且负责监控集群运行状态</li><li>工作节点上运行着Supervisor，负责监听从Nimbus分配给它执行的任务，据此启动或停止任务的工作进程。</li><li><strong>每一个工作进程执行一个Topology的子集；一个运行中的Topology由分布在不同工作节点上的多个工作进程组成。</strong></li><li>Nimbus 和和 Supervisor节点之间所有的协调工作是通过<strong>Zookeeper集群</strong>来实现的。此外，Nimbus 和Supervisor进程都是<strong>快速失败（fail-fast)</strong> 和 <strong>无状态（stateless）</strong> 的；<strong>Storm集群所有的状态要么在Zookeeper集群中，要么存储在本地磁盘上</strong>。这意味着我们可以用kill-9来杀死Nimbus和Supervisor进程，它们在重启后可以继续工作。这个设计使得Storm集群拥有极强的<strong>稳定性</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Storm&quot;&gt;&lt;a href=&quot;#什么是Storm&quot; class=&quot;headerlink&quot; title=&quot;什么是Storm&quot;&gt;&lt;/a&gt;什么是Storm&lt;/h1&gt;&lt;p&gt;Apache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Storm/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/tags/Storm/"/>
    
  </entry>
  
</feed>
