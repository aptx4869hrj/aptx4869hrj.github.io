<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>端木胥的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.duanmuxu.top/"/>
  <updated>2019-06-20T15:30:26.758Z</updated>
  <id>http://www.duanmuxu.top/</id>
  
  <author>
    <name>端木胥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Shell学习03：expect实现自动输入密码登录服务器</title>
    <link href="http://www.duanmuxu.top/20190620/shell-learning-03-expect-to-automatically-enter-the-password-log-in-server.html"/>
    <id>http://www.duanmuxu.top/20190620/shell-learning-03-expect-to-automatically-enter-the-password-log-in-server.html</id>
    <published>2019-06-20T15:14:46.304Z</published>
    <updated>2019-06-20T15:30:26.758Z</updated>
    
    <content type="html"><![CDATA[<p>我们通过Shell脚本可以实现简单的控制流功能，比如说循环、判断、对本地文件进行一些简单的操作、输入输出写日志等，但都是对于本地机器而言进行的操作。那么当我们<strong>需要在一台机器上操作另一台机器时</strong>，那该怎么办呢？</p><p>expect就是用来实现这种交互功能的工具。</p><h2 id="expect介绍"><a href="#expect介绍" class="headerlink" title="expect介绍"></a>expect介绍</h2><p>expect是Unix系统中用来进行自动化控制和测试的软件工具，作为Tcl脚本语言的一个扩展，应用在交互式软件中如telnet，ftp，Passwd，fsck，rlogin，tip，ssh等等。expect是一个免费的编程工具，用来实现自动的交互式任务，而无需人为干预。说白了，expect就是一套用来实现自动交互功能的软件，比如上面说的一台机子操作另一台机子。</p><p>在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而利用expect，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。这就是expect！</p><h2 id="expect安装"><a href="#expect安装" class="headerlink" title="expect安装"></a>expect安装</h2><p>我用的是Ubuntu发行版，因此执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install expect</span><br></pre></td></tr></table></figure><p>就ok啦，CentOS用户可以通过命令 yum  install expect 安装</p><h2 id="expect相关命令"><a href="#expect相关命令" class="headerlink" title="expect相关命令"></a>expect相关命令</h2><ul><li>spawn：启动新的进程</li><li>expect：从进程接收字符串（换行后系统自动打印的字符串）</li><li>send：用于向进程发送字符串 </li><li>interact：允许用户交互</li><li>exp_continue： 匹配多个字符串在执行动作后加此命令</li></ul><h2 id="expect参数"><a href="#expect参数" class="headerlink" title="expect参数"></a>expect参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name [lindex $argv 0]</span><br></pre></td></tr></table></figure><p>使用[lindex $argv 0]进行读取参数，使用set将参数添加进变量中</p><h2 id="实例详解"><a href="#实例详解" class="headerlink" title="实例详解"></a>实例详解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/expect</span><br><span class="line"></span><br><span class="line">set timeout 30</span><br><span class="line">set host &quot;10.11.43.90&quot;</span><br><span class="line">set username &quot;root&quot;</span><br><span class="line">set password &quot;123456&quot;</span><br><span class="line"></span><br><span class="line">spawn ssh $username@$host</span><br><span class="line">expect &quot;*password*&quot; </span><br><span class="line">&#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">interact</span><br></pre></td></tr></table></figure><ul><li>set timeout 30：设置超时时间，单位为秒，默认情况下是10秒，也可设为-1，表示一直运作</li><li>set host/username/password：设置变量</li><li>spawn ssh $username@$host：启动新的进程，spawn主要的功能是给ssh运行进程加个壳，用来传递交互指令。这里变量的引用和Shell脚本中一致，直接使用$或者使用${}都可以</li><li>expect “<em>password</em>“：接受的字符串中是否包含’password’这个子串</li><li>{send “$password\r”}：如果包含，则发送$password过去并回车，即执行交互动作</li><li>interact：执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。</li></ul><h2 id="expect登录其他服务器执行命令"><a href="#expect登录其他服务器执行命令" class="headerlink" title="expect登录其他服务器执行命令"></a>expect登录其他服务器执行命令</h2><p>以下内容是一台机器通过ssh登录另一台机器，并在另一台机器上执行命令将以日期作为分区的文件从一个hdfs集群转移至另一个hdfs集群上。参数为一个日期，如果传了参数，则使用用户传的参数，否则使用前一天的日期作为分区标志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#! /usr/bin/expect</span><br><span class="line"># 设置超时时间 等待三十秒</span><br><span class="line">set timeout 30</span><br><span class="line"># 传入参数</span><br><span class="line">set name [lindex $argv 0]</span><br><span class="line"></span><br><span class="line"># 设置时间</span><br><span class="line">set date [ clock format [ clock seconds ] -format &quot;%Y%m%d&quot; ]</span><br><span class="line">set secon [  clock seconds ]</span><br><span class="line">set yestoday_secon 0</span><br><span class="line"> </span><br><span class="line">set yestoday_secon [expr &#123;$secon - 86400&#125; ]</span><br><span class="line">set yestoday [ clock format [ expr &#123;$yestoday_secon&#125; ] -format &quot;%Y%m%d&quot; ]</span><br><span class="line"></span><br><span class="line">if &#123;&quot;$name&quot; &gt; 0&#125; &#123;</span><br><span class="line">        set time &quot;$name&quot;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        set time &quot;$yestoday&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn ssh hadoop@10.11.43.90</span><br><span class="line">expect &quot;*assword&quot;     </span><br><span class="line">send &quot;123456\r&quot; </span><br><span class="line"></span><br><span class="line">expect &quot;hadoop&quot;</span><br><span class="line">send &quot;hadoop distcp hdfs://10.11.56.29/apps/hive/warehouse/location_stay/dt=$&#123;time&#125;/* /DOMAIN_B/DISNEY/LOCATION/APP/HY/location_stay/dt=$&#123;time&#125;\r&quot;</span><br><span class="line"></span><br><span class="line">expect &quot;hadoop&quot;</span><br><span class="line">send &quot;exit\r&quot;</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们通过Shell脚本可以实现简单的控制流功能，比如说循环、判断、对本地文件进行一些简单的操作、输入输出写日志等，但都是对于本地机器而言进行的操作。那么当我们&lt;strong&gt;需要在一台机器上操作另一台机器时&lt;/strong&gt;，那该怎么办呢？&lt;/p&gt;
&lt;p&gt;expect就是用
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习02：Shell变量</title>
    <link href="http://www.duanmuxu.top/20190619/shell-learning-02-variables.html"/>
    <id>http://www.duanmuxu.top/20190619/shell-learning-02-variables.html</id>
    <published>2019-06-19T13:20:22.650Z</published>
    <updated>2019-06-19T13:22:44.365Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名不加美元符号($)，并且变量名和等号中不能有空格。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tempVar=&quot;variable&quot;</span><br></pre></td></tr></table></figure><p>同时，变量名的命令规则如下：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li><li>中间不能有空格，可以使用下划线 _ </li><li>不能使用标点符号</li><li>不能使用bash里的关键字（可用 <strong>compgen -k</strong> 命令查看保留关键字）。</li></ul><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加$符号即可，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tempVar=&quot;variable&quot;</span><br><span class="line">echo $tempVar</span><br><span class="line">echo $&#123;tempVar&#125;</span><br></pre></td></tr></table></figure><p>变量名外面的大括号是可选的，加大括号是为了帮助解释器识别变量的边界，防止出现识别错误变量。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;shell&quot;</span><br><span class="line">echo &quot;I am learning $&#123;str&#125;skill&quot;</span><br></pre></td></tr></table></figure><p>打印出来就是<strong>I am learning shellskill</strong>，如果没有大括号，则打印出来的内容是<strong>I am learning</strong>，系统识别<em>strskill</em>为一个变量，但并没有此变量，因此打印变量为空。所以使用变量时建议加上大括号，更为规范。</p><h3 id="readonly-只读变量"><a href="#readonly-只读变量" class="headerlink" title="readonly 只读变量"></a>readonly 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">myVar=&quot;change&quot;</span><br><span class="line">readonly myVar</span><br><span class="line">myUrl=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure><p>运行时报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令就可以删除变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset myVar</span><br></pre></td></tr></table></figure><p>变量被删除后不能再次使用。并且 unset 命令不能删除<strong>只读变量</strong>。</p><p>（当脚本文件规模不大时，要删除变量的话直接在脚本里把变量去掉就行了。）</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li>环境变量</li><li>本地变量</li><li>局部变量</li><li>位置变量</li><li>特殊变量（bash内置变量，也称系统变量）</li></ul><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export var_name=value    //作用域为当前shell进程及其子进程`</span><br></pre></td></tr></table></figure><p>给Linux系统配置过JDK的同学应该对这个变量很熟悉</p><h4 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_name=value   //本地变量，作用域为当前shell进程，对当前shell外的其他shell进程，v包括当前shell，子shell进程均无效</span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local var_name=value  //局部变量，作用域为当前代码段，常用于函数</span><br></pre></td></tr></table></figure><p>局部变量也是一种本地变量</p><h4 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$1,$2,$3, ....  //用来引用脚本的参数</span><br><span class="line">shift [num]     //位置变量使用完以后退出，后面的参数向前推进 </span><br><span class="line">shift 1         //一次往前推，例：$1完成任务后变成$2执行</span><br></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$#   //是传给脚本的参数个数</span><br><span class="line">$0   //是脚本本身的名字</span><br><span class="line">$!   //是shell最后运行的后台Process的PID</span><br><span class="line">$@   //是传给脚本的所有参数的列表</span><br><span class="line">$*   //是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个</span><br><span class="line">$$   //是脚本运行的当前进程ID号</span><br><span class="line">$?   //是显示上条命令的退出状态，0表示没有错误，其他表示有错误</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash内建环境变量，这些变量不能当作自定义变量使用</span><br><span class="line">PATH</span><br><span class="line">SHELL</span><br><span class="line">UID</span><br><span class="line">HISTSIZE</span><br><span class="line">HOME</span><br><span class="line">PWD</span><br><span class="line">HISTFILE</span><br><span class="line">PS1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义变量&quot;&gt;&lt;a href=&quot;#定义变量&quot; class=&quot;headerlink&quot; title=&quot;定义变量&quot;&gt;&lt;/a&gt;定义变量&lt;/h3&gt;&lt;p&gt;定义变量时，变量名不加美元符号($)，并且变量名和等号中不能有空格。如：&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Shell学习01：创建和执行脚本文件</title>
    <link href="http://www.duanmuxu.top/20190618/shell-learning-01-creating-and-executing-script-files.html"/>
    <id>http://www.duanmuxu.top/20190618/shell-learning-01-creating-and-executing-script-files.html</id>
    <published>2019-06-18T07:51:38.418Z</published>
    <updated>2019-06-18T07:55:02.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建Shell脚本"><a href="#新建Shell脚本" class="headerlink" title="新建Shell脚本"></a>新建Shell脚本</h2><p>进入一个你想要放脚本文件的目录。执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 直接新建脚本文件并进入编辑</span><br><span class="line">vim ShellTest.sh </span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line"></span><br><span class="line"># 先新建脚本文件，再进入编辑页面</span><br><span class="line">touch ShellTest.sh  </span><br><span class="line">vim ShellTest.sh</span><br></pre></td></tr></table></figure><p>在脚本文件编辑页面中放入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure><ul><li>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。一般默认使用Bash进行脚本执行。</li><li>echo 命令用于向窗口输出文本。</li></ul><h2 id="执行Shell脚本"><a href="#执行Shell脚本" class="headerlink" title="执行Shell脚本"></a>执行Shell脚本</h2><h4 id="作为可执行程序"><a href="#作为可执行程序" class="headerlink" title="作为可执行程序"></a>作为可执行程序</h4><p>在root用户下新建文件时，文件的默认权限为 <strong>-rw-r–r–</strong>，即文件在root用户下可读写，其他用户只能读不能写，但是<strong>所有用户都无法执行</strong>。因此执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ShellTest.sh</span><br></pre></td></tr></table></figure><p>将脚本文件变为可执行文件，执行后的权限为 <strong>-rwxr-xr-x</strong> ，即所有用户都可执行。然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ShellTest.sh</span><br></pre></td></tr></table></figure><p>控制台输出 “Hello World !”，脚本执行成功。 </p><blockquote><p>./ 表示执行本文件所在目录下的某一文件</p></blockquote><h4 id="作为解释器参数"><a href="#作为解释器参数" class="headerlink" title="作为解释器参数"></a>作为解释器参数</h4><p>这种运行方式直接运行解释器，把 shell 脚本的文件名作为解释器的参数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh ShellTest.sh</span><br></pre></td></tr></table></figure><p>这种方式运行的脚本，不需要在第一行指定解释器信息，也不需要将脚本文件的权限转为可执行，只要作为参数的脚本文件的路径没错就行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;新建Shell脚本&quot;&gt;&lt;a href=&quot;#新建Shell脚本&quot; class=&quot;headerlink&quot; title=&quot;新建Shell脚本&quot;&gt;&lt;/a&gt;新建Shell脚本&lt;/h2&gt;&lt;p&gt;进入一个你想要放脚本文件的目录。执行&lt;/p&gt;
&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="Shell" scheme="http://www.duanmuxu.top/categories/Shell/"/>
    
    
      <category term="Shell" scheme="http://www.duanmuxu.top/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Storm学习02：八种grouping分组策略</title>
    <link href="http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html"/>
    <id>http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html</id>
    <published>2019-06-11T08:24:43.140Z</published>
    <updated>2019-06-11T08:28:15.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>为拓扑中的每个 Bolt 的<strong>确定输入数据流</strong>是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。</p><p>在 Storm 中有八种内置的数据流分组方式，而且还可以通过 <strong>CustomStreamGrouping</strong>接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式）</p><h2 id="具体分组"><a href="#具体分组" class="headerlink" title="具体分组"></a>具体分组</h2><p>这八种分组分时分别为：</p><hr><ul><li>Shuffle grouping：随机分组。这种方式下元组会被尽可能随机地分配到Bolt的不同任务（tasks）中，使得每个任务所处理元组数量能够保持基本一致，以确保集群的负载均衡。</li><li>Fields grouping：按字段分组。这种方式下数据流根据定义的Field来进行分组。比如，如果某个数据流是基于一个名为“user-id”的字段进行分组的，那么所有包含相同的“user-id”的tuple都会被分配到同一个任务中，这样就可以确保消息处理的一致性。</li><li>Partial Key grouping：部分关键字分组。这种方式与Fields grouping很相似，根据定义的域来对数据流进行分组，不同的是，这种方式会考虑下游Bolt数据处理的均衡性问题，在<strong>输入数据源关键字不平衡</strong>时会有更好的性能。</li><li>All grouping：完全分组。这种方式下数据流会被同时发送到Bolt的所有任务中（也就是说同一个元组会被复制多份然后被所有的任务处理），使用这种分组方式要特别小心。</li><li>Global grouping：全局分组。这种方式下所有的数据流都会被发送到 Bolt 的同一个任务中，也就是id最小的那个任务。</li><li>None grouping：无分组。使用这种方式说明你不关心数据流如何分组。目前这种方式的结果与随机分组完全等效，不过未来Storm社区可能会考虑通过非分组方式来让 Bolt 和它所订阅的 Spout 或 Bolt 在同一个线程中执行。</li><li>Direct grouping：直接分组。这是一种特殊的分组方式。使用这种方式意味着元组的发送者可以指定下游的哪个任务可以接收这个元组。只有在数据流被声明为直接数据流时才能够使用直接分组方式。使用直接数据流发送元组需要使用OutputCollector的其中一个emitDirect方法。Bolt可以通过TopologyContext来获取它的下游消费者的任务id，也可以通过跟踪OutputCollector的emit方法（该方法会返回它所发送元组的目标任务的id）的数据来获取任务 id。</li><li>Local or shuffle grouping：本地或随机分组。如果目标bolt有一个或者多个task与源bolt的task在同一个工作进程中，tuple将会被随机发送给这些同进程中的tasks。否则，和普通的Shuffle Grouping行为一致。</li></ul><hr><p>其中Shuffle grouping、Fields grouping、All grouping、Global grouping四种策略用得较多。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>拿最简单的WordCount来做例子：</p><h3 id="新建wordcount项目"><a href="#新建wordcount项目" class="headerlink" title="新建wordcount项目"></a>新建wordcount项目</h3><h4 id="新建RandomSentenceSpout类来产生数据"><a href="#新建RandomSentenceSpout类来产生数据" class="headerlink" title="新建RandomSentenceSpout类来产生数据"></a>新建RandomSentenceSpout类来产生数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.spout.SpoutOutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichSpout;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class RandomSentenceSpout extends BaseRichSpout &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 6102239192526611945L;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(RandomSentenceSpout.class);</span><br><span class="line"></span><br><span class="line">    private SpoutOutputCollector collector;</span><br><span class="line">    private Random random;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此open方法,</span><br><span class="line">     * 一般都会在此方法中对发送Tuple的对象SpoutOutputCollector和配置对象TopologyContext初始化</span><br><span class="line">     */</span><br><span class="line">    public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">        this.random = new Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个spout类，之前说过，最终会运行在task中，某个worker进程的某个executor线程内部的某个task中</span><br><span class="line">     * 那个task会负责去不断的无限循环调用nextTuple()方法</span><br><span class="line">     * 只要的话呢，无限循环调用，可以不断发射最新的数据出去，形成一个数据流</span><br><span class="line">     */</span><br><span class="line">    public void nextTuple() &#123;</span><br><span class="line">        String[] sentences = new String[]&#123;</span><br><span class="line">                &quot;I used to watch her from my kitchen widow&quot;</span><br><span class="line">                , &quot;she seemed so small as she muscled her way through the crowd of boys on the playground&quot;</span><br><span class="line">                , &quot;The school was across the street from our home and I would often watch the kids as they played during recess&quot;</span><br><span class="line">                , &quot;A sea of children, and yet tome&quot;</span><br><span class="line">                , &quot;she stood out from them all&quot;&#125;;</span><br><span class="line">        String sentence = sentences[random.nextInt(sentences.length)];</span><br><span class="line">        LOGGER.info(&quot;  --- 发射 sentence 数据 ---&gt; &#123;&#125;&quot;, sentence);</span><br><span class="line">        // 这个values，你可以认为就是构建一个tuple,tuple是最小的数据单位，无限个tuple组成的流就是一个stream,通过 emit 发送数据到下游bolt tuple</span><br><span class="line">        this.collector.emit(new Values(sentence));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前Spout的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游</span><br><span class="line">     bolt 中 execute 接收数据 key</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;sentence&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新建SplitSentenceBolt类用来切割单词"><a href="#新建SplitSentenceBolt类用来切割单词" class="headerlink" title="新建SplitSentenceBolt类用来切割单词"></a>新建SplitSentenceBolt类用来切割单词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.task.OutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Tuple;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SplitSentenceBolt extends BaseRichBolt &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -4758047349803579486L;</span><br><span class="line"></span><br><span class="line">    private OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法</span><br><span class="line">     * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化</span><br><span class="line">     */</span><br><span class="line">    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的</span><br><span class="line">     * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行</span><br><span class="line">     * 切分单词</span><br><span class="line">     */</span><br><span class="line">    public void execute(Tuple input) &#123;</span><br><span class="line">        // 接收上游数据</span><br><span class="line">        String sentence = input.getStringByField(&quot;sentence&quot;);</span><br><span class="line">        String[] words = sentence.split(&quot; &quot;);</span><br><span class="line">        for(String word : words)&#123;</span><br><span class="line">            //发射数据</span><br><span class="line">            this.collector.emit(new Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key</span><br><span class="line">     * 定义发射出去的tuple，每个field的名称</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;word&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新建WordCountBolt类用来单词计数"><a href="#新建WordCountBolt类用来单词计数" class="headerlink" title="新建WordCountBolt类用来单词计数"></a>新建WordCountBolt类用来单词计数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.shade.com.google.common.collect.Maps;</span><br><span class="line">import org.apache.storm.task.OutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Tuple;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class WordCountBolt extends BaseRichBolt &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(WordCountBolt.class);</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -7114915627898482737L;</span><br><span class="line"></span><br><span class="line">    private OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Long&gt; countMap = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法</span><br><span class="line">     * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化</span><br><span class="line">     */</span><br><span class="line">    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的</span><br><span class="line">     * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行</span><br><span class="line">     * 统计单词</span><br><span class="line">     */</span><br><span class="line">    public void execute(Tuple input) &#123;</span><br><span class="line">        // 接收上游数据</span><br><span class="line">        String word = input.getStringByField(&quot;word&quot;);</span><br><span class="line">        Long count = countMap.get(word);</span><br><span class="line">        if(null == count)&#123;</span><br><span class="line">            count = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">        countMap.put(word, count);</span><br><span class="line">        LOGGER.info(&quot; ---  单词计数[&#123;&#125;] ---&gt; 出现的次数：&#123;&#125;&quot;, word, count);</span><br><span class="line">        //发射数据</span><br><span class="line">        this.collector.emit(new Values(word,count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key</span><br><span class="line">     * 定义发射出去的tuple，每个field的名称</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;word&quot;,&quot;count&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新建WordCountTopology类用来链接Spout和Bolt，执行主程序"><a href="#新建WordCountTopology类用来链接Spout和Bolt，执行主程序" class="headerlink" title="新建WordCountTopology类用来链接Spout和Bolt，执行主程序"></a>新建WordCountTopology类用来链接Spout和Bolt，执行主程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.Config;</span><br><span class="line">import org.apache.storm.LocalCluster;</span><br><span class="line">import org.apache.storm.StormSubmitter;</span><br><span class="line">import org.apache.storm.topology.TopologyBuilder;</span><br><span class="line">import org.apache.storm.utils.Utils;</span><br><span class="line"></span><br><span class="line">public class WordCountTopology &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //去将spout和bolts组合起来，构建成一个拓扑</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line"></span><br><span class="line">        // 第一个参数的意思，就是给这个spout设置一个名字</span><br><span class="line">        // 第二个参数的意思，就是创建一个spout的对象</span><br><span class="line">        // 第三个参数的意思，就是设置spout的executor有几个</span><br><span class="line">        builder.setSpout(&quot;RandomSentence&quot;, new RandomSentenceSpout(), 2);</span><br><span class="line">        builder.setBolt(&quot;SplitSentence&quot;, new SplitSentenceBolt(), 5)</span><br><span class="line">                //为bolt 设置 几个task</span><br><span class="line">                .setNumTasks(10)</span><br><span class="line">                //设置流分组策略</span><br><span class="line">                .shuffleGrouping(&quot;RandomSentence&quot;);</span><br><span class="line"></span><br><span class="line">        // fieldsGrouping 这个很重要，就是说，相同的单词，从SplitSentenceSpout发射出来时，一定会进入到下游的指定的同一个task中</span><br><span class="line">        // 只有这样子，才能准确的统计出每个单词的数量</span><br><span class="line">        // 比如你有个单词，hello，下游task1接收到3个hello，task2接收到2个hello</span><br><span class="line">        // 通过fieldsGrouping 可以将 5个hello，全都进入一个task</span><br><span class="line">        builder.setBolt(&quot;wordCount&quot;, new WordCountBolt(), 10)</span><br><span class="line">                //为bolt 设置 几个task</span><br><span class="line">                .setNumTasks(20)</span><br><span class="line">                //设置流分组策略</span><br><span class="line">                .shuffleGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.globalGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.allGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.fieldsGrouping(&quot;SplitSentence&quot;, new Fields(&quot;word&quot;));</span><br><span class="line"></span><br><span class="line">        // 运行配置项</span><br><span class="line">        Config config = new Config();</span><br><span class="line"></span><br><span class="line">        //说明是在命令行执行，打算提交到storm集群上去</span><br><span class="line">        if(args != null &amp;&amp; args.length &gt; 0)&#123;</span><br><span class="line">            /**</span><br><span class="line">             *  要想提高storm的并行度可以从三个方面来改造</span><br><span class="line">             *  worker(进程)&gt;executor(线程)&gt;task(实例)</span><br><span class="line">             *  增加work进程，增加executor线程，增加task实例</span><br><span class="line">             *  对应 supervisor.slots.port 中配置个数</span><br><span class="line">             *  这里可以动态设置使用个数</span><br><span class="line">             *  最好一台机器上的一个topology只使用一个worker,主要原因时减少了worker之间的数据传输</span><br><span class="line">             *</span><br><span class="line">             *  注意：如果worker使用完的话再提交topology就不会执行，因为没有可用的worker，只能处于等待状态，把之前运行的topology停止一个之后这个就会继续执行了</span><br><span class="line">             */</span><br><span class="line">            config.setNumWorkers(3);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 将Topolog提交集群</span><br><span class="line">                StormSubmitter.submitTopology(args[0], config, builder.createTopology());</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 用本地模式运行1个拓扑时，用来限制生成的线程的数量</span><br><span class="line">            config.setMaxTaskParallelism(20);</span><br><span class="line"></span><br><span class="line">            // 将Topolog提交本地集群</span><br><span class="line">            LocalCluster cluster = new LocalCluster();</span><br><span class="line">            cluster.submitTopology(&quot;wordCountTopology&quot;, config, builder.createTopology());</span><br><span class="line"></span><br><span class="line">            // 为了测试模拟等待</span><br><span class="line">            Utils.sleep(60000);</span><br><span class="line">            // 执行完毕，关闭cluster</span><br><span class="line">            cluster.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="shuffleGrouping运行结果"><a href="#shuffleGrouping运行结果" class="headerlink" title="shuffleGrouping运行结果"></a>shuffleGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611161427796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="shuffleGrouping运行结果" title>                </div>                <div class="image-caption">shuffleGrouping运行结果</div>            </figure><p>随机分组，不自觉间做到了负载均衡。</p><h4 id="globalGrouping运行结果"><a href="#globalGrouping运行结果" class="headerlink" title="globalGrouping运行结果"></a>globalGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611161449921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="globalGrouping运行结果" title>                </div>                <div class="image-caption">globalGrouping运行结果</div>            </figure><p>只往一个里面发,发送到id最小的那个任务。</p><h4 id="allGrouping运行结果"><a href="#allGrouping运行结果" class="headerlink" title="allGrouping运行结果"></a>allGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611161502207.png" alt="allGrouping运行结果" title>                </div>                <div class="image-caption">allGrouping运行结果</div>            </figure><p>两个spot并行 所有都分发。</p><h4 id="fieldsGrouping运行结果"><a href="#fieldsGrouping运行结果" class="headerlink" title="fieldsGrouping运行结果"></a>fieldsGrouping运行结果</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2019061116151598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="fieldsGrouping运行结果" title>                </div>                <div class="image-caption">fieldsGrouping运行结果</div>            </figure><p>相同的名称的fields分发到一个bolt里面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h2&gt;&lt;p&gt;为拓扑中的每个 Bolt 的&lt;strong&gt;确定输入数据流&lt;/strong&gt;是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Storm/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/tags/Storm/"/>
    
  </entry>
  
  <entry>
    <title>Ambari集群搭建（HDP离线安装版）</title>
    <link href="http://www.duanmuxu.top/20190604/ambari-cluster-setup-hdp-offline-installation.html"/>
    <id>http://www.duanmuxu.top/20190604/ambari-cluster-setup-hdp-offline-installation.html</id>
    <published>2019-06-04T10:57:20.241Z</published>
    <updated>2019-06-08T04:27:48.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装环境部署"><a href="#安装环境部署" class="headerlink" title="安装环境部署"></a>安装环境部署</h2><h4 id="使用版本"><a href="#使用版本" class="headerlink" title="使用版本"></a>使用版本</h4><ul><li>Ubuntu：ubuntu-16.04.6-server-amd64</li><li>Ambari：ambari-2.5.0.3-ubuntu16</li><li>HDP：HDP-2.6.0.3-ubuntu16</li><li>HDP-UTILS：HDP-UTILS-1.1.0.21-ubuntu16</li></ul><h4 id="设置每台主机的host"><a href="#设置每台主机的host" class="headerlink" title="设置每台主机的host"></a>设置每台主机的host</h4><p>首先修改每一台主机的hostname<br>输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><p>命名随意，不重复就行。</p><p>输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>进入hosts编辑页面<br>每台主机host的配置都要相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 127.0.0.1     localhost ambari01</span><br><span class="line">192.168.2.93    ambari01</span><br><span class="line">192.168.2.94    ambari02</span><br><span class="line">192.168.2.95    ambari03</span><br></pre></td></tr></table></figure><p>ip地址后的名称与hostname中的名称相同</p><p>修改完后ping其他不同的主机，看能不能ping通</p><h4 id="链接Xshell"><a href="#链接Xshell" class="headerlink" title="链接Xshell"></a>链接Xshell</h4><p>安装Ubuntu的时候，勾选安装OpenSSH，系统打开后就能直接使用ssh服务了。</p><p>登录每台主机，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>将该文件下的 <strong>PermitRootLogin</strong>的值改为 <strong>yes</strong></p><p>输入以下命令重启一下SSH服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure><p>重启成功后就能使用xShell连接虚拟机进行操作了。</p><h4 id="免密登录从机"><a href="#免密登录从机" class="headerlink" title="免密登录从机"></a>免密登录从机</h4><p>首先在主机上运行 <strong>sudo ssh-keygen</strong> ，然后一路回车，生成本机公私密钥。 <strong>注意要一路回车，不用输入任何字符。</strong> 然后执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@ambari01</span><br><span class="line">ssh-copy-id root@ambari02</span><br><span class="line">ssh-copy-id root@ambari03</span><br></pre></td></tr></table></figure><p>注意也要对自己本机也操作一次，不然后面在ambari服务器上安装组件的时候本机会显示<strong>permision denied</strong> 的情况。</p><p>执行以上命令时，会依次提示输入每台从机的root密码，然后主机就会自动将公钥发送给各个从机的机器中并立即生效。</p><p>执行后可以通过执行<strong>ssh root@ambari02</strong> 进行测试，可以直接登陆从机，无需密码。</p><h4 id="保存主机的私钥"><a href="#保存主机的私钥" class="headerlink" title="保存主机的私钥"></a>保存主机的私钥</h4><p>复制一份刚才主机生成的私钥，后面ambari搭建集群的时候会需要用到，密钥的文件位于 <strong>/root/.ssh/id_rsa</strong>，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /root/.ssh/id_rsa /root</span><br></pre></td></tr></table></figure><p>将密钥复制到root文件目录下，然后通过<strong>xftp</strong>将文件下载到Windows本地。因为xftp不能直接访问.ssh目录。</p><h4 id="安装yum和ntp"><a href="#安装yum和ntp" class="headerlink" title="安装yum和ntp"></a>安装yum和ntp</h4><p>每个从机、主机都需要安装yum、ntp，否则后面Ambari部署有些会不通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install yum</span><br><span class="line">apt-get install ntp</span><br></pre></td></tr></table></figure><h4 id="python版本-gt-2-6"><a href="#python版本-gt-2-6" class="headerlink" title="python版本 &gt; 2.6"></a>python版本 &gt; 2.6</h4><p>一般Ubuntu默认都会安装python2.7，此条可以忽略。</p><hr><p>准备工作完毕。下面开始集群的搭建。</p><h2 id="下载HDP与HDP-UTILS离线安装包"><a href="#下载HDP与HDP-UTILS离线安装包" class="headerlink" title="下载HDP与HDP-UTILS离线安装包"></a>下载HDP与HDP-UTILS离线安装包</h2><p>前面一个安装包大约5.9G，如果选择在线安装则太费时间，因此下载已经编译好的HDP安装包进行离线安装。</p><p>首先进入 <a href="https://docs.hortonworks.com/" target="_blank" rel="noopener">https://docs.hortonworks.com/</a> 找到ambari，选择自己想要的版本。本文使用的是Ambari-2.5.0.3版本。选择好版本后，找到<strong>Apache Ambari Installation</strong> ，点击进入后，通过点击 <strong>Getting Ready -&gt; Using a Local Repository -&gt; Obtaining the Repositories -&gt; HDP Stack Repositories</strong> 找到HDP离线版下载，我使用的版本为 HDP-2.6.0.3，具体网址为下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.hortonworks.com/HDPDocuments/Ambari-2.5.0.3/bk_ambari-installation/content/hdp_26_repositories.html</span><br></pre></td></tr></table></figure><p>然后就是漫长的下载之路了，一共6G左右，记住要选择对应的Ambari和虚拟机版本。下载HDP和HDP-UTILS两个文件。</p><h2 id="安装-Ambari"><a href="#安装-Ambari" class="headerlink" title="安装 Ambari"></a>安装 Ambari</h2><p>Ambari只需要在主机上安装，而后安装组件时其他从机会自动部署。</p><p>继续在刚才的网站上，找到 <strong>Download the Ambari Repository</strong>，选择对应的虚拟机版本，然后按照官方手册指引，root用户登录主机后依次执行以下三句命令即可完成安装源的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/apt/sources.list.d/ambari.list http://public-repo-1.hortonworks.com/ambari/ubuntu16/2.x/updates/2.5.0.3/ambari.list</span><br><span class="line">apt-key adv --recv-keys --keyserver keyserver.ubuntu.com B9733A7A07513CAD</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><p>要注意ambari版本的问题，不要版本不一致。</p><p>具体操作可以查看<a href="https://docs.hortonworks.com/HDPDocuments/Ambari-2.5.0.3/bk_ambari-installation/content/download_the_ambari_repo_ubuntu16.html" target="_blank" rel="noopener">官方操作手册</a>。</p><p>然后进行ambari-server 的安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ambari-server</span><br></pre></td></tr></table></figure><p>一共七百多MB，大概安装个二十分钟左右，视网速而定。</p><h2 id="配置-Ambari"><a href="#配置-Ambari" class="headerlink" title="配置 Ambari"></a>配置 Ambari</h2><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ambari-server setup</span><br></pre></td></tr></table></figure><p>进行配置ambari-server，一路回车进行配置，途中会安装JDK，选择JDK1.8继续安装。</p><p>中途也会遇到选择安装数据库，默认选择安装MySQL，继续安装。</p><p>ambari的用户名和密码如果不进行设置则默认都为admin。</p><p>安装好后将JDK1.8安装包发送给每个从机，都将JDK1.8安装一遍。</p><h2 id="启动-Ambari"><a href="#启动-Ambari" class="headerlink" title="启动 Ambari"></a>启动 Ambari</h2><p>操作手册上如是说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Run the following command on the Ambari Server host:</span><br><span class="line">ambari-server start</span><br><span class="line"></span><br><span class="line">- To check the Ambari Server processes:</span><br><span class="line">ambari-server status</span><br><span class="line"></span><br><span class="line">- To stop the Ambari Server:</span><br><span class="line">ambari-server stop</span><br></pre></td></tr></table></figure><p>执行 <strong>ambari-server start</strong> ，稍候片刻启动服务。然后进入网址 <strong>http://&lt;主机IP&gt;:8080</strong> 就可以进入Ambari的登录界面。账号密码如果刚才没有配置，则均为admin。</p><h2 id="部署HDP离线安装包"><a href="#部署HDP离线安装包" class="headerlink" title="部署HDP离线安装包"></a>部署HDP离线安装包</h2><h4 id="安装Nignx"><a href="#安装Nignx" class="headerlink" title="安装Nignx"></a>安装Nignx</h4><p>也不一定是要nignx，只要能提供Http服务，来作为HDP离线包的下载服务器就行。</p><p>主机上运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nignx</span><br></pre></td></tr></table></figure><p>安装完成后浏览器进入 <strong>http://&lt;主机IP&gt;:80</strong> 查看是否有Nignx欢迎页面。</p><h4 id="上传HDP离线安装包"><a href="#上传HDP离线安装包" class="headerlink" title="上传HDP离线安装包"></a>上传HDP离线安装包</h4><p>使用xftp进行文件传输，xftp连接主机后进入 <strong>/var/www/html</strong> 目录，将HDP-UTILS-1.1.0.21-ubuntu16.tar.gz和HDP-2.6.0.3-ubuntu16-deb.tar.gz两个文件传到该目录下。</p><p>在linux终端下新建文件夹HDP-UTILS-1.1.0.21，将压缩包HDP-2.6.0.3-ubuntu16-deb.tar.gz直接解压，将压缩包HDP-UTILS-1.1.0.21-ubuntu16.tar.gz解压到新建的文件夹HDP-UTILS-1.1.0.21下</p><p>执行以下命令将默认的欢迎页面重命名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/www/html/index.nginx-debian.html /var/www/html/index.nginx-debian.html.bak</span><br></pre></td></tr></table></figure><p>进入nignx的配置页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><p>在 <strong>server{…}</strong> 里添加一句 <strong>autoindex on;</strong> 即打开目录浏览功能。</p><p>以上步骤做完后，再次访问 <strong>http://&lt;主机IP&gt;:80</strong> 时，能看到目录结构，同时能找到HDP以及HDP-UTILS，能够从页面上下载，HDP离线安装包就配置好了。</p><h2 id="开始创建集群"><a href="#开始创建集群" class="headerlink" title="开始创建集群"></a>开始创建集群</h2><ul><li>进入 <strong>http://&lt;主机IP&gt;:8080</strong> Ambari登录页面，账号密码均为admin；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160632726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="ambari登录界面" title>                </div>                <div class="image-caption">ambari登录界面</div>            </figure></li><li>登陆后选择<strong>Launch Install Wizard</strong>；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160657570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>命名你的集群，好听点就行；</li><li>下一步，选择本地Repository，选择对应的虚拟机版本，链接填刚才配置好的Nignx的服务器路径址，即<strong>http://&lt;主机IP&gt;/HDP/ubuntu16/</strong> 和 <strong>http://&lt;主机IP&gt;/HDP-UTILS-1.1.0.21/</strong>；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160730196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>进入install options，输入集群机器的ip，选择之前下载到本地的id_rsa文件。点击Register and confirm 进入下一步；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160714458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>confirm host 之后，进行选择服务，即要安装的大数据组件，进行安装</li><li>进行到Customize Services时可能会让你进行一些密码的设置，比如hive组件之类的，设置好不报错后继续安装；<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160746440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li><li>安装成功即完成部署。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2019060416075651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></li></ul><hr><p>完结撒花！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190604160902366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><hr><hr><p>参考文章：<a href="https://www.jianshu.com/p/af50f3e8b8b2" target="_blank" rel="noopener">如何优雅地使用Apache Ambari安装HDFS、HBase等分布式应用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装环境部署&quot;&gt;&lt;a href=&quot;#安装环境部署&quot; class=&quot;headerlink&quot; title=&quot;安装环境部署&quot;&gt;&lt;/a&gt;安装环境部署&lt;/h2&gt;&lt;h4 id=&quot;使用版本&quot;&gt;&lt;a href=&quot;#使用版本&quot; class=&quot;headerlink&quot; title=&quot;使
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Ambari" scheme="http://www.duanmuxu.top/tags/Ambari/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转化为阿拉伯数字</title>
    <link href="http://www.duanmuxu.top/20190602/roman-numerals-are-converted-to-arabic.html"/>
    <id>http://www.duanmuxu.top/20190602/roman-numerals-are-converted-to-arabic.html</id>
    <published>2019-06-02T04:28:32.282Z</published>
    <updated>2019-06-02T04:31:29.751Z</updated>
    
    <content type="html"><![CDATA[<p>题目简述：</p><hr><p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. </p><hr><p>简而言之，从I到M七个字母分别代表着1~1000的七种不同大小。当所给罗马数字的字母顺序为从M到I的顺序排列时，它的值即为其字母所代表的值相加，比如’XXVII’，即表示X+X+V+I+I。当所给罗马数字字符串中有一个字母比这个字母其后的字母所表示的值小时，这两个字母结合起来代表一个数值，其值为（后一个字母的值-前一个字母的值），比如’MCD’，C的值比D小，因此等于M+CD=1000+500-100=1400。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>其实经过分析过后思路就很明确了，比较所给字符串中当前字母和下一个字母的数值大小，如果当前字母的值比下一个字母的值大，直接相加，反之则后一个字母的值减去当前字母的值，并将这两个字母当作一个整体。</p><p>有了思路，就得有解题方法。既然是涉及到前后两个字母进行比较，那么就有两种情况，<strong>一种是获取当前字母的值，与后一个字母进行比较；一种是保存前一个字母的值，与当前字母的值进行比较。</strong></p><hr><h4 id="当前字母与前一个字母相比较"><a href="#当前字母与前一个字母相比较" class="headerlink" title="当前字母与前一个字母相比较"></a>当前字母与前一个字母相比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        int[] a = new int[26];</span><br><span class="line">        a[&apos;I&apos; - &apos;A&apos;] = 1;</span><br><span class="line">        a[&apos;V&apos; - &apos;A&apos;] = 5;</span><br><span class="line">        a[&apos;X&apos; - &apos;A&apos;] = 10;</span><br><span class="line">        a[&apos;L&apos; - &apos;A&apos;] = 50;</span><br><span class="line">        a[&apos;C&apos; - &apos;A&apos;] = 100;</span><br><span class="line">        a[&apos;D&apos; - &apos;A&apos;] = 500;</span><br><span class="line">        a[&apos;M&apos; - &apos;A&apos;] = 1000;</span><br><span class="line"></span><br><span class="line">        int sum = 0;</span><br><span class="line">        char prev = &apos;A&apos;;</span><br><span class="line">        for (char str : s.toCharArray()) &#123;</span><br><span class="line">            if(a[str - &apos;A&apos;] &gt; a[prev - &apos;A&apos;])&#123;</span><br><span class="line">                sum = sum - 2*a[prev - &apos;A&apos;];</span><br><span class="line">            &#125;</span><br><span class="line">            sum = sum + a[str - &apos;A&apos;];</span><br><span class="line">            prev = str;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法foreach中，当前值为str，保存的前一个字母为prev。当当前字母的值大于前一个字母的值时，整体总数sum减去前一个字母的值的两倍（一倍拿来消除之前加过的前一个字母的值，一倍拿来做整体两个字母的减数）。从而得出结果。</p><hr><h4 id="当前字母与后一个字母相比较"><a href="#当前字母与后一个字母相比较" class="headerlink" title="当前字母与后一个字母相比较"></a>当前字母与后一个字母相比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; chara = new HashMap&lt;&gt;();</span><br><span class="line">        chara.put(&apos;I&apos;, 1);</span><br><span class="line">        chara.put(&apos;V&apos;, 5);</span><br><span class="line">        chara.put(&apos;X&apos;, 10);</span><br><span class="line">        chara.put(&apos;L&apos;, 50);</span><br><span class="line">        chara.put(&apos;C&apos;, 100);</span><br><span class="line">        chara.put(&apos;D&apos;, 500);</span><br><span class="line">        chara.put(&apos;M&apos;, 1000);</span><br><span class="line"></span><br><span class="line">        int sum = 0; //定义总数</span><br><span class="line">        for(int i = 0; i &lt; s.length(); i++)&#123;</span><br><span class="line">            if(i &lt; s.length()-1 &amp;&amp; chara.get(s.charAt(i)) &lt; chara.get(s.charAt(i+1)))&#123;</span><br><span class="line">                sum = sum - chara.get(s.charAt(i));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum = sum + chara.get(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Map进行存储，当时使用数组也可以，只是为了<strong>存储多元化</strong>。这种方法要注意charAt的界限，防止越界。当当前的字母的值大于下一个字母的值时，正常相加；反之则总数sum减去当前字母的值。</p><p>有一点值得注意的是if的条件中有个<em>i &lt; s.length()-1</em>，即为了防止越界我们作比较只比较到了字符串的倒数第二个字母，最后一个字母的值是直接相加的。因为最后一个字母无需与其后的字母相比较，因此此种方法可行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目简述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Symbol&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>两个字符串中含有几个相同字符的几种解法</title>
    <link href="http://www.duanmuxu.top/20190602/several-solutions-for-identical-characters-in-two-strings.html"/>
    <id>http://www.duanmuxu.top/20190602/several-solutions-for-identical-characters-in-two-strings.html</id>
    <published>2019-06-02T04:28:32.281Z</published>
    <updated>2019-06-02T04:31:29.751Z</updated>
    
    <content type="html"><![CDATA[<p>最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。<br><br><br>进入正题，题目如下：</p><blockquote><p>You’re given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.<br><br>The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.<br><br>Example 1:<br>Input: <br>J = “aA”,<br> S = “aAAbbbb”<br>Output: 3<br><br>Example 2:<br>Input: <br>J = “z”,<br> S = “ZZ”<br>Output: 0<br><br>Note:<br>S and J will consist of letters and have length at most 50.<br>The characters in J are distinct.</p></blockquote><h4 id="简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。"><a href="#简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。" class="headerlink" title="简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。"></a>简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。</h4><hr><blockquote><p><em>以下方法全是基于Java进行实现</em></p></blockquote><p>先放我的方法：</p><h3 id="方法一：将字符串转化成数组"><a href="#方法一：将字符串转化成数组" class="headerlink" title="方法一：将字符串转化成数组"></a>方法一：将字符串转化成数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        char[] Ja = J.toCharArray();</span><br><span class="line">        char[] Sa = S.toCharArray();</span><br><span class="line">        int r = 0;</span><br><span class="line">        for (int i = 0;i &lt; Ja.length ; i ++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; Sa.length; j++)&#123;</span><br><span class="line">                if(Ja[i] == Sa[j])</span><br><span class="line">                    r ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先将J和S字符串转化成两个数组</li><li>对J的数组进行遍历，再对S的数组进行遍历</li><li>如果J中的字母与S中的字母相等（区分大小写），累加器r就加一</li><li>最后输出r即可</li></ul><br>&nbsp;&nbsp;&nbsp;&nbsp;很简单的一道题，当时想着继续刷题吧，反正刷题网站的意义就在于刷刷刷。不过还好打开了这道题的评论区，让我看到了一个新的世界。评论里有着许许多多其他不同的解题方法。这才是刷题网站的意义，**给一道题以不同的解题思路，让每个人都能有多种不同的思考。**<br>&nbsp;&nbsp;&nbsp;&nbsp;以下是本道题评论区中给出的其他解题方法，亲测有效<h3 id="方法二：字符串直接进行比较"><a href="#方法二：字符串直接进行比较" class="headerlink" title="方法二：字符串直接进行比较"></a>方法二：字符串直接进行比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S)&#123;</span><br><span class="line">        int count=0;</span><br><span class="line">        for (int i=0;i&lt;J.length();i++)&#123;</span><br><span class="line">            for (int j=0;j&lt;S.length();j++)&#123;</span><br><span class="line">                if (S.charAt(j) == J.charAt(i))&#123;</span><br><span class="line">                    count+=1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;其实和方法一差不大多，直接<strong>对字符串进行循环比较</strong>。最开始我也想用这方法，不过忘了charAt方法，不能确定字符串某个位置上的字母，于是换成了方法一。<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;另一种直接比较方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        int count =0;</span><br><span class="line">        for (int i =0;i&lt;S.length();i++)&#123;</span><br><span class="line">            if (J.contains(String.valueOf(S.charAt(i))))&#123;</span><br><span class="line">                count++;</span><br><span class="line">             &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是循环比较，少了层for循环而已，不再赘述。</p><h3 id="方法三：正则表达式"><a href="#方法三：正则表达式" class="headerlink" title="方法三：正则表达式"></a>方法三：正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">    return S.replaceAll(&quot;[^&quot; + J + &quot;]&quot;, &quot;&quot;).length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太狠了，这方法太狠了，一行解决事情。先介绍一下什么是正则表达式：</p><blockquote><p>正则表达式是对字符串（包括普通字符（例如，a到z之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。</p></blockquote><p>判断S字符串中有多少能被J字符串所替换的字符，将这些字符的长度输出就是答案。太狠了。<br><br><strong>不过这种方法时间会占用更多。</strong></p><h3 id="方法四：Hash-Set方法"><a href="#方法四：Hash-Set方法" class="headerlink" title="方法四：Hash Set方法"></a>方法四：Hash Set方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        Set&lt;Character&gt; set = new HashSet&lt;&gt;();</span><br><span class="line">        for (char c : J.toCharArray()) </span><br><span class="line">            set.add(c);</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (char c : S.toCharArray()) </span><br><span class="line">            if (set.contains(c)) </span><br><span class="line">                res++;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Hash Set就是用来提高查找效率的</strong>，将J字符串中的字母放在set中，判断S字符串中的字母知否包含在set中，是则累加器res加一，最后输出。<strong>这种方法运行效率也高。</strong></p><hr><p>问：为什么不是将S字符串的字符存入set中？<br><br>答：Hash Set不能存入相同的元素。以例子一为例，S字符串为：S = “aAAbbbb”，”A”有两个，”b”有四个，最后存入set后，set的长度为3，即存入元素为”a”,”A,”b”，因为字符串直接存入set里时，相同元素的HashCode是一样的，就会跳过重复的字符。这时与J字符串相比较，就只有”a”,”A”相匹配，输出结果为2，答案错误。</p><h3 id="方法五：ASCII值转换"><a href="#方法五：ASCII值转换" class="headerlink" title="方法五：ASCII值转换"></a>方法五：ASCII值转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int[] arr = new int[&apos;z&apos; - &apos;A&apos; + 1];</span><br><span class="line">    for (char c : J.toCharArray()) </span><br><span class="line">        arr[c - &apos;A&apos;] = 1;</span><br><span class="line">    for (char c : S.toCharArray()) </span><br><span class="line">        count += arr[c - &apos;A&apos;];</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个arr数组，大小为A的ASCII的值（65）到z的ASCII的值（122）的范围，中间有些特殊字符也占用了空间，不过没关系，不碍事。然后将J字符串中的字符也转成ASCII值，并将以该字符的ASCII值（与A相减过后的值，不然会溢出）为角标的数组值设为1，再对S字符串进行循环，累加器count一直与角标为S串中的字符的ASCII值的arr数组的值相加，最后结果输出即可。也是一种转换思维。</p><h3 id="方法六：Hash-Map方法"><a href="#方法六：Hash-Map方法" class="headerlink" title="方法六：Hash Map方法"></a>方法六：Hash Map方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int numJewelsInStones(String J, String S) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(char s : S.toCharArray())</span><br><span class="line">            map.put(s, map.getOrDefault(s, 0) + 1);</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; J.length(); i++)</span><br><span class="line">            count += map.getOrDefault(J.charAt(i), 0);</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>HashSet方法更简洁，详情参见方法四。</p><hr><p>暂时放这一些方法，有看到新的再更新，继续学习！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。&lt;br&gt;&lt;br&gt;&lt;br&gt;进入正题，题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You’re given strings J represen
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://www.duanmuxu.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第k个结点</title>
    <link href="http://www.duanmuxu.top/20190602/the-kth-node-in-list.html"/>
    <id>http://www.duanmuxu.top/20190602/the-kth-node-in-list.html</id>
    <published>2019-06-02T04:28:32.279Z</published>
    <updated>2019-06-02T04:31:29.754Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><p>链表结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由链表结构就能知道由此基础建立的链表不能直接知道该链表的长度，需要通过node = node.next 一步一步遍历链表才能获取链表长度。</p><p>因此最先想到的方法就是<strong>先遍历一遍链表，获取链表长度，然后通过链表长度和k数值的差得出目标地址</strong>。实现方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        ListNode newHead = head, pre = head;</span><br><span class="line">        int count = 0; // 获取链表长度</span><br><span class="line">        while(pre != null)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(count &lt; k) // 不存在倒数第k个链表</span><br><span class="line">            return null;</span><br><span class="line">        else&#123;</span><br><span class="line">            int num = count - k; // num为正数的目的地址，与倒数第k个链表值一致</span><br><span class="line">            while(num &gt; 0)&#123;</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            return newHead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了基础思路，下一步就是简化代码，用更简洁的表达将效果呈现出来。以下使用for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123; //5,&#123;1,2,3,4,5&#125;</span><br><span class="line">        ListNode p, q;</span><br><span class="line">        p = q = head;</span><br><span class="line">        int i = 0;</span><br><span class="line">        for (; p != null; i++) &#123;</span><br><span class="line">            if (i &gt;= k) </span><br><span class="line">                q = q.next;</span><br><span class="line">            p = p.next; // p相当于上面的pre链表，用于测量链表长度</span><br><span class="line">        &#125;</span><br><span class="line">        return i &lt;= k ? null : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用<strong>while一次遍历</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        ListNode pre=null,p=null;</span><br><span class="line">        //两个指针都指向头结点</span><br><span class="line">        p=head;</span><br><span class="line">        pre=head;</span><br><span class="line">        //记录k值</span><br><span class="line">        int a=k;</span><br><span class="line">        //记录节点的个数</span><br><span class="line">        int count=0;</span><br><span class="line">        //p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span><br><span class="line">        //当p指针跑到最后时，pre所指指针就是倒数第k个节点</span><br><span class="line">        while(p!=null)&#123;</span><br><span class="line">            p=p.next;</span><br><span class="line">            count++;</span><br><span class="line">            if(k&lt;1)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        //如果节点个数小于所求的倒数第k个节点，则返回空</span><br><span class="line">        if(count&lt;a) return null;</span><br><span class="line">        return pre;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实思路是一致的，就是<strong>通过得到链表长度，再得到n-k位置的链表值。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个链表，输出该链表中倒数第k个结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链表结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>括号匹配消除</title>
    <link href="http://www.duanmuxu.top/20190602/bracket-matching-elimination.html"/>
    <id>http://www.duanmuxu.top/20190602/bracket-matching-elimination.html</id>
    <published>2019-06-02T04:28:32.278Z</published>
    <updated>2019-05-16T08:08:39.154Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><hr><p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p><blockquote><p>input : ()[]{}<br>output : true</p></blockquote><blockquote><p>input : ({[]})<br>output : true</p></blockquote><blockquote><p>input : ({)}<br>output : false</p></blockquote><hr><p>简单得说就是括号相匹配，同一个类型的括号连在一起。同一对括号可以嵌套在其他括号中，但只能一对括号都嵌套进去（如（{}）），不能只嵌套一边的括号（如（{）}）。</p><p>有看过<strong>二叉树的前中后序遍历进行加减乘除操作</strong>的应该一看到这一题就知道怎么做了。运算中有有括号的先算括号中的数的原则，那么就需要对运算中的括号进行识别与约束，与这道题一个道理。因此一看到这道题就应该想到可以用栈去求解。解法如下：</p><h4 id="使用栈-Stack-的解法"><a href="#使用栈-Stack-的解法" class="headerlink" title="使用栈(Stack)的解法"></a>使用栈(Stack)的解法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        for (Character chara:s.toCharArray()) &#123;</span><br><span class="line">            if (chara == &apos;(&apos; || chara == &apos;[&apos; || chara == &apos;&#123;&apos;)</span><br><span class="line">                stack.push(chara);</span><br><span class="line">            else &#123;</span><br><span class="line">                if (stack.isEmpty())&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else &#123;</span><br><span class="line">                    Character charPop = stack.pop();</span><br><span class="line">                    if (charPop == &apos;(&apos; &amp;&amp; chara != &apos;)&apos; || charPop == &apos;[&apos; &amp;&amp; chara != &apos;]&apos; || charPop == &apos;&#123;&apos; &amp;&amp; chara != &apos;&#125;&apos;)&#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (stack.isEmpty())</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：所给字符串第一个字符必为”(“,”[“,”{“中的一种，如果不是，那必然无法必配成功，return false。按字符串顺序识别字符将字符串push进栈中。当字符为”)”,”]”,”}”中的一种时，pop一个字符与上面三种字符向匹配，如果匹配成功，继续执行程序，匹配成功的括号自动消除。反之return false，说明这个“右”括号的前面一个括号也是“右”括号，即前面一个括号无法匹配成功。最后判断这个栈是否为空，如果全部都匹配消除完成，栈为空。</p><h4 id="优化后的使用栈的方法"><a href="#优化后的使用栈的方法" class="headerlink" title="优化后的使用栈的方法"></a>优化后的使用栈的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">for (char c : s.toCharArray()) &#123;</span><br><span class="line">if (c == &apos;(&apos;)</span><br><span class="line">stack.push(&apos;)&apos;);</span><br><span class="line">else if (c == &apos;&#123;&apos;)</span><br><span class="line">stack.push(&apos;&#125;&apos;);</span><br><span class="line">else if (c == &apos;[&apos;)</span><br><span class="line">stack.push(&apos;]&apos;);</span><br><span class="line">else if (stack.isEmpty() || stack.pop() != c)</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>太简洁了！！！</strong> 字符如果是“左”括号，那么栈中保存相应的“右”括号。字符如果是“右”括号，与pop出的值相比，如果不相等则说明前一个括号不是相对应的“左”括号，即无法匹配，return false。</p><p>除了上面用栈的方法外，还有一种<strong>值替换法</strong>，实现如下：</p><h4 id="目标值替换法"><a href="#目标值替换法" class="headerlink" title="目标值替换法"></a>目标值替换法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isValid(String s) &#123;</span><br><span class="line">        int length;</span><br><span class="line">    </span><br><span class="line">        do &#123;</span><br><span class="line">            length = s.length();</span><br><span class="line">            s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;);</span><br><span class="line">        &#125; while(length != s.length());</span><br><span class="line">    </span><br><span class="line">        return s.length() == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：暴力替换目标值，符合一整对括号的值直接替换成空值，以替换前的字符串长度和替换后的字符串长度作比较条件，建立循环。最后判断字符串长度是否为零，即整对括号是否被替换完全。</p><p>还有Map的方法：</p><h4 id="使用Key-Value匹配进行求解"><a href="#使用Key-Value匹配进行求解" class="headerlink" title="使用Key-Value匹配进行求解"></a>使用Key-Value匹配进行求解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">    char[] chars = s.toCharArray();</span><br><span class="line">    Map&lt;Character,Character&gt; pairs = new HashMap&lt;Character,Character&gt;();</span><br><span class="line">    pairs.put(&apos;(&apos;, &apos;)&apos;);</span><br><span class="line">    pairs.put(&apos;&#123;&apos;, &apos;&#125;&apos;);</span><br><span class="line">    pairs.put(&apos;[&apos;, &apos;]&apos;);</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">    for (char c:chars) &#123;</span><br><span class="line">    if (pairs.containsKey(c)) &#123;</span><br><span class="line">    stack.push(pairs.get(c));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    if (stack.isEmpty() || c != stack.pop()) </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：将“左”括号作为key，“右”括号作为值放在Map中，其他思路与优化后的使用栈的方法一致。</p><hr><p>无论是用栈还是数组还是Hash Map，都只是一种工具，最主要的是思路，有了思路就有了目标，各种存储方法只是帮助达到目标的工具罢了。（当然，有些工具是独轮车，有些工具是飞机哈哈哈哈哈哈哈）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="leetcode" scheme="http://www.duanmuxu.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="http://www.duanmuxu.top/20190602/reverse-list.html"/>
    <id>http://www.duanmuxu.top/20190602/reverse-list.html</id>
    <published>2019-06-02T04:28:32.276Z</published>
    <updated>2019-06-02T04:31:29.749Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p>最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，<strong>暴力</strong>反转链表。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre, result = new ListNode(0);</span><br><span class="line">        pre = result;</span><br><span class="line"></span><br><span class="line">        if(head == null)&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while(cur != null)&#123; //循环读取链表数值，存在array链表中</span><br><span class="line">            array.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i = array.size() - 1; i &gt;=0; i--)&#123;</span><br><span class="line">            pre = new ListNode(array.get(i));</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法很美好，现实很骨感。运行时报出如下错误：</p><blockquote><p>Exception in thread “main” java.lang.NullPointerException</p></blockquote><p>咋肥事，还会有空指针报错？马上Debug，发现一个漏洞。</p><p>最开始定义了ListNode pre, result两个新链表，pre用于循环，每次增加新的next节点，因为每次pre.next = new ListNode(num)时，pre.val会赋予新的值，不能成为一条完整的逆序链表，因此定义了result链表来与pre每次添加的值相等，因为result = pre，因此两个<strong>内存地址相等</strong>，也就是result每次会以链表形式添加pre所添加的新元素，从而达到逆序操作。</p><p>不过问题就出在pre = new ListNode(array.get(i));这上，<strong>每次new一个值时，pre的内存地址就改变一次</strong>，但是result的内存地址不会变，因此result不会与pre产生联系，也就是最后return result的时候，<strong>result的值在最开始定义result时就已经确定了</strong>，与后续pre的操作无关，因此无法得到反转链表的目的。</p><p>所以上述代码是些辣鸡。那就换个思路吧，直接从<strong>链表本身</strong>入手。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">        if(head==null)</span><br><span class="line">            return null;</span><br><span class="line">        ListNode pre = null;</span><br><span class="line">        ListNode next = null;</span><br><span class="line">        while(head!=null)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啥意思呢，pre表示所给链表的前一个节点，next表示所给链表的下一个节点。代码解释如下:</p><ol><li>next = head.next 表示next保存head的下一个节点，<strong>保证head.next不会丢失</strong>；</li><li>head.next = pre 表示head指向了pre,也就是head<strong>从后指向前</strong>；</li><li>pre = head 表示pre现在已经是在next前面的数值中，由后指向前的一个链表；</li><li>head = next 表示head找回原先的head的下一节点，也就是第一步中被next保存的节点；</li><li>继续以上操作，直至head遍历完成，此时pre也反转完成。</li></ol><p>举个栗子最直观：</p><p><strong>输入链表 1-&gt;2-&gt;3-&gt;4-&gt;5</strong></p><ol><li>next = head.next = 2-&gt;3-&gt;4-&gt;5</li><li>head.next = pre =null</li><li>pre = head = 1</li><li>head = next = 2-&gt;3-&gt;4-&gt;5</li><li>—新一轮循环—</li><li>next = head.next = 3-&gt;4-&gt;5</li><li>head.next = pre = 1  （<strong>此时head.val = 2，因此head 表示2-&gt;1</strong>）</li><li>pre = head = 2-&gt;1 （<strong>达到反转的目的</strong>）</li><li>head = next = 3-&gt;4-&gt;5</li><li>—新一轮循环—</li><li>……</li><li>head = null</li><li>pre = 5-&gt;4-&gt;3-&gt;2-&gt;1</li></ol><p><strong>输出链表 5-&gt;4-&gt;3-&gt;2-&gt;1</strong></p><p>任务完成，值得品味。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，&lt;strong&gt;暴力&lt;/strong&gt;反转链表。实现如下：&lt;/p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>对所有员工的薪水按照salary进行按照1-N的排名</title>
    <link href="http://www.duanmuxu.top/20190602/salary-for-all-employees-is-ranked-according-to-1n-in.html"/>
    <id>http://www.duanmuxu.top/20190602/salary-for-all-employees-is-ranked-according-to-1n-in.html</id>
    <published>2019-06-02T04:28:32.273Z</published>
    <updated>2019-06-02T04:31:29.752Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列</p></blockquote><p>建表语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `salaries` (</span><br><span class="line">`emp_no` int(11) NOT NULL,</span><br><span class="line">`salary` int(11) NOT NULL,</span><br><span class="line">`from_date` date NOT NULL,</span><br><span class="line">`to_date` date NOT NULL,</span><br><span class="line">PRIMARY KEY (`emp_no`,`from_date`));</span><br></pre></td></tr></table></figure><p>输出描述：</p><table><thead><tr><th>emp_no</th><th>salary</th><th>rank</th></tr></thead><tbody><tr><td>10005</td><td>94692</td><td>1</td></tr><tr><td>10002</td><td>94409</td><td>2</td></tr><tr><td>10010</td><td>94409</td><td>2</td></tr><tr><td>10001</td><td>88958</td><td>3</td></tr><tr><td>10007</td><td>88958</td><td>3</td></tr><tr><td>10004</td><td>74057</td><td>4</td></tr></tbody></table><p>不看最后一个rank排名，那么这道题特别简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s.emp_no, s.salary</span><br><span class="line">from salaries s</span><br><span class="line">where s.to_date = &apos;9999-01-01&apos;</span><br><span class="line">order by s.salary desc, s.emp_no asc</span><br></pre></td></tr></table></figure><p>但是题目偏偏加了一个rank工资排名。那么怎样才能获得这个排名呢？</p><p>在Java中我们可以直接使用循环来给目标值加排名，SQL查询语句中看来行不通。仅仅使用一张表似乎达不到目的，那就使用两张表吧。</p><p>既然不能使用循环，那么可以通过什么方法来表示排名，或者说是<strong>表示在自己的前面还有多少人（包括自己）</strong>。</p><p>很明显了，我们可以通过两张表中salary的大小不同来获取在自己前面的人的个数，即<strong>s1.salary &lt;= s2.salary</strong>。举个栗子：<br><br>有三个salary（6000，5000，4000， 4000），输出为s1.salary，那么当s1.salary = 6000时，s1.salary &lt;= s2.salary 的值为6000，也就是一个，当s1.salary = 5000时，s1.salary &lt;= s2.salary 的值为6000和5000两个。但是当s1.salary = 4000时，s1.salary &lt;= s2.salary 的值就为（6000，5000，4000， 4000）四个，且4000是重复的，因此我们使用<strong>count(distinct s2.salary) rank</strong> 来去重，并计算个数，即排名，以此类推，<strong>输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary就是s1.salary的排名</strong></p><p>当然不要忘了<strong>group by s1.emp_no</strong> ，用来将员工编号分组，计算count()</p><p>最后结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select s1.emp_no, s1.salary, count(distinct s2.salary) rank</span><br><span class="line">from salaries s1, salaries s2</span><br><span class="line">where s1.salary &lt;= s2.salary and s1.to_date = &apos;9999-01-01&apos; and s2.to_date = &apos;9999-01-01&apos;</span><br><span class="line">group by s1.emp_no</span><br><span class="line">order by rank</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建表语句：&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="数据库" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>单向链表小记</title>
    <link href="http://www.duanmuxu.top/20190602/oneway-linked-list.html"/>
    <id>http://www.duanmuxu.top/20190602/oneway-linked-list.html</id>
    <published>2019-06-02T04:28:32.272Z</published>
    <updated>2019-06-02T04:31:29.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a>什么是链表？</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。</p><p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。　　</p><h3 id="什么是单向链表？"><a href="#什么是单向链表？" class="headerlink" title="什么是单向链表？"></a>什么是单向链表？</h3><p>单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。（其实就是上一篇中提到的ListNode）</p><p>单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。</p><h3 id="单向链表的具体实现"><a href="#单向链表的具体实现" class="headerlink" title="单向链表的具体实现"></a>单向链表的具体实现</h3><p>这边放上练习用的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package LinkedList;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class SingleLinkedList &#123;</span><br><span class="line">private int size;</span><br><span class="line">private Node head;</span><br><span class="line"></span><br><span class="line">public SingleLinkedList() &#123;</span><br><span class="line">size = 0;</span><br><span class="line">head = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private class Node&#123;</span><br><span class="line">private Object data;//每个节点的数据</span><br><span class="line">private Node next; //每个节点指向下一个节点的连接</span><br><span class="line"></span><br><span class="line">public Node(Object data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在链表头添加元素</span><br><span class="line">public Object addhead(Object obj) &#123;</span><br><span class="line">Node newHead = new Node(obj);</span><br><span class="line">if(size == 0)</span><br><span class="line">head = newHead;</span><br><span class="line">else &#123;</span><br><span class="line">newHead.next = head;</span><br><span class="line">head = newHead;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在链表头删除元素</span><br><span class="line">public Object deleteHead() &#123;</span><br><span class="line">Object obj = head.data;</span><br><span class="line">head = head.next;</span><br><span class="line">size--;</span><br><span class="line">return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查找指定元素，找到了返回节点Node，找不到返回null</span><br><span class="line">public Node find(Object obj) &#123;</span><br><span class="line">Node current = head;</span><br><span class="line">int tempSize = size;</span><br><span class="line">while(tempSize &gt; 0)&#123;</span><br><span class="line"> if(obj.equals(current.data))&#123;</span><br><span class="line"> return current;</span><br><span class="line"> &#125;else&#123;</span><br><span class="line"> current = current.next;</span><br><span class="line">     &#125;</span><br><span class="line">    tempSize--;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     //删除指定的元素，删除成功返回true</span><br><span class="line">     public boolean delete(Object value)&#123;</span><br><span class="line">         if(size == 0)&#123;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">         Node current = head;</span><br><span class="line">         Node previous = head;</span><br><span class="line">         while(current.data != value)&#123;</span><br><span class="line">         if(current.next == null)&#123;</span><br><span class="line">                 return false;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 previous = current;</span><br><span class="line">                 current = current.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //如果删除的节点是第一个节点</span><br><span class="line">         if(current == head)&#123;</span><br><span class="line">             head = current.next;</span><br><span class="line">             size--;</span><br><span class="line">         &#125;else&#123;//删除的节点不是第一个节点</span><br><span class="line">             previous.next = current.next;</span><br><span class="line">             size--;</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    //判断链表是否为空</span><br><span class="line">     public boolean isEmpty() &#123;</span><br><span class="line">     return (size == 0);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //在链表尾部添加元素</span><br><span class="line">     public Object addTail(Object obj) &#123;</span><br><span class="line">     Node newTail = new Node(obj);</span><br><span class="line">     Node current = head;</span><br><span class="line">     int temSize = size;</span><br><span class="line">     while (temSize &gt; 0) &#123;</span><br><span class="line">if (current.next == null) &#123;</span><br><span class="line">//需要先增加链表的容量，才能进行添加</span><br><span class="line">size++;</span><br><span class="line">current.next = newTail;</span><br><span class="line">newTail.next = null;</span><br><span class="line"></span><br><span class="line">return current;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">current = current.next;</span><br><span class="line">&#125;</span><br><span class="line">temSize--;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line">     return obj;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //显示节点信息</span><br><span class="line">     public void display() &#123;</span><br><span class="line">     if (size &gt; 0) &#123;</span><br><span class="line">Node node = head;</span><br><span class="line">int tempSize = size;</span><br><span class="line">if (tempSize == 1) &#123;</span><br><span class="line">System.out.print(&quot;[&quot; + node.data + &quot;]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">while (tempSize &gt; 0) &#123;</span><br><span class="line">if (node.equals(head)) &#123;</span><br><span class="line">System.out.print(&quot;[&quot; + node.data + &quot;-&gt;&quot;);</span><br><span class="line">&#125;else if (node.next == null) &#123;</span><br><span class="line">System.out.print(node.data+&quot;]&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.print(node.data+&quot;-&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">node = node.next;</span><br><span class="line">tempSize--;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">System.out.println(&quot;[]&quot;);</span><br><span class="line">&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">SingleLinkedList sLinkedList  = new SingleLinkedList();</span><br><span class="line">sLinkedList.addhead(&quot;A&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;B&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;C&quot;);</span><br><span class="line">sLinkedList.addhead(&quot;D&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.addTail(&quot;O&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.deleteHead();</span><br><span class="line">sLinkedList.display();</span><br><span class="line"></span><br><span class="line">sLinkedList.delete(&quot;B&quot;);</span><br><span class="line">sLinkedList.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[D-&gt;C-&gt;B-&gt;A]</span><br><span class="line">[D-&gt;C-&gt;B-&gt;A-&gt;O]</span><br><span class="line">[C-&gt;B-&gt;A-&gt;O]</span><br><span class="line">[C-&gt;A-&gt;O]</span><br></pre></td></tr></table></figure><p>这边注意一个地方，addTail()是往链表的末尾添加一个元素，在进行判断current.next == null 后，<strong>要先将整体链表的size + 1</strong>，不要将size + 1放在循环外进行,才能够使current.next = newTail,否则将无法添加成功，因为容量不够。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是链表？&quot;&gt;&lt;a href=&quot;#什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;什么是链表？&quot;&gt;&lt;/a&gt;什么是链表？&lt;/h3&gt;&lt;p&gt;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer 替换字符串中的空格</title>
    <link href="http://www.duanmuxu.top/20190602/stringbuffer-replaces-spaces-in-strings.html"/>
    <id>http://www.duanmuxu.top/20190602/stringbuffer-replaces-spaces-in-strings.html</id>
    <published>2019-06-02T04:28:32.269Z</published>
    <updated>2019-06-08T04:28:45.372Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">将一个字符串中的空格替换成 &quot;%20&quot;。</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">&quot;A B&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;A%20B&quot;</span><br></pre></td></tr></table></figure><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="将String-Buffer转换为String类型，再进行操作"><a href="#将String-Buffer转换为String类型，再进行操作" class="headerlink" title="将String Buffer转换为String类型，再进行操作"></a>将String Buffer转换为String类型，再进行操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    String str1 = str.toString();</span><br><span class="line">str1 = str1.replace(&quot; &quot;,&quot;%20&quot;);</span><br><span class="line">    return str1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别简单，不过好像不是出题者的原意</p><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><h4 id="先填充字符串再进行遍历替换"><a href="#先填充字符串再进行遍历替换" class="headerlink" title="先填充字符串再进行遍历替换"></a>先填充字符串再进行遍历替换</h4><blockquote><p>解题思路：<br>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。<br>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。<br>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">    int P1 = str.length() - 1;</span><br><span class="line">    for (int i = 0; i &lt;= P1; i++)</span><br><span class="line">        if (str.charAt(i) == &apos; &apos;)</span><br><span class="line">            str.append(&quot;  &quot;);</span><br><span class="line"></span><br><span class="line">    int P2 = str.length() - 1;</span><br><span class="line">    while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123;</span><br><span class="line">        char c = str.charAt(P1--);</span><br><span class="line">        if (c == &apos; &apos;) &#123;</span><br><span class="line">            str.setCharAt(P2--, &apos;0&apos;);</span><br><span class="line">            str.setCharAt(P2--, &apos;2&apos;);</span><br><span class="line">            str.setCharAt(P2--, &apos;%&apos;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            str.setCharAt(P2--, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串" scheme="http://www.duanmuxu.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Single Number 找出数组中的单一数字</title>
    <link href="http://www.duanmuxu.top/20190602/single-number-find-a-in-the-array.html"/>
    <id>http://www.duanmuxu.top/20190602/single-number-find-a-in-the-array.html</id>
    <published>2019-06-02T04:28:32.252Z</published>
    <updated>2019-06-02T04:31:29.720Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：</p><blockquote><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.<br><br>给定一个非空的整数数组，除了一个元素外，每个元素都会出现两次。找出那个单一的整数。</p></blockquote><p>最常规的思路就是进行循环，统计出现的数字，只出现一次的就是我们要的答案了</p><h4 id="for循环统计数字出现次数"><a href="#for循环统计数字出现次数" class="headerlink" title="for循环统计数字出现次数"></a>for循环统计数字出现次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int[] result = new int[nums.length];</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0;i &lt; nums.length; i++)&#123;</span><br><span class="line">            for (int j = 0;j &lt;= count;j++)&#123;</span><br><span class="line">                if (j == count)&#123;</span><br><span class="line">                    result[j] = -1;</span><br><span class="line">                    count++;</span><br><span class="line">                    j = count +1;</span><br><span class="line">                &#125;else if (nums[i] == nums[j])&#123;</span><br><span class="line">                    result[j]++;</span><br><span class="line">                    count++;</span><br><span class="line">                    j = count + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k = 0; k &lt; result.length ;k++)&#123;</span><br><span class="line">            if (result[k] == -1)</span><br><span class="line">                return nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个result数组用来存放统计的次数，初始值为-1，进行双重循环，以后每找到一个与nums数组中相同的数字，就在result数组中+1，即值变为0。最后根据result中值为-1（即在nums数组中没找到相同数值的数字）的数字就是我们要找的数字。</p><p>这种方法逻辑很顺，但是<strong>时间复杂度为O(n^2)</strong>，运行时间会消费很多。<br>那么要降低时间复杂度，就得<strong>减少一层循环</strong>。怎么才能实现呢？既要实现统计次数，又要遍历数组，有应用过<strong>Map Reducer</strong>方法的同学应该很容易就能想到<strong>word count</strong>程序好像就是这么一个道理，因此我们可以使用Map进行存值判断。</p><h4 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; result = new HashMap&lt;&gt;();</span><br><span class="line">        int resultNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            int num = nums[i];</span><br><span class="line">            if(result.containsKey(num))&#123;</span><br><span class="line">                result.remove(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.put(num, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int res : result.keySet()) &#123;</span><br><span class="line">            resultNum = res;</span><br><span class="line">        &#125;</span><br><span class="line">        return resultNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为nums数组中的重复数字只有两个，因此判断数字是否已经存在于Map中，若已经存在，则remove该数字，此时Map和nums数组中都已不存在该数字，若Map中不存在该数字，则put该数字。最后Map只剩下单一的数字，即我们想要的结果。</p><p>Map中需要插入<strong>key-value</strong>两个值，但是value的值对我们没有什么帮助，因此可以使用HashSet进一步优化。</p><h4 id="HashSet实现"><a href="#HashSet实现" class="headerlink" title="HashSet实现"></a>HashSet实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; result = new HashSet&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if(!result.add(num))</span><br><span class="line">                result.remove(num);</span><br><span class="line">        &#125;</span><br><span class="line">        Iterator&lt;Integer&gt; it = result.iterator();</span><br><span class="line">        return it.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断nums中的数字是否已经存在与HashSet中，若已经存在，则remove，若不存在，则直接add。这步与Map类似，不过只需要插入一个nums数组中的值就够了。</p><p>上面都是常规的一些存储方法，可没想到还有一个<strong>更加简洁帅气</strong>的方法。就是使用异或 ^ 的方法。</p><h4 id="XOR异或方法"><a href="#XOR异或方法" class="headerlink" title="XOR异或方法"></a>XOR异或方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            result = result ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么意思呢，^ 异或满足下面的转化：</p><table><thead><tr><th>a</th><th>b</th><th>result</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr><tr><td>所以两个数字进行 ^ 运算时，先将数字转化为二进制，再进行 ^ 操作，<strong>当两个数字相同时，则对应的二进制数的位数也都相同，因此运算结果为0</strong>。当<strong>0与任意数字进行异或运算时，运算结果为该任意数字</strong>，因此最终的结果就是nums数组中出现的单一数字。</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a non-empty array of integers, every element appears twice except for one. Find that single one.&lt;br&gt;&lt;br&gt;给
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>PAT乙级真题—福尔摩斯的约会</title>
    <link href="http://www.duanmuxu.top/20190602/pat-b-level-question-sherlock-holmess-date.html"/>
    <id>http://www.duanmuxu.top/20190602/pat-b-level-question-sherlock-holmess-date.html</id>
    <published>2019-06-02T04:28:32.251Z</published>
    <updated>2019-06-02T04:31:29.750Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><blockquote><p>大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。</p></blockquote><p>输入描述:</p><blockquote><p>输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。</p></blockquote><p>输出描述:</p><blockquote><p>在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。</p></blockquote><p>输入例子:</p><blockquote><p>3485djDkxh4hhGE<br>2984akDfkkkkggEdsb<br>s&amp;hgsfdk<br>d&amp;Hyscvnm</p></blockquote><p>输出例子:</p><blockquote><p>THU 14:04</p></blockquote><hr><p>这边注意几点，如果前两个输入中出现<strong>连续相同的字母</strong>怎么办？如果<strong>代表小时的相同字母/数字出现得比代表日期的相同字母要早</strong>怎么办？如果后两个输入中有多组相同的字母怎么办？输出中碰到个位数的小时/分钟时前面不带”0”（<strong>输出不规范</strong>）怎么办？</p><p>这些都不是问题，下面贴出通过的代码，并且有详细注释。可能会显得有些冗长，但是看起来一目了然，毫无难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class Holmes &#123;</span><br><span class="line">    //定义日期</span><br><span class="line">    private static char[] day = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;;</span><br><span class="line">    //定义当天的小时</span><br><span class="line">    private static char[] hour =&#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        //循环读取四个输入</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        while (scanner.hasNext())&#123;</span><br><span class="line">            //获取四个字符串</span><br><span class="line">            String str1 = scanner.nextLine();</span><br><span class="line">            String str2 = scanner.nextLine();</span><br><span class="line">            String str3 = scanner.nextLine();</span><br><span class="line">            String str4 = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            //判断前两个字符串哪一个最短</span><br><span class="line">            int daytime = shortest(str1, str2);</span><br><span class="line">            boolean isDay = true;//判断相同的字母是否是代表“天”</span><br><span class="line">            String result = &quot;&quot;;//结果字符串</span><br><span class="line">            int sum = 0; //前两个字符串中相同字母/数字的个数</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; daytime; i++)&#123;</span><br><span class="line">                if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInDay(str1.toCharArray()[i]) &amp;&amp; isDay)&#123;</span><br><span class="line">                    result += getDay(str1.toCharArray()[i]);</span><br><span class="line">                    /**</span><br><span class="line">                     * isDay有两个作用：</span><br><span class="line">                     * 一是防止下一次有字母出现时将字母当作成“天”的字母；</span><br><span class="line">                     * 二是供else if 中做判断，防止识别时间在识别周几之前</span><br><span class="line">                     */</span><br><span class="line">                    isDay = false;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;else if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInHour(str1.toCharArray()[i]) &amp;&amp; !isDay )&#123;</span><br><span class="line">                    //输出规范化，防止出现输出为 “THU 2:12”的情况</span><br><span class="line">                    if (getHour(str1.toCharArray()[i]) &lt; 10)&#123;</span><br><span class="line">                        result += &quot; 0&quot;+ getHour(str1.toCharArray()[i]);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        result += &quot; &quot;+ getHour(str1.toCharArray()[i]);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //防止已经识别周几和小时之后还有相同又符合判断条件的字母出现</span><br><span class="line">                if (sum == 2)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //获取str3，str4中最小的字符串长度</span><br><span class="line">            int minute = shortest(str3, str4);</span><br><span class="line">            for (int i = 0; i &lt; minute ; i++)&#123;</span><br><span class="line">                if (str3.toCharArray()[i] == str4.toCharArray()[i] &amp;&amp; isEnglishChar(str3.toCharArray()[i]))&#123;</span><br><span class="line">                    //输出规范化，与上同</span><br><span class="line">                    if (i &lt; 10 ) &#123;</span><br><span class="line">                        result += &quot;:0&quot; + i;</span><br><span class="line">                        break; //有相同的字母直接退出for循环</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        result += &quot;:&quot; + i;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //输出</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回两个字符串长度最小的字符串长度</span><br><span class="line">     * @param str1</span><br><span class="line">     * @param str2</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int shortest(String str1, String str2)&#123;</span><br><span class="line">        return str1.length() &lt; str2.length() ? str1.length() : str2.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 判断输入字符是否存在与day的数组中</span><br><span class="line">     * @param character</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isInDay(Character character)&#123;</span><br><span class="line">        for (int i = 0; i &lt; day.length; i++)&#123;</span><br><span class="line">            if (character == day[i])</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断输入字符是否存在与hour数组中</span><br><span class="line">     * @param character</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isInHour(Character character)&#123;</span><br><span class="line">        for (int i = 0; i &lt; hour.length; i++)&#123;</span><br><span class="line">            if (character == hour[i])</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据输入字符获取星期几的简写</span><br><span class="line">     * @param dayChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static String getDay(Character dayChar)&#123;</span><br><span class="line">        switch (dayChar)&#123;</span><br><span class="line">            case &apos;A&apos;:</span><br><span class="line">                return &quot;MON&quot;;</span><br><span class="line">            case &apos;B&apos;:</span><br><span class="line">                return &quot;TUE&quot;;</span><br><span class="line">            case &apos;C&apos;:</span><br><span class="line">                return &quot;WED&quot;;</span><br><span class="line">            case &apos;D&apos;:</span><br><span class="line">                return &quot;THU&quot;;</span><br><span class="line">            case &apos;E&apos;:</span><br><span class="line">                return &quot;FRI&quot;;</span><br><span class="line">            case &apos;F&apos;:</span><br><span class="line">                return &quot;SAT&quot;;</span><br><span class="line">            case &apos;G&apos;:</span><br><span class="line">                return &quot;SUN&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Not Found This Day&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据输入字符获取小时时间</span><br><span class="line">     * @param hourChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int getHour(Character hourChar)&#123;</span><br><span class="line">        for (int i = 0; i &lt; hour.length; i++)&#123;</span><br><span class="line">            if (hourChar == hour[i])</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断输入字符是否是一个英文字母（包含大小写）</span><br><span class="line">     * @param engChar</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static boolean isEnglishChar(Character engChar)&#123;</span><br><span class="line">        if (engChar &gt;= &apos;a&apos; &amp;&amp; engChar &lt;= &apos;z&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        else if(engChar &gt;= &apos;A&apos; &amp;&amp; engChar &lt;= &apos;Z&apos;)</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;amp;hgsfdk d&amp;amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="PAT" scheme="http://www.duanmuxu.top/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>往微信图文中插入外链视频的方法（包含几种失败方法）</title>
    <link href="http://www.duanmuxu.top/20190602/how-to-insert-an-external-video-into-a-wechat-graphic-including-several-failure-methods.html"/>
    <id>http://www.duanmuxu.top/20190602/how-to-insert-an-external-video-into-a-wechat-graphic-including-several-failure-methods.html</id>
    <published>2019-06-02T04:28:32.249Z</published>
    <updated>2019-06-02T04:31:29.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种不同方法"><a href="#几种不同方法" class="headerlink" title="几种不同方法"></a>几种不同方法</h1><h2 id="最常见方法"><a href="#最常见方法" class="headerlink" title="最常见方法"></a>最常见方法</h2><p>我们平时转发图文时，往往转发的图文中会带有视频，一般的解决方法就是在浏览器中打开<br>腾讯视频，找到原图文中的原视频，然后进行分享复制链接，</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/1.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>再把链接复制粘贴到后台视频链接的地方就会有视频显示出来</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/2.jpg" alt="在这里插入图片描述"></p><p>再点击确定就可以在图文中看见插入的视频了。<br>但是！！前几天在进行转发一篇图文中的视频时我发现了一个新的问题，有些视频点击分享时无法复制视频地址链接，怎么整都不行！<br>所以我先试了以下方法，但都<strong>无法实现</strong>！为了不让大家走弯路，我先把我用过的<strong>行不通</strong>的方法列出来。</p><h2 id="失败方法一："><a href="#失败方法一：" class="headerlink" title="失败方法一："></a>失败方法一：</h2><p>下载视频上传后台</p><p>该视频只有 57 秒，不足 <strong>20M</strong>（微信公众号后台要求上传的视频大小要小于20M），那我就下载腾讯视频客户端，再下载原视频，然后把视频上传到后台就行了呗，但是问题又出现了，腾讯视频的下载格式是<strong>qlv</strong>，公众号后台<strong>不支持该格式</strong>的视频。</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/3.jpg" alt="在这里插入图片描述"></p><p>不过问题不大，将原视频进行格式转换成 <strong>MP4</strong>，再上传到后台，还是美滋滋，但是问题又来了，格式工厂无法支持该格式，无法进行转换，那就从网上找吧，可是市面上的格式转换器（对我使用过的而言）转换后的 MP4 格式上传到后台后，公众号后台却无法解码，</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/4.jpg" alt="公众号后台转码失败"></p><p>因此视频还是无法成功上传，这条路，卒。</p><h2 id="利用windows-系统命令行对视频缓存的合成及转换"><a href="#利用windows-系统命令行对视频缓存的合成及转换" class="headerlink" title="利用windows 系统命令行对视频缓存的合成及转换"></a>利用windows 系统命令行对视频缓存的合成及转换</h2><p>我们每次在浏览器或是客户端进行视频查看时，系统会<strong>自动生成缓存</strong>保存在电脑中，下次查看视频时就会方便很多，因此我们先找到电脑本地视频缓存区，</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/5.jpg" alt="本地缓存目录"></p><p>腾讯视频将一整段完整的视频进行分段缓存，还都是<strong>ts</strong>的文件，这个格式第一次见，问题不<br>大，打开 <strong>cmd 命令行</strong>，使用 <strong>copy/b</strong> 命令进行分段视频的合成和转换，</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/6.jpg" alt="利用命令行进行合成"><br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/7.jpg" alt="合成并转换后的视频文件" title>                </div>                <div class="image-caption">合成并转换后的视频文件</div>            </figure></p><p>视频转换成功，美滋滋。可是问题又来了，点击打开只能在腾讯视频进行播放，其他视频软件出现解码错误（又是解码错误！！）</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/8.jpg" alt="迅雷影音播放画面"></p><p>而且腾讯视频里只有音频，没有视频图像，这条路，卒。</p><h2 id="检查网页元素进行视频捕捉和保存"><a href="#检查网页元素进行视频捕捉和保存" class="headerlink" title="检查网页元素进行视频捕捉和保存"></a>检查网页元素进行视频捕捉和保存</h2><p>知乎上的一个方法，利用浏览器播放视频，检查网页元素进行视频捕捉和保存 <a href="https://www.zhihu.com/question/23805794/answer/55527454" target="_blank" rel="noopener">如何下载网页上的视频？ - 习惯秋落的回答 - 知乎</a> 有兴趣的可以根据里面详细的介绍试一试</p><p><img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/9.jpg" alt="在这里插入图片描述"></p><p>当我开开心心地进行视频保存时，却发现保存的视频格式是<strong>ts</strong> 文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/10.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure><p>又是<strong>ts</strong>文件！！！这条路，卒。</p><h2 id="手机端UC浏览器进行视频保存"><a href="#手机端UC浏览器进行视频保存" class="headerlink" title="手机端UC浏览器进行视频保存"></a>手机端UC浏览器进行视频保存</h2><p>平时我们用<strong>手机 UC 浏览器</strong>进行看视频时，右上角会有一个下载视频的图标，我们可以进行视频下载，一般来说是 <strong>MP4</strong> 格式，但是前两天我在试验的时候那个图标不见了，我也就没有去深究。</p><h2 id="成功方法"><a href="#成功方法" class="headerlink" title="成功方法"></a>成功方法</h2><h3 id="查找浏览器视频元素"><a href="#查找浏览器视频元素" class="headerlink" title="查找浏览器视频元素"></a>查找浏览器视频元素</h3><p>既然团中央学校部的图文中可以播放该视频，那这篇<strong>图文的信息中肯定有该视频的信息</strong>，所以重点来啦，下面都是要记笔记的地方！<br>首先在浏览器中打开我们要转发的图文，我用的是谷歌浏览器，也建议大家使用。</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/11.jpg" alt="浏览器打开图文" title>                </div>                <div class="image-caption">浏览器打开图文</div>            </figure></p><p><br>然后打开网页检查元素，一种方法是<strong>右击鼠标，选择检查</strong>即可，另一种方法是 <strong>shift+ctrl+I快捷键</strong>进入检查</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/12.jpg" alt="进入检查页面" title>                </div>                <div class="image-caption">进入检查页面</div>            </figure></p><p><br>点击右边框框中的 <strong>element</strong> 元素 </p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/13.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>键入 <strong>ctrl+F</strong> 进行元素检索</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/14.jpg" alt="进行检索" title>                </div>                <div class="image-caption">进行检索</div>            </figure></p><p><br>搜索 <strong>v.qq.com</strong>,因为这个是所有腾讯视频链接中所包含的特定元素</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/15.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>此时网页自动找到页面中的视频元素（左半边），以及该视频的链接地址（右半边中的<strong>黄色部分</strong>所在区域），然后呢，我们有了该视频链接的总地址，此时我们复制 <strong>src=…后的部分，从 v.qq.com 一直到 false</strong></p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/16.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>然后将我们复制的这段链接再粘贴到后台</p><p><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/method-of-inserting-outer-chain-video-into-wechat-text-(including-several-failure-methods)/17.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure></p><p><br>以上就是从<strong>原图文找原视频链接地址</strong>的方法，十分简便，为什么我之前会试那么多复杂的方法！！</p><p><strong>当然如果腾讯视频可以直接复制视频地址链接，那就不要整这些花里胡哨的。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几种不同方法&quot;&gt;&lt;a href=&quot;#几种不同方法&quot; class=&quot;headerlink&quot; title=&quot;几种不同方法&quot;&gt;&lt;/a&gt;几种不同方法&lt;/h1&gt;&lt;h2 id=&quot;最常见方法&quot;&gt;&lt;a href=&quot;#最常见方法&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="新媒体运营" scheme="http://www.duanmuxu.top/categories/%E6%96%B0%E5%AA%92%E4%BD%93%E8%BF%90%E8%90%A5/"/>
    
    
      <category term="新媒体" scheme="http://www.duanmuxu.top/tags/%E6%96%B0%E5%AA%92%E4%BD%93/"/>
    
      <category term="视频" scheme="http://www.duanmuxu.top/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>使用MultipleOutputs方法将mapreduce分组输出</title>
    <link href="http://www.duanmuxu.top/20190602/mapreduce-group-output-using-the-multipleoutputs-method.html"/>
    <id>http://www.duanmuxu.top/20190602/mapreduce-group-output-using-the-multipleoutputs-method.html</id>
    <published>2019-06-02T04:28:32.247Z</published>
    <updated>2019-06-02T04:31:31.616Z</updated>
    
    <content type="html"><![CDATA[<p>MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-00000文件），那么我们如果需要将这一个输出文件分为多个输出文件该怎么办呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/mapreduce-grouping-output-using-multipleoutputs-method/1.jpg" alt="一个输出" title>                </div>                <div class="image-caption">一个输出</div>            </figure><p>这里就用到了MR框架中的MultipleOutputs函数（MultipleOutputs是2.0之后的新API，是对老版本中MultipleOutputs与MultipleOutputFormat的一个整合）。<br>先来看段完整代码熟悉一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class dateFormat &#123;</span><br><span class="line">    static class MyMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected void map(LongWritable key, Text value,Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;);</span><br><span class="line">            String time = simpleDateFormat.format(new Date());</span><br><span class="line">            String line = value.toString().trim();</span><br><span class="line">            for (int i =0; i&lt; line.length(); i++)&#123;</span><br><span class="line">                char newChar = line.charAt(i);</span><br><span class="line">                context.write(new Text(time), new Text(String.valueOf(newChar)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class MyReducer extends Reducer&lt;Text,Text,Text,Text&gt;&#123;</span><br><span class="line">        private MultipleOutputs&lt;Text, Text&gt; multipleOutputs;</span><br><span class="line"></span><br><span class="line">        protected void setup(Context context)&#123;</span><br><span class="line">            multipleOutputs = new MultipleOutputs&lt;Text, Text&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        protected void reduce(Text key, Iterable&lt;Text&gt; values,Context context)throws IOException, InterruptedException &#123;</span><br><span class="line">            for (Text value : values) &#123;</span><br><span class="line">                multipleOutputs.write((Text) null, value, key.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        protected void cleanup(Context context) throws IOException, InterruptedException&#123;</span><br><span class="line">            multipleOutputs.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123;</span><br><span class="line">        Configuration conf = new Configuration();</span><br><span class="line">        Job job = Job.getInstance(conf);</span><br><span class="line">        job.setJarByClass(dateFormat.class);</span><br><span class="line"></span><br><span class="line">        job.setJobName(&quot;MultipleOutputTest&quot;);</span><br><span class="line"></span><br><span class="line">        job.setMapperClass(MyMapper.class);</span><br><span class="line">        job.setReducerClass(MyReducer.class);</span><br><span class="line"></span><br><span class="line">        job.setMapOutputKeyClass(Text.class);</span><br><span class="line">        job.setMapOutputValueClass(Text.class);</span><br><span class="line"></span><br><span class="line">        job.setOutputKeyClass(NullWritable.class);</span><br><span class="line">        job.setOutputValueClass(Text.class);</span><br><span class="line">//      MultipleOutputs.addNamedOutput(job, TextOutputFormat.class, NullWritable.class, Text.class);</span><br><span class="line">        FileInputFormat.setInputPaths(job, new Path(args[0]));</span><br><span class="line">        Path outPath = new Path(args[1]);</span><br><span class="line">        FileSystem fs = FileSystem.get(conf);</span><br><span class="line">        if(fs.exists(outPath)) &#123;</span><br><span class="line">            fs.delete(outPath, true);</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputFormat.setOutputPath(job, outPath);</span><br><span class="line"></span><br><span class="line">        job.waitForCompletion(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>multipleOutputs.write的输出规范如下：<br><strong>multipleOutputs.write((namedOutput,) key, value, baseOutputPath)</strong><br>这里需要注意的一点在是map中的输出值会作为reduce中输出文件的文件命名（<em>map.key</em>-r-00000），即<strong>baseOutputPath</strong>的值确定了分组输出文件的命名规范。</p><p><strong>namedOutput</strong>为可选项，为当前输出Job的名称，如果有多于一个multipleOutputs.write时，需指定namedOutput名称，并在Driver里添加 <strong>MultipleOutputs.addNamedOutput(job,</strong> <strong>“namedOutput”</strong> , <strong>TextOutputFormat.class, NullWritable.class, Text.class)</strong>;作为作业的入口。</p><p>上述的代码段是我根据获取系统时间作为reducer的输入key值，命名时也根据map的执行时间进行命名，输出到同一文件夹之下，具体结果如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/mapreduce-grouping-output-using-multipleoutputs-method/2.jpg" alt="分组输出到同一文件下" title>                </div>                <div class="image-caption">分组输出到同一文件下</div>            </figure><p>如果需要将这些文件分别输出到不同的文件夹下，那么只需要将 multipleOutputs.write((Text) null, value, key.toString());中的key.toString()改为key+”/“,即改为<strong>multipleOutputs.write((Text) null, value, key+”/“)</strong>; 即可，输出结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/mapreduce-grouping-output-using-multipleoutputs-method/3.jpg" alt="分组输出到不同文件夹下" title>                </div>                <div class="image-caption">分组输出到不同文件夹下</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://www.duanmuxu.top/tags/Hadoop/"/>
    
      <category term="Map Reduce" scheme="http://www.duanmuxu.top/tags/Map-Reduce/"/>
    
  </entry>
  
  <entry>
    <title>只爱一点点</title>
    <link href="http://www.duanmuxu.top/20190602/just-love-a-little-bit.html"/>
    <id>http://www.duanmuxu.top/20190602/just-love-a-little-bit.html</id>
    <published>2019-06-02T04:28:32.246Z</published>
    <updated>2019-06-02T04:30:52.443Z</updated>
    
    <content type="html"><![CDATA[<p>不爱那么多，<br>只爱一点点。<br>别人的爱情像海深，<br>我的爱情浅。<br>不爱那么多，<br>只爱一点点。<br>别人的爱情像天长，<br>我的爱情短。<br>不爱那么多，<br>只爱一点点。<br>别人眉来又眼去，<br>我只偷看你一眼。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/just-love-a-little/1.jpg" alt="在这里插入图片描述" title>                </div>                <div class="image-caption">在这里插入图片描述</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人的爱情像海深，&lt;br&gt;我的爱情浅。&lt;br&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人的爱情像天长，&lt;br&gt;我的爱情短。&lt;br&gt;不爱那么多，&lt;br&gt;只爱一点点。&lt;br&gt;别人眉来又眼去，&lt;br&gt;我只偷看你一眼。&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.duanmuxu.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="现代诗" scheme="http://www.duanmuxu.top/tags/%E7%8E%B0%E4%BB%A3%E8%AF%97/"/>
    
  </entry>
  
  <entry>
    <title>Java实现从尾到头打印链表（ListNode）每个节点的值</title>
    <link href="http://www.duanmuxu.top/20190602/java-implementation-prints-the-value-of-each-node-from-end-to-linked-list-listnode.html"/>
    <id>http://www.duanmuxu.top/20190602/java-implementation-prints-the-value-of-each-node-from-end-to-linked-list-listnode.html</id>
    <published>2019-06-02T04:28:32.243Z</published>
    <updated>2019-06-02T04:30:52.392Z</updated>
    
    <content type="html"><![CDATA[<p>进行做题之前，先来看看什么是ListNode。</p><blockquote><p>ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode</span><br><span class="line">&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    </span><br><span class="line">    public ListNode(int x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>val表示当前ListNode的值，next指向下一个ListNode。在进行ListNode<strong>初始化时必须传值</strong>，如下面main函数中进行初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ListNode listNode = new ListNode(1);</span><br><span class="line">listNode.next = new ListNode(3);</span><br><span class="line">listNode.next.next = new ListNode(4);</span><br><span class="line">listNode.next.next.next = new ListNode(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时生成链表：1-&gt;3-&gt;4-&gt;1</p><hr><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</span><br></pre></td></tr></table></figure><h3 id="方法一：利用栈的思想"><a href="#方法一：利用栈的思想" class="headerlink" title="方法一：利用栈的思想"></a>方法一：利用栈的思想</h3><p>一个链表从头到尾输入，要求输出的是从尾到头。符合栈<strong>先进后出</strong>的思想，因此可以用下面方法实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">while (listNode != null) &#123;</span><br><span class="line">stack.push(listNode.val);</span><br><span class="line">listNode = listNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; arrayList  = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">arrayList.add(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      return arrayList;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList  = new ArrayList&lt;Integer&gt;();</span><br><span class="line">if (listNode != null) &#123;</span><br><span class="line">arrayList.addAll(printListFromTailToHead(listNode.next));</span><br><span class="line">arrayList.add(listNode.val);</span><br><span class="line">&#125;</span><br><span class="line">return arrayList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下addAll()和all()的区别：</p><blockquote><p>add（）是将传入的的参数作为当前 List 中d的一个项目（Item）来存储，即使你传入一个 list 也只会另当前的List集合增加 1 个元素。<br><br><br>addAll（）是传入一个List，将此前List集合中的所有元素加入到当前的 List 中，当前 List 集合会增加的元素个数是传入的 List 的大小。</p></blockquote><h3 id="方法三：头插法"><a href="#方法三：头插法" class="headerlink" title="方法三：头插法"></a>方法三：头插法</h3><p>利用链表头插法为逆序的特点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ListNode head = new ListNode(-1);</span><br><span class="line">while (listNode != null) &#123;</span><br><span class="line">ListNode q = listNode.next;</span><br><span class="line">listNode.next = head.next;</span><br><span class="line">head.next = listNode;</span><br><span class="line">listNode = q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">head = head.next;</span><br><span class="line">while (head != null) &#123;</span><br><span class="line">arrayList.add(head.val);</span><br><span class="line">head = head.next;</span><br><span class="line">&#125;</span><br><span class="line">return arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法四：链表翻转"><a href="#方法四：链表翻转" class="headerlink" title="方法四：链表翻转"></a>方法四：链表翻转</h3><ul><li>利用函数：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    while(listNode != null)&#123;</span><br><span class="line">        list.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Collections.reverse(list);//使用Collections的reverse方法，直接将list反转</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>强行进行逆序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if(listNode == null)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    while(listNode.next != null)&#123;</span><br><span class="line">        arr.add(listNode.val);</span><br><span class="line">        listNode = listNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.add(listNode.val);</span><br><span class="line">    int temp = 0;</span><br><span class="line">    for(int inx=0, end=arr.size()-1; inx&lt;end; inx++, end--)&#123;</span><br><span class="line">        temp = arr.get(inx);</span><br><span class="line">        arr.set(inx, arr.get(end));</span><br><span class="line">        arr.set(end, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进行做题之前，先来看看什么是ListNode。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;f
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找二叉树的下一个节点（中序遍历）</title>
    <link href="http://www.duanmuxu.top/20190602/find-the-next-node-of-binary-tree-middle-order-traversal.html"/>
    <id>http://www.duanmuxu.top/20190602/find-the-next-node-of-binary-tree-middle-order-traversal.html</id>
    <published>2019-06-02T04:28:32.229Z</published>
    <updated>2019-06-02T04:30:52.508Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们先了解一下二叉树的三种遍历方法：</p><ul><li>前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；</li><li>中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面；</li><li>后序遍历：也是从最左节点开始，根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面。</li></ul><p>比如下面一张图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/find-the-next-node-of-the-binary-tree-(intermediate-traversal)/1.jpg" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><ul><li>前序遍历为：ABDGHECKFIJ</li><li>中序遍历为：GDHBEAKCIJF</li><li>后序遍历为：GHDEBKJIFCA</li></ul><p>了解了二叉树的大致遍历方式，我们来看下题目：</p><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><p>通过中序遍历我们可以知道一个节点的下一个节点有两种情况：</p><ul><li>如果一个节点的右子树不为空，那么该节点的下一个节点是<strong>右子树的最左节点</strong>，比如上图中C的后一个节点是I；</li><li>如果一个节点的右子树为空，那么向上找<strong>第一个左链接</strong>指向的树包含该节点的<strong>父节点</strong>。比如上图H的下一个节点是B。</li></ul><p>接下来看代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 定义一棵树</span><br><span class="line"></span><br><span class="line">public class TreeLinkNode &#123;</span><br><span class="line"></span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode next = null;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">    &#123;</span><br><span class="line">        //判断该节点是否存在右子节点</span><br><span class="line">        if(pNode.right != null)&#123;</span><br><span class="line">        //如果有右子树，则找右子树的最左节点</span><br><span class="line">            TreeLinkNode rightNode = pNode.right;</span><br><span class="line">            while(rightNode.left != null)</span><br><span class="line">                rightNode = rightNode.left;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        //没右子树，则找第一个当前节点是父节点左孩子的节点</span><br><span class="line">            while(pNode.next != null)&#123;</span><br><span class="line">                TreeLinkNode parentNode = pNode.next;</span><br><span class="line">                if(parentNode.left == pNode)</span><br><span class="line">                    return parentNode;</span><br><span class="line">                pNode = pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们先了解一下二叉树的三种遍历方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面；&lt;/li&gt;
&lt;li&gt;中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer中关于斐波那契数列的分析和运用</title>
    <link href="http://www.duanmuxu.top/20190602/analysis-and-application-of-the-fibonacci-sequence-in-sword.html"/>
    <id>http://www.duanmuxu.top/20190602/analysis-and-application-of-the-fibonacci-sequence-in-sword.html</id>
    <published>2019-06-02T04:28:32.227Z</published>
    <updated>2019-06-02T04:30:52.476Z</updated>
    
    <content type="html"><![CDATA[<p>我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。</p><blockquote><p>斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）<br>——《百度百科》</p></blockquote><p>具体函数表达参考下面这张图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/1.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><h4 id="那么我们该如何求解与斐波那契数列相关的问题呢？"><a href="#那么我们该如何求解与斐波那契数列相关的问题呢？" class="headerlink" title="那么我们该如何求解与斐波那契数列相关的问题呢？"></a>那么我们该如何求解与斐波那契数列相关的问题呢？</h4><p>先看一下题目描述：</p><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p></blockquote><p>具体可以用以下几种方法求解：</p><h5 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h5><p>递归能将一个问题划分成多个子问题进行求解。求F(n)时会转化成求F(n-1)、F(n-2),以此类推，最后转化成几个F(0)、F(1)相加的结果。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result = Fibonacci(n - 1) + Fibonacci(n - 2);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/2.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>可是使用递归会有一个问题，会重复计算一些子问题。比如计算F(5)需要计算F(4)和F(3)，计算F(4)需要计算F(3)和F(2)，可以看到F(3)被重复计算了。造成了资源浪费。</p><p>所以我们换个思路。</p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>递归是将一个问题划分成多个子问题进行求解。动态规划相当于是个相反的过程，将子问题的解存储起来，用来解决大问题，比如已知F(0)、F(1)，进行求F(2)，再进一步求F(3)，以此类推，直至求到F(n)。这样子就不会有重复求解子问题的烦恼产生。<br>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int[] fib = new int[n+1];</span><br><span class="line">        fib[0] = 0;</span><br><span class="line">        fib[1] = 1;</span><br><span class="line">        for(int i = 2;i &lt; n + 1; i++)&#123;</span><br><span class="line">            fib[i] = fib[i - 1] + fib[i - 2];</span><br><span class="line">        &#125;</span><br><span class="line">        return fib[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/3.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><p>这么做比递归好很多，但是考虑到第i项只与第i-1和第i-2项有关，因此只需要存储前两项的值就能求解第i项，从而将空间复杂度由O(N)降低为O(1)。所以我们可以进一步优化。</p><h5 id="动态规划的进一步优化"><a href="#动态规划的进一步优化" class="headerlink" title="动态规划的进一步优化"></a>动态规划的进一步优化</h5><p>使用两个值存储i-1和i-2，避免使用数组，浪费更多的空间。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        if (n &lt;= 1)&#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne = 1; //存储i-1</span><br><span class="line">        int preTwo = 0; //存储i-2</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 2;i &lt; n + 1; i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间与占用内存如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/4.jpg" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure></p><hr><p>接下来我们来看看剑指Offer中其他关于斐波那契数列的运用的题目：</p><h6 id="题目一：跳台阶"><a href="#题目一：跳台阶" class="headerlink" title="题目一：跳台阶"></a>题目一：跳台阶</h6><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p>简单分析一下，就可以知道还是上面斐波那契数列的变化，青蛙跳1级台阶有1种跳法，2级台阶有2种跳法，3级台阶时可以从1级台阶跳上来也可以从2级台阶跳上来，即等于1级台阶的跳法加2级台阶的跳法因此n级台阶共有n-2级台阶跳法数+n-1级台阶跳法数。</p><p>实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)</span><br><span class="line">            return target;</span><br><span class="line"></span><br><span class="line">        int preOne = 2;</span><br><span class="line">        int preTwo = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target+1 ;i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="题目二：变态跳台阶"><a href="#题目二：变态跳台阶" class="headerlink" title="题目二：变态跳台阶"></a>题目二：变态跳台阶</h6><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p></blockquote><p>上一题的升级版，跳n级台阶时可以允许跳1~n任意阶级的台阶。<br><br>先来分析一下</p><ul><li>跳n级台阶，那么第一步有n种跳法：跳1级、跳2级、到跳n级</li><li>跳1级，剩下n-1级，则剩下跳法是F(n-1)；</li><li>跳2级，剩下n-2级，则剩下跳法是F(n-2)；</li><li>所以F(n)=F(n-1)+F(n-2)+…+F(1)+1，最后的+1是因为直接跳n级台阶只有一种方法；</li><li>因为F(n-1)=F(n-2)+F(n-3)+…+F(1)+1;</li><li>以此类推，得F(n)=2*F(n-1)。</li></ul><p>分析后变得比上面一提还要简单。实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)&#123;</span><br><span class="line">            return target;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int preNum = 2;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target + 1;i++)&#123;</span><br><span class="line">            result = 2 * preNum;</span><br><span class="line">            preNum = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="题目三：矩阵覆盖"><a href="#题目三：矩阵覆盖" class="headerlink" title="题目三：矩阵覆盖"></a>题目三：矩阵覆盖</h6><blockquote><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p></blockquote><p>再来分析一下</p><ul><li>首先从n=1开始，小矩阵只能竖着放，只有一种方法；</li><li>n=2时，大矩阵为2 * 2，小矩阵既可以竖着放也可以横着放，有两种方法；</li><li>当n越来越大时，如果第一步选择竖着放，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/5.jpg" alt="第一步：竖着放" title>                </div>                <div class="image-caption">第一步：竖着放</div>            </figure>那么大矩阵的规模缩小成2 * (n-1)；</li><li>如果第一步选择竖着放，那么第二排也只能横着放，如下图：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/analysis-and-application-of-fibonacci-sequence-in-sword-finger-offer/6.jpg" alt="第一步：横着放" title>                </div>                <div class="image-caption">第一步：横着放</div>            </figure>那么大矩阵的规模缩小成2 * (n-2)；</li><li>因此，题目又转化成了与题目一一样的斐波那契数列了。<br>实现如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        if(target &lt;= 2)</span><br><span class="line">            return target;</span><br><span class="line"></span><br><span class="line">        int preOne = 2;</span><br><span class="line">        int preTwo = 1;</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 3;i &lt; target+1 ;i++)&#123;</span><br><span class="line">            result = preOne + preTwo;</span><br><span class="line">            preTwo = preOne;</span><br><span class="line">            preOne = result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上就是关于斐波那契数列的含义和使用方式，题目一二三都是剑指Offer中的真题，示例中关于运行时间和占用内存是根据牛客网的测试用例得来的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://www.duanmuxu.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="http://www.duanmuxu.top/tags/%E5%89%91%E6%8C%87Offer/"/>
    
      <category term="数据结构" scheme="http://www.duanmuxu.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://www.duanmuxu.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Storm学习01：Storm简介</title>
    <link href="http://www.duanmuxu.top/20190602/storm-learning-01-introduction-to.html"/>
    <id>http://www.duanmuxu.top/20190602/storm-learning-01-introduction-to.html</id>
    <published>2019-06-02T04:28:32.198Z</published>
    <updated>2019-06-11T10:16:20.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Storm"><a href="#什么是Storm" class="headerlink" title="什么是Storm"></a>什么是Storm</h1><p>Apache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批处理相类似，Storm可以对大量的数据流进行可靠的实时处理，这一过程也称为“流式处理”，是分布式大数据处理的一个重要方向。Storm支持多种类型的应用，包括：实时分析、在线机器学习、连续计算、分布式 RPC（ DRPC）、ETL等。Strom的一个重要特点就是“快速”的数据处理，有benchmark示显示Storm级能够达到单个节点每秒百万级tuple处理（tuple是Storm的最小数据单元）的速度。快速的数据是处理、优秀的可扩展性与容错性、便捷的可操作性与维护性、活跃的社区技术支持，这就是 Storm 。</p><hr><h1 id="Hadoop与Storm的比较"><a href="#Hadoop与Storm的比较" class="headerlink" title="Hadoop与Storm的比较"></a>Hadoop与Storm的比较</h1><h3 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h3><table><thead><tr><th></th><th>Hadoop</th><th>Storm</th></tr></thead><tbody><tr><td>系统角色</td><td>JobTracker</td><td>Nimbus</td></tr><tr><td></td><td>TaskTracker</td><td>Supervisor</td></tr><tr><td></td><td>Child</td><td>Worker</td></tr><tr><td>应用名称</td><td>Job</td><td>Topology</td></tr><tr><td>组件接口</td><td>Mapper/Reducer</td><td>Spout/Bolt</td></tr><tr><td>- <strong>Nimbus</strong>：Nimbus在Storm中用于资源分配和作业调度，类比Hadoop中的Job Tracker</td><td></td><td></td></tr><tr><td>- <strong>Supervisor</strong>：Supervisor在Storm中用于接收Nimbus分配的任务，并且启动和停止用于完成这些任务对的Worker进程。Supervisor类比Hadoop中的TaskTracker</td><td></td><td></td></tr><tr><td>- <strong>Worker</strong>：运行Storm中具体组件逻辑的进程。这里的组件指的是Spout或者Bolt，对比Hadoop.x的Child进程。</td><td></td><td></td></tr><tr><td>- <strong>Topology</strong>：Topology是Storm中运行的一个任务，类比Hadoop.x中的一个作业（Job）</td><td></td><td></td></tr><tr><td>- <strong>Spout</strong>：在一个Topology中产生源数据流的组件</td><td></td><td></td></tr><tr><td>- <strong>Bolt</strong>：在一个Topology中接收数据，并进行逻辑处理的组件，称为Transformation</td><td></td><td></td></tr></tbody></table><h3 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h3><table><thead><tr><th></th><th>Hadoop</th><th>Storm</th></tr></thead><tbody><tr><td>数据来源</td><td>Hadoop处理的是HDFS上TB级别的数据（历史数据）</td><td>Storm处理的是实时新增的某一笔数据（实时数据）</td></tr><tr><td>处理过程</td><td>Hadoop是分Map阶段和Reduce阶段</td><td>Storm是由用户定义处理流程，流程中可以包含多个步骤，每个步骤可以是数据源（Spout）或处理逻辑（Bolt）</td></tr><tr><td>是否结束</td><td>Hadoop最后是要结束的</td><td>Storm没有结束状态，到最后一步时，就停在那，直到有新数据进入时再从头开始</td></tr><tr><td>处理速度</td><td>Hadoop是以处理HDFS上大量数据为目的的，处理速度慢</td><td>Storm是只要处理新增的某一笔数据即可，可以做到很快</td></tr><tr><td>适用场景</td><td>Hadoop是在要处理批量数据时用的，不讲究时效性</td><td>Storm是要处理某一新增数据时使用的，讲究时效性</td></tr></tbody></table><p>ps：在Hadoop集群上运行MapReduce jobs，在Storm集群上运行topologies。jobs和topologies有很大的不同。一个关键区别是：一个Map Reduce jobs最终可以完成，而topologies处理过程将永远执行（除非Kill it）</p><hr><h1 id="Storm组件"><a href="#Storm组件" class="headerlink" title="Storm组件"></a>Storm组件</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20190611162336868.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="image" title>                </div>                <div class="image-caption">image</div>            </figure><h5 id="Storm集群中包含两类节点：主控节点（Master-Node）和工作节点（Work-Node）"><a href="#Storm集群中包含两类节点：主控节点（Master-Node）和工作节点（Work-Node）" class="headerlink" title="Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node）"></a>Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node）</h5><ul><li>主控节点上运行着Nimbus，负责在Storm集群内分发代码，分配任务给工作机器，并且负责监控集群运行状态</li><li>工作节点上运行着Supervisor，负责监听从Nimbus分配给它执行的任务，据此启动或停止任务的工作进程。</li><li><strong>每一个工作进程执行一个Topology的子集；一个运行中的Topology由分布在不同工作节点上的多个工作进程组成。</strong></li><li>Nimbus 和和 Supervisor节点之间所有的协调工作是通过<strong>Zookeeper集群</strong>来实现的。此外，Nimbus 和Supervisor进程都是<strong>快速失败（fail-fast)</strong> 和 <strong>无状态（stateless）</strong> 的；<strong>Storm集群所有的状态要么在Zookeeper集群中，要么存储在本地磁盘上</strong>。这意味着我们可以用kill-9来杀死Nimbus和Supervisor进程，它们在重启后可以继续工作。这个设计使得Storm集群拥有极强的<strong>稳定性</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Storm&quot;&gt;&lt;a href=&quot;#什么是Storm&quot; class=&quot;headerlink&quot; title=&quot;什么是Storm&quot;&gt;&lt;/a&gt;什么是Storm&lt;/h1&gt;&lt;p&gt;Apache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批
      
    
    </summary>
    
      <category term="大数据" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Storm/"/>
    
    
      <category term="大数据" scheme="http://www.duanmuxu.top/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Storm" scheme="http://www.duanmuxu.top/tags/Storm/"/>
    
  </entry>
  
</feed>
