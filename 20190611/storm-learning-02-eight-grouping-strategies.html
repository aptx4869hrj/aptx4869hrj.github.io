<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Storm学习02：八种grouping分组策略 | 端木胥的个人博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="大数据,Storm">
    <meta name="description" content="简述为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。 在 Storm 中有八种内置的数据流分组方式，而且还可以通过 CustomStreamGrouping接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式） 具体分组这八种分组分时分别为：   Shuffle grouping：随机分组。这种">
<meta name="keywords" content="大数据,Storm">
<meta property="og:type" content="article">
<meta property="og:title" content="Storm学习02：八种grouping分组策略">
<meta property="og:url" content="http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html">
<meta property="og:site_name" content="端木胥的个人博客">
<meta property="og:description" content="简述为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。 在 Storm 中有八种内置的数据流分组方式，而且还可以通过 CustomStreamGrouping接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式） 具体分组这八种分组分时分别为：   Shuffle grouping：随机分组。这种">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190611161427796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190611161449921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190611161502207.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2019061116151598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-06-11T08:28:15.164Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Storm学习02：八种grouping分组策略">
<meta name="twitter:description" content="简述为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。 在 Storm 中有八种内置的数据流分组方式，而且还可以通过 CustomStreamGrouping接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式） 具体分组这八种分组分时分别为：   Shuffle grouping：随机分组。这种">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190611161427796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70">
    
        <link rel="alternate" type="application/atom+xml" title="端木胥的个人博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/logo.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">端木胥</h5>
          <a href="mailto:157170555@qq.com" title="157170555@qq.com" class="mail">157170555@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags">
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/aptx4869hrj" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/3454630080" target="_blank">
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Storm学习02：八种grouping分组策略</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Storm学习02：八种grouping分组策略</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-06-11T08:24:43.140Z" itemprop="datePublished" class="page-time">
  2019-06-11
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/大数据/">大数据</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/大数据/Storm/">Storm</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简述"><span class="post-toc-number">1.</span> <span class="post-toc-text">简述</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#具体分组"><span class="post-toc-number">2.</span> <span class="post-toc-text">具体分组</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#实例"><span class="post-toc-number">3.</span> <span class="post-toc-text">实例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#新建wordcount项目"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">新建wordcount项目</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#新建RandomSentenceSpout类来产生数据"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">新建RandomSentenceSpout类来产生数据</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#新建SplitSentenceBolt类用来切割单词"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">新建SplitSentenceBolt类用来切割单词</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#新建WordCountBolt类用来单词计数"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">新建WordCountBolt类用来单词计数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#新建WordCountTopology类用来链接Spout和Bolt，执行主程序"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">新建WordCountTopology类用来链接Spout和Bolt，执行主程序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#运行结果"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">运行结果</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#shuffleGrouping运行结果"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">shuffleGrouping运行结果</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#globalGrouping运行结果"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">globalGrouping运行结果</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#allGrouping运行结果"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">allGrouping运行结果</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#fieldsGrouping运行结果"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">fieldsGrouping运行结果</span></a></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Storm学习02：八种grouping分组策略" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Storm学习02：八种grouping分组策略</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-06-11 16:24:43" datetime="2019-06-11T08:24:43.140Z" itemprop="datePublished">2019-06-11</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/大数据/">大数据</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/大数据/Storm/">Storm</a></li></ul></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>为拓扑中的每个 Bolt 的<strong>确定输入数据流</strong>是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。</p>
<p>在 Storm 中有八种内置的数据流分组方式，而且还可以通过 <strong>CustomStreamGrouping</strong>接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式）</p>
<h2 id="具体分组"><a href="#具体分组" class="headerlink" title="具体分组"></a>具体分组</h2><p>这八种分组分时分别为：</p>
<hr>
<ul>
<li>Shuffle grouping：随机分组。这种方式下元组会被尽可能随机地分配到Bolt的不同任务（tasks）中，使得每个任务所处理元组数量能够保持基本一致，以确保集群的负载均衡。</li>
<li>Fields grouping：按字段分组。这种方式下数据流根据定义的Field来进行分组。比如，如果某个数据流是基于一个名为“user-id”的字段进行分组的，那么所有包含相同的“user-id”的tuple都会被分配到同一个任务中，这样就可以确保消息处理的一致性。</li>
<li>Partial Key grouping：部分关键字分组。这种方式与Fields grouping很相似，根据定义的域来对数据流进行分组，不同的是，这种方式会考虑下游Bolt数据处理的均衡性问题，在<strong>输入数据源关键字不平衡</strong>时会有更好的性能。</li>
<li>All grouping：完全分组。这种方式下数据流会被同时发送到Bolt的所有任务中（也就是说同一个元组会被复制多份然后被所有的任务处理），使用这种分组方式要特别小心。</li>
<li>Global grouping：全局分组。这种方式下所有的数据流都会被发送到 Bolt 的同一个任务中，也就是id最小的那个任务。</li>
<li>None grouping：无分组。使用这种方式说明你不关心数据流如何分组。目前这种方式的结果与随机分组完全等效，不过未来Storm社区可能会考虑通过非分组方式来让 Bolt 和它所订阅的 Spout 或 Bolt 在同一个线程中执行。</li>
<li>Direct grouping：直接分组。这是一种特殊的分组方式。使用这种方式意味着元组的发送者可以指定下游的哪个任务可以接收这个元组。只有在数据流被声明为直接数据流时才能够使用直接分组方式。使用直接数据流发送元组需要使用OutputCollector的其中一个emitDirect方法。Bolt可以通过TopologyContext来获取它的下游消费者的任务id，也可以通过跟踪OutputCollector的emit方法（该方法会返回它所发送元组的目标任务的id）的数据来获取任务 id。</li>
<li>Local or shuffle grouping：本地或随机分组。如果目标bolt有一个或者多个task与源bolt的task在同一个工作进程中，tuple将会被随机发送给这些同进程中的tasks。否则，和普通的Shuffle Grouping行为一致。</li>
</ul>
<hr>
<p>其中Shuffle grouping、Fields grouping、All grouping、Global grouping四种策略用得较多。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>拿最简单的WordCount来做例子：</p>
<h3 id="新建wordcount项目"><a href="#新建wordcount项目" class="headerlink" title="新建wordcount项目"></a>新建wordcount项目</h3><h4 id="新建RandomSentenceSpout类来产生数据"><a href="#新建RandomSentenceSpout类来产生数据" class="headerlink" title="新建RandomSentenceSpout类来产生数据"></a>新建RandomSentenceSpout类来产生数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.spout.SpoutOutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichSpout;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">public class RandomSentenceSpout extends BaseRichSpout &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 6102239192526611945L;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(RandomSentenceSpout.class);</span><br><span class="line"></span><br><span class="line">    private SpoutOutputCollector collector;</span><br><span class="line">    private Random random;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此open方法,</span><br><span class="line">     * 一般都会在此方法中对发送Tuple的对象SpoutOutputCollector和配置对象TopologyContext初始化</span><br><span class="line">     */</span><br><span class="line">    public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">        this.random = new Random();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个spout类，之前说过，最终会运行在task中，某个worker进程的某个executor线程内部的某个task中</span><br><span class="line">     * 那个task会负责去不断的无限循环调用nextTuple()方法</span><br><span class="line">     * 只要的话呢，无限循环调用，可以不断发射最新的数据出去，形成一个数据流</span><br><span class="line">     */</span><br><span class="line">    public void nextTuple() &#123;</span><br><span class="line">        String[] sentences = new String[]&#123;</span><br><span class="line">                &quot;I used to watch her from my kitchen widow&quot;</span><br><span class="line">                , &quot;she seemed so small as she muscled her way through the crowd of boys on the playground&quot;</span><br><span class="line">                , &quot;The school was across the street from our home and I would often watch the kids as they played during recess&quot;</span><br><span class="line">                , &quot;A sea of children, and yet tome&quot;</span><br><span class="line">                , &quot;she stood out from them all&quot;&#125;;</span><br><span class="line">        String sentence = sentences[random.nextInt(sentences.length)];</span><br><span class="line">        LOGGER.info(&quot;  --- 发射 sentence 数据 ---&gt; &#123;&#125;&quot;, sentence);</span><br><span class="line">        // 这个values，你可以认为就是构建一个tuple,tuple是最小的数据单位，无限个tuple组成的流就是一个stream,通过 emit 发送数据到下游bolt tuple</span><br><span class="line">        this.collector.emit(new Values(sentence));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前Spout的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游</span><br><span class="line">     bolt 中 execute 接收数据 key</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;sentence&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新建SplitSentenceBolt类用来切割单词"><a href="#新建SplitSentenceBolt类用来切割单词" class="headerlink" title="新建SplitSentenceBolt类用来切割单词"></a>新建SplitSentenceBolt类用来切割单词</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.task.OutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Tuple;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class SplitSentenceBolt extends BaseRichBolt &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -4758047349803579486L;</span><br><span class="line"></span><br><span class="line">    private OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法</span><br><span class="line">     * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化</span><br><span class="line">     */</span><br><span class="line">    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的</span><br><span class="line">     * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行</span><br><span class="line">     * 切分单词</span><br><span class="line">     */</span><br><span class="line">    public void execute(Tuple input) &#123;</span><br><span class="line">        // 接收上游数据</span><br><span class="line">        String sentence = input.getStringByField(&quot;sentence&quot;);</span><br><span class="line">        String[] words = sentence.split(&quot; &quot;);</span><br><span class="line">        for(String word : words)&#123;</span><br><span class="line">            //发射数据</span><br><span class="line">            this.collector.emit(new Values(word));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key</span><br><span class="line">     * 定义发射出去的tuple，每个field的名称</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;word&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新建WordCountBolt类用来单词计数"><a href="#新建WordCountBolt类用来单词计数" class="headerlink" title="新建WordCountBolt类用来单词计数"></a>新建WordCountBolt类用来单词计数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.shade.com.google.common.collect.Maps;</span><br><span class="line">import org.apache.storm.task.OutputCollector;</span><br><span class="line">import org.apache.storm.task.TopologyContext;</span><br><span class="line">import org.apache.storm.topology.OutputFieldsDeclarer;</span><br><span class="line">import org.apache.storm.topology.base.BaseRichBolt;</span><br><span class="line">import org.apache.storm.tuple.Fields;</span><br><span class="line">import org.apache.storm.tuple.Tuple;</span><br><span class="line">import org.apache.storm.tuple.Values;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class WordCountBolt extends BaseRichBolt &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger LOGGER = LoggerFactory.getLogger(WordCountBolt.class);</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = -7114915627898482737L;</span><br><span class="line"></span><br><span class="line">    private OutputCollector collector;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Long&gt; countMap = Maps.newConcurrentMap();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法</span><br><span class="line">     * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化</span><br><span class="line">     */</span><br><span class="line">    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123;</span><br><span class="line">        this.collector = collector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的</span><br><span class="line">     * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行</span><br><span class="line">     * 统计单词</span><br><span class="line">     */</span><br><span class="line">    public void execute(Tuple input) &#123;</span><br><span class="line">        // 接收上游数据</span><br><span class="line">        String word = input.getStringByField(&quot;word&quot;);</span><br><span class="line">        Long count = countMap.get(word);</span><br><span class="line">        if(null == count)&#123;</span><br><span class="line">            count = 0L;</span><br><span class="line">        &#125;</span><br><span class="line">        count ++;</span><br><span class="line">        countMap.put(word, count);</span><br><span class="line">        LOGGER.info(&quot; ---  单词计数[&#123;&#125;] ---&gt; 出现的次数：&#123;&#125;&quot;, word, count);</span><br><span class="line">        //发射数据</span><br><span class="line">        this.collector.emit(new Values(word,count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的</span><br><span class="line">     * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key</span><br><span class="line">     * 定义发射出去的tuple，每个field的名称</span><br><span class="line">     */</span><br><span class="line">    public void declareOutputFields(OutputFieldsDeclarer declarer) &#123;</span><br><span class="line">        declarer.declare(new Fields(&quot;word&quot;,&quot;count&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新建WordCountTopology类用来链接Spout和Bolt，执行主程序"><a href="#新建WordCountTopology类用来链接Spout和Bolt，执行主程序" class="headerlink" title="新建WordCountTopology类用来链接Spout和Bolt，执行主程序"></a>新建WordCountTopology类用来链接Spout和Bolt，执行主程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package com.topo;</span><br><span class="line"></span><br><span class="line">import org.apache.storm.Config;</span><br><span class="line">import org.apache.storm.LocalCluster;</span><br><span class="line">import org.apache.storm.StormSubmitter;</span><br><span class="line">import org.apache.storm.topology.TopologyBuilder;</span><br><span class="line">import org.apache.storm.utils.Utils;</span><br><span class="line"></span><br><span class="line">public class WordCountTopology &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //去将spout和bolts组合起来，构建成一个拓扑</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line"></span><br><span class="line">        // 第一个参数的意思，就是给这个spout设置一个名字</span><br><span class="line">        // 第二个参数的意思，就是创建一个spout的对象</span><br><span class="line">        // 第三个参数的意思，就是设置spout的executor有几个</span><br><span class="line">        builder.setSpout(&quot;RandomSentence&quot;, new RandomSentenceSpout(), 2);</span><br><span class="line">        builder.setBolt(&quot;SplitSentence&quot;, new SplitSentenceBolt(), 5)</span><br><span class="line">                //为bolt 设置 几个task</span><br><span class="line">                .setNumTasks(10)</span><br><span class="line">                //设置流分组策略</span><br><span class="line">                .shuffleGrouping(&quot;RandomSentence&quot;);</span><br><span class="line"></span><br><span class="line">        // fieldsGrouping 这个很重要，就是说，相同的单词，从SplitSentenceSpout发射出来时，一定会进入到下游的指定的同一个task中</span><br><span class="line">        // 只有这样子，才能准确的统计出每个单词的数量</span><br><span class="line">        // 比如你有个单词，hello，下游task1接收到3个hello，task2接收到2个hello</span><br><span class="line">        // 通过fieldsGrouping 可以将 5个hello，全都进入一个task</span><br><span class="line">        builder.setBolt(&quot;wordCount&quot;, new WordCountBolt(), 10)</span><br><span class="line">                //为bolt 设置 几个task</span><br><span class="line">                .setNumTasks(20)</span><br><span class="line">                //设置流分组策略</span><br><span class="line">                .shuffleGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.globalGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.allGrouping(&quot;SplitSentence&quot;);</span><br><span class="line">                //.fieldsGrouping(&quot;SplitSentence&quot;, new Fields(&quot;word&quot;));</span><br><span class="line"></span><br><span class="line">        // 运行配置项</span><br><span class="line">        Config config = new Config();</span><br><span class="line"></span><br><span class="line">        //说明是在命令行执行，打算提交到storm集群上去</span><br><span class="line">        if(args != null &amp;&amp; args.length &gt; 0)&#123;</span><br><span class="line">            /**</span><br><span class="line">             *  要想提高storm的并行度可以从三个方面来改造</span><br><span class="line">             *  worker(进程)&gt;executor(线程)&gt;task(实例)</span><br><span class="line">             *  增加work进程，增加executor线程，增加task实例</span><br><span class="line">             *  对应 supervisor.slots.port 中配置个数</span><br><span class="line">             *  这里可以动态设置使用个数</span><br><span class="line">             *  最好一台机器上的一个topology只使用一个worker,主要原因时减少了worker之间的数据传输</span><br><span class="line">             *</span><br><span class="line">             *  注意：如果worker使用完的话再提交topology就不会执行，因为没有可用的worker，只能处于等待状态，把之前运行的topology停止一个之后这个就会继续执行了</span><br><span class="line">             */</span><br><span class="line">            config.setNumWorkers(3);</span><br><span class="line">            try &#123;</span><br><span class="line">                // 将Topolog提交集群</span><br><span class="line">                StormSubmitter.submitTopology(args[0], config, builder.createTopology());</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 用本地模式运行1个拓扑时，用来限制生成的线程的数量</span><br><span class="line">            config.setMaxTaskParallelism(20);</span><br><span class="line"></span><br><span class="line">            // 将Topolog提交本地集群</span><br><span class="line">            LocalCluster cluster = new LocalCluster();</span><br><span class="line">            cluster.submitTopology(&quot;wordCountTopology&quot;, config, builder.createTopology());</span><br><span class="line"></span><br><span class="line">            // 为了测试模拟等待</span><br><span class="line">            Utils.sleep(60000);</span><br><span class="line">            // 执行完毕，关闭cluster</span><br><span class="line">            cluster.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><h4 id="shuffleGrouping运行结果"><a href="#shuffleGrouping运行结果" class="headerlink" title="shuffleGrouping运行结果"></a>shuffleGrouping运行结果</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdnimg.cn/20190611161427796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="shuffleGrouping运行结果" title>
                </div>
                <div class="image-caption">shuffleGrouping运行结果</div>
            </figure>
<p>随机分组，不自觉间做到了负载均衡。</p>
<h4 id="globalGrouping运行结果"><a href="#globalGrouping运行结果" class="headerlink" title="globalGrouping运行结果"></a>globalGrouping运行结果</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdnimg.cn/20190611161449921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="globalGrouping运行结果" title>
                </div>
                <div class="image-caption">globalGrouping运行结果</div>
            </figure>
<p>只往一个里面发,发送到id最小的那个任务。</p>
<h4 id="allGrouping运行结果"><a href="#allGrouping运行结果" class="headerlink" title="allGrouping运行结果"></a>allGrouping运行结果</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdnimg.cn/20190611161502207.png" alt="allGrouping运行结果" title>
                </div>
                <div class="image-caption">allGrouping运行结果</div>
            </figure>
<p>两个spot并行 所有都分发。</p>
<h4 id="fieldsGrouping运行结果"><a href="#fieldsGrouping运行结果" class="headerlink" title="fieldsGrouping运行结果"></a>fieldsGrouping运行结果</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://img-blog.csdnimg.cn/2019061116151598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NjM3Mw==,size_16,color_FFFFFF,t_70" alt="fieldsGrouping运行结果" title>
                </div>
                <div class="image-caption">fieldsGrouping运行结果</div>
            </figure>
<p>相同的名称的fields分发到一个bolt里面。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-06-11T08:28:15.164Z" itemprop="dateUpdated">2019-06-11 16:28:15</time>
</span><br>


        
        转载联系1571170555@qq.com
        
    </div>
    
    <footer>
        <a href="http://www.duanmuxu.top">
            <img src="/img/avatar.jpg" alt="端木胥">
            端木胥
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Storm/">Storm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/大数据/">大数据</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html&title=《Storm学习02：八种grouping分组策略》 — 端木胥的个人博客&pic=http://www.duanmuxu.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html&title=《Storm学习02：八种grouping分组策略》 — 端木胥的个人博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Storm学习02：八种grouping分组策略》 — 端木胥的个人博客&url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html&via=http://www.duanmuxu.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/20190618/shell-learning-01-create-and-execute-script-files.html" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Shell学习01：创建和执行脚本文件</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/20190604/ambari-cluster-build-hdp-offline-installation-version.html" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Ambari集群搭建（HDP离线安装版）</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "TkNx8qQrs1R3XrIeuTt3bIvD-gzGzoHsz",
            appKey: "1rYKcKGqfnSVtHTn1uyOKqhw",
            avatar: "mm",
            placeholder: "Just commit",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>端木胥 &copy; 2018 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html&title=《Storm学习02：八种grouping分组策略》 — 端木胥的个人博客&pic=http://www.duanmuxu.top/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html&title=《Storm学习02：八种grouping分组策略》 — 端木胥的个人博客&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Storm学习02：八种grouping分组策略》 — 端木胥的个人博客&url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html&via=http://www.duanmuxu.top" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.duanmuxu.top/20190611/storm-learning-02-eight-grouping-strategies.html" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtElEQVR42u3aQa7bMAwFQN//0i3QbWv7kRTzg2K8ChIn1mghKY+8rvj69ef6+5279/N7kqc8f+vAhYeHh9ca+t2VPOb5wfkv393/PHF39+Ph4eFt856X6dsv33yaDysfSbJJ4OHh4X0bb/7gZHHHw8PD+594+VE4CSOqVDw8PLxv4yWRQR4BJJFr/qwPZS14eHh4Ma9aAPuG14v1PTw8PLxBVX2yQOcH9F6cEY0WDw8Pb4FXbQWohq3Vtqqz4QgeHh7eBi+PXCf4/CicByLRRODh4eF9hJdHEtXYolroystpt9/Cw8PDW+MlRfpe8elUK0Bzc8LDw8P7IG9eiJpMSjXguHpfxsPDwxvz8qV5Tu3FstWAGA8PD2+blwQBeQAx2QDyA/3LRODh4eF9hDcpRE1K/r0todBThoeHh3eUl/zo8xScCjLyDSaKd/Hw8PDWeNVyVz6gSWNBEje8TBweHh7eGq9a7K8OIglzk0N8tf0LDw8Pb4M3+qs/wJx9/fIpHh4e3hqvGstOPu2FF0ms3PzfgIeHhxfzqiX/5Kd7Ja68wauAx8PDw1vg5QX++fKdNCXkkUe5wQsPDw/vEK+60M/boSaAfHu4evsYHh4eXpp/RiFCXjarTtw1vvDw8PA+yest/b2jcLV8lWwYL1sUHh4e3hovf/z8kD2JP8plMzw8PLwF3qTCng80PzpXw9/CfwU8PDy8Q7xqANELVashxSSM+Me+h4eHh7fGy0tf1TvLXQzxsf5l/cfDw8Nb4B1YfMdtBHnbVu+YjoeHh7fBmyQZ81aqyTRF04eHh4e3xpsMvboL5YPrBSV4eHh438ObHIIn5f9qC9dV7WXAw8PD+yFevoVUY9w8ClncGPDw8PBaYUS+HPcA+WaTNyvg4eHhbfBOFcDueFXS8+/MoxA8PDy8Ae83/wMr8F1vksQAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '快回来！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
