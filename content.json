[{"title":"Hadoop Streaming详解","date":"2019-09-22T10:44:41.617Z","path":"20190922/detailed-hadoop-streaming.html","text":"刚来公司的时候就发现大家都在使用Hadoop Streaming 来执行任务，当时还在想名字里有Streaming，Hadoop也拿来做实时计算工具了吗？后来发现原来只是我学得太少，对编程工具的理解太片面了。 那么接下来就来看看什么是Hadoop Streaming，为什么要使用Hadoop Streaming、Hadoop Streaming的原理以及怎么使用Hadoop Streaming。 什么是Hadoop StreamingHadoop Streaming是Hadoop提供的一个编程工具，由Hadoop提供。 为什么使用Hadoop Streaming之前习惯了使用Hadoop框架来进行数据处理，Hadoop框架是用Java语言写的，也就是说如果想用Hadoop框架来执行MR任务，那么需要开发者会Java编程语言，这样子让不会Java语言的开发者怎么办？重新学习一门新语言吗，好像也不是不行(-，但是太麻烦啦，时间成本很高，因此Hadoop Streaming就出现啦！ Hadoop Streaming允许用户使用任何程序语言来编写mapreduce里的Mapper 和 Reducer函数，无论你会不会Java，只要会某种编程语言，都能通过Hadoop Streaming来编写MR程序（公司用的都是Python，为了合群只能先学习Python！） Hadoop Streaming 局限性标准输入输出上面说到Hadoop Streaming支持任何语言来编写MR程序，这固然对开发者是十分友好的，但是它也有一定的局限性，即map/reduce函数的数据流必须遵循相应编程语言的标准输入输出（stdin、stdout），用什么编程语言实现业务逻辑，就必须要通过该语言的标准输入stdin读取数据，通过该语言的标准输出stdout输出数据。比方说如下的几种编程语言的输入输出： 1234567891011121314151617181920212223# python标准输入输出import sysfor line in sys.stdin: 后续操作 print (输出内容)# shell标准输入输出while read LINE; do 后续操作 echo &quot;输出内容&quot;# c语言标准输入输出char buffer[BUF_SIZE];while(fgets(buffer, BUF_SIZE - 1, stdin))&#123; int len = strlen(buffer); 后续操作&#125;printf(输出内容)... 这种规定标准的输入输出，不能方便地处理多路输出。 处理文本数据Hadoop Streaming默认只能处理文本数据Textfile，而对于二进制数据，较好的方法是将二进制的key、value进行base64编码，转化为文本在进行操作。 多余的开销用Java编写的MR程序直接处理框架从输入数据中得到的key/value对，而在Hadoop Streaming中Java程序不直接处理kv对，而是通过管道写到mapper的标准输入，mapper程序再从kv中解析出kv对，这个过程多了两次数据拷贝和解析（分割），这会带来一定的开销。同理，对于reducer也一样。 Hadoop Streaming 原理 image Streaming原理是用Java实现一个包装用户程序的MR程序，该程序负责调用MapReduce Java接口获取key/value键值对输入，创建一个新的进程启动包装的用户程序，将数据通过管道传递给包装的用户程序处理，然后调用MapReduce Java接口将用户程序的输出切分成kv对输出。 如上图所示，Streaming Java Mapper通过管道将key/value输入传递给用户mapper的标准输入，并获取mapper的标准输出；Streaming Java Reducer调用Java接口通过InputFormat从HDFS获取输入数据，从管道将kv传递给用户reducer程序的标准输入，获取reducer的标准输出并调用Java接口通过OutputFormat输出数据。 shuffle和sort阶段，和一般的MapReduce作业流程一样,经过此阶段的操作然后到达Reducer。 怎么使用Hadoop Streaming参数说明： -input ：指定作业输入，path可以是文件或者目录，可以使用*通配符，-input选项可以使用多次指定多个文件或目录作为输入 -output ：指定作业输出目录，path必须不存在，而且执行作业的用户必须有创建该目录的权限，-output只能使用一次 -mapper：指定mapper可执行程序，必须指定且唯一 -reducer：指定reducer可执行程序，必须指定且唯一 -file, -cacheFile, -cacheArchive：分别用于向计算节点分发本地文件、HDFS文件和HDFS压缩文件 -numReduceTasks：指定reducer的个数，如果设置-numReduceTasks 0或者-reducer NONE则没有reducer程序，mapper的输出直接作为整个作业的输出 -combiner：指定combiner Java类，对应的Java类文件打包成jar文件后用-file分发 -inputformat, -outputformat：指定inputformat和outputformat Java类，用于读取输入数据和写入输出数据，分别要实现InputFormat和OutputFormat接口。如果不指定，默认使用TextInputFormat和TextOutputFormat -partitioner：指定partitioner Java类，Streaming提供了一些实用的partitioner实现，参考KeyBasedFiledPartitoner和IntHashPartitioner -cmdenv NAME=VALUE：给mapper和reducer程序传递额外的环境变量，NAME是变量名，VALUE是变量值 -mapdebug, -reducedebug：分别指定mapper和reducer程序失败时运行的debug程序 -verbose：指定输出详细信息，例如分发哪些文件，实际作业配置参数值等，可以用于调试 -jobconf || -D NAME=VALUE ：指定作业参数，NAME是参数名，VALUE是参数值，可以指定的参数参考hadoop-default.xml。作业参数详解： 配置参数 参数详情 mapred.job.name 作业名 mapred.job.priority 作业优先级 mapred.job.map.capacity 最多同时运行map任务数 mapred.job.reduce.capacity 最多同时运行reduce任务数 hadoop.job.ugi 作业执行权限 mapred.map.tasks map任务个数 mapred.reduce.tasks reduce任务个数 mapred.job.groups 作业可运行的计算节点分组 mapred.task.timeout 任务没有响应（输入输出）的最大时间 mapred.compress.map.output map的输出是否压缩 mapred.map.output.compression.codec map的输出压缩方式 mapred.output.compress reduce的输出是否压缩 mapred.output.compression.codec reduce的输出压缩方式 stream.map.output.field.separator map输出分隔符 这其中特别建议用-jobconf mapred.job.name=’My Job Name’设置作业名，使用-jobconf mapred.job.priority=VERY_HIGH | HIGH | NORMAL | LOW | VERY_LOW设置作业优先级，使用-jobconf mapred.job.map.capacity=M设置同时最多运行M个map任务，使用-jobconf mapred.job.reduce.capacity=N设置同时最多运行N个reduce任务。","tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.duanmuxu.top/tags/Hadoop/"}]},{"title":"Python学习笔记07","date":"2019-08-12T15:47:51.284Z","path":"20190812/python-study-notes-07.html","text":"convert_types.py 脚本中保存了一个列表，列表中存放的是pv行为，如：[‘离线动作-列表页-到这里去 1’,’离线动作-图区-搜周边 2’,’离线动作-图区-到这里去 1’…] 今天想要将 convert_types.py 里的pv行为全部都放在excel表里，行为名称和行为编号分开存放，于是使用pandas 中的dataframe结构存放数据，再将dataframe的数据写入excel文件中，代码写好后运行程序却报了以下错误： 1UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe5 in position 7: ordinal not in range(128) 查阅资料后解决了以下两个问题 dataframe 如何写入数据到excel 文件中单个dataframe 写入数据到excel 文件中将整个dataframe 写入excel 文件，直接调用dataframe的to_excel()函数即可 123# result 为结果列表，将列表转化为DataFrame类型数据df = pd.DataFrame(result)df.to_excel(&apos;filePath&apos;,sheet_name=&apos;sheetname&apos;) to_excel()参数解释： 12345DataFrame.to_excel(excel_writer, sheet_name=&apos;Sheet1&apos;, na_rep=&apos;&apos;, float_format=None, columns=None, header=True, index=True, index_label=None, startrow=0, startcol=0, engine=None, merge_cells=True, encoding=None, inf_rep=&apos;inf&apos;, verbose=True, freeze_panes=None) excel_writer : 字符串或ExcelWriter 对象——文件路径或现有的ExcelWriter sheet_name :字符串,默认“Sheet1”——将包含DataFrame的表的名称。 na_rep : 字符串,默认‘ ’——缺失数据表示方式 float_format : 字符串,默认None——格式化浮点数的字符串 columns : 序列,可选——要编写的列 header : 布尔或字符串列表，默认为Ture。——写出列名。如果给定字符串列表，则假定它是列名称的别名。 index :布尔,默认的Ture——写行名（索引） index_label : 字符串或序列，默认为None。——如果需要，可以使用索引列的列标签。如果没有给出，标题和索引为true，则使用索引名称。如果数据文件使用多索引，则需使用序列。 startrow :——左上角的单元格行来转储数据框 startcol :——左上角的单元格列转储数据帧 engine : 字符串,默认没有——使用写引擎-也可以通过选项io.excel.xlsx.writer，io.excel.xls.writer和io.excel.xlsm.writer进行设置。 merge_cells : 布尔,默认为Ture——编码生成的excel文件。只有xlwt需要，其他编写者本地支持unicode。 inf_rep : 字符串,默认“正”——无穷大的表示(在Excel中不存在无穷大的本地表示) freeze_panes : 整数的元组(长度2)，默认为None。——指定要冻结的基于1的最底部行和最右边的列 多个DataFrame 分为多个表写入同一个excel 文件中需要通过ExcelWriter()方法打开一个已经存在的excel表格作为writer，然后通过to_excel()方法将需要保存的数据逐个写入excel，最后关闭writer 123456write = pd.ExcelWriter(&apos;filePath&apos;)df = pd.DataFrame(result)df1 = df.copy()df.to_excel(write, sheet_name=&apos;data1&apos;)df1.to_excel(write, sheet_name=&apos;data2&apos;)write.save() 结果为excel 表中有表名为’data1’和’data2’的两张小表 多个DataFrame 写入一个excel 文件同一个表中数据定义与上一个相同，只不过需要更改to_excel()函数中的参数而已 123456write = pd.ExcelWriter(&apos;filePath&apos;)df = pd.DataFrame(result)df1 = df.copy()df.to_excel(write, sheet_name=&apos;data&apos;,startrow = 10)df1.to_excel(write, sheet_name=&apos;data&apos;, startrow = 30, startcol = 10)write.save() df数据从表格的第十行开始插入 df1数据从表格的第三十行和第十列开始插入 注意第二个数据插入的地方不能有其他数据，否则数据会覆盖。 sys.setdefaultencoding(‘utf-8’)的使用Python 里面的编码和解码也就是 unicode 和 str 这两种形式的相互转化。编码是 unicode -&gt; str，相反的，解码就是 str -&gt; unicode。剩下的问题就是确定何时需要进行编码或者解码了。 关于文件开头的”编码指示”，也就是 # -*- coding: -*- 这个语句。Python 默认脚本文件都是 UTF-8 编码的，当文件中有非 UTF-8 编码范围内的字符的时候就要使用”编码指示”来修正。关于 sys.defaultencoding，这个在解码没有明确指明解码方式的时候使用。 12345#! /usr/bin/env python # -*- coding: utf-8 -*- # 注意这里的 s 是 str 类型的，而不是 unicode s = &apos;中文&apos; s.encode(&apos;gb18030&apos;) 这句代码将 s 重新编码为 gb18030 的格式，即进行 unicode -&gt; str 的转换。因为 s 本身就是 str 类型的，因此 Python 会自动的先将 s 解码为 unicode ，然后再编码成 gb18030。因为解码是python自动进行的，我们没有指明解码方式，python 就会使用 sys.defaultencoding 指明的方式来解码。很多情况下 sys.defaultencoding 是ANSCII，如果 s 不是这个类型就会出错。拿上面的情况来说，sys.defaultencoding 是 anscii，而 s 的编码方式和文件的编码方式一致，是 utf8 的，所以出错了: 1UnicodeDecodeError: &apos;ascii&apos; codec can&apos;t decode byte 0xe4 in position 0: ordinal not in range(128) 出现这种情况时有两种方法来解决： 明确的指示出 s 的编码方式12345#! /usr/bin/env python# -*- coding: utf-8 -*-# 注意这里的 s 是 str 类型的，而不是 unicodes = &apos;中文&apos; s.decode(&apos;utf8&apos;).encode(&apos;gb18030&apos;) 先用 utf-8 解码，再用 gb18030 编码，就不会出错了 更改 sys.defaultencoding 为文件的编码方式123456789#! /usr/bin/env python# -*- coding: utf-8 -*-import sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)# 注意这里的 s 是 str 类型的，而不是 unicodes = &apos;中文&apos; s.encode(&apos;gb18030&apos;) 这是个固定用法，Python2.5 初始化后删除了 sys.setdefaultencoding 方法，所以需要重新载入 sys dataframe.read_excel()顺带说一下使用dataframe读取excel文件的方法 1read_excel(io, sheetname=0, header=0, skiprows=None, skip_footer=0, index_col=None,names=None, parse_cols=None, parse_dates=False,date_parser=None,na_values=None,thousands=None, convert_float=True, has_index_names=None, converters=None,dtype=None, true_values=None, false_values=None, engine=None, squeeze=False, **kwds) 常用参数解析： io : string, path object ; excel 路径。 sheetname : string, int, mixed list of strings/ints, or None, default 0 返回多表使用sheetname=[0,1],若sheetname=None是返回全表 注意：int/string 返回的是dataframe，而none和list返回的是dict of dataframe header : int, list of ints, default 0 指定列名行，默认0，即取第一行，数据为列名行以下的数据 若数据不含列名，则设定 header = None skiprows : list-like,Rows to skip at the beginning，省略指定行数的数据 skip_footer : int,default 0, 省略从尾部数的int行数据 index_col : int, list of ints, default None指定列为索引列，也可以使用u’strings’ names : array-like, default None, 指定列的名字。 附上完整代码 12345678910111213141516171819#! /usr/bin/env python# -*- coding=utf-8 -*-import pandas as pdimport convert_typesimport sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;)key = []value = []list = convert_types.listfor i in range(len(list)): key.append(list[i].strip().split(&apos;\\t&apos;)[0]) value.append(list[i].strip().split(&apos;\\t&apos;)[1])result=&#123;&quot;名称&quot;:key, &quot;数值&quot;:value&#125;df = pd.DataFrame(result)df.to_excel(&apos;/Users/v_huruijie/Documents/sug/sug.xlsx&apos;,sheet_name=&apos;convert_types.py&apos;)","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Python学习笔记06","date":"2019-08-05T14:16:23.309Z","path":"20190805/python-study-notes-06.html","text":"Python JSONJSON函数使用 JSON 函数需要导入 json 库：import json json.dumps:将 Python 对象编码成 JSON 字符串 json.loads:将已编码的 JSON 字符串解码为 Python 对象 encode:将 Python 对象编码成 JSON 字符串 decode:将已编码的 JSON 字符串解码为 Python 对象 json.dumpsjson.dumps 用于将 Python 对象编码成 JSON 字符串 1json.dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw) 参数解释： obj: Python 对象 skipkeys: skipkeys可以跳过那些非string对象当作key的处理。在encoding过程中，dict对象的key只可以是string对象，如果是其他类型，那么在编码过程中就会抛出ValueError的异常 ensure_ascii: 如果obj里包括非ASCII码,True时,编成ASCII码; False时,不进行编码,原样输出。json.dumps 序列化时对中文默认使用的ascii编码，输出的为ascii码值，而不是中文。当设置ensure_ascii==FALSE 时，输出即为中文 check_circular: 默认为True，值为False时,”循环引用检查”对容器类型跳过检查,并且也可能导致溢出错误/或者更糟 allow_nan: 默认为True，值为False时,对于序列化超出范围的float值,严格遵守JSON规范,将是一个ValueError而不是使用JavaScript等价物(NaN,Infinity,-Infinity) indent: 根据数据格式缩进显示，读起来更加清晰, indent的值，代表缩进空格式 separators: 去掉‘，’ ‘：’后面的空格，在传输数据的过程中，越精简越好，冗余的东西全部去掉 default: 是一个函数,该函数能够把自定义类型的对象转换成可序列化的基本类型 sort_keys: 告诉编码器按照字典key排序(a到z)输出 123456789101112131415161718&gt;&gt;&gt; import json&gt;&gt;&gt; data = [ &#123; &apos;a&apos; : 1, &apos;b&apos; : 2, &apos;c&apos; : 3, &apos;d&apos; : 4, &apos;e&apos; : 5 &#125; ]&gt;&gt;&gt; json=json.dumps(data)&gt;&gt;&gt; print json[&#123;&quot;a&quot;: 1, &quot;c&quot;: 3, &quot;b&quot;: 2, &quot;e&quot;: 5, &quot;d&quot;: 4&#125;]&gt;&gt;&gt; data[&#123;&apos;a&apos;: 1, &apos;c&apos;: 3, &apos;b&apos;: 2, &apos;e&apos;: 5, &apos;d&apos;: 4&#125;]&gt;&gt;&gt; print json.dumps(data, sort_keys=True, indent=2, separators=(&apos;,&apos;, &apos;: &apos;))[ &#123; &quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3, &quot;d&quot;: 4, &quot;e&quot;: 5 &#125;] json.loadsjson.loads 用于解码 JSON 数据。该函数返回 Python 字段的数据类型 1json.loads(s[, encoding[, cls[, object_hook[, parse_float[, parse_int[, parse_constant[, object_pairs_hook[, **kw]]]]]]]]) 参数解释： s: 待解码的 JSON 数据 encoding: 编码方式 object_hook: 该函数负责把反序列化后的基本类型对象转换成自定义类型的对象 parse_float: 如果指定，将调用每个JSON浮点的字符串进行解码。默认情况下，这相当于浮点（NUMYSTR）。这可以用于使用另一个数据类型或解析器用于JSON浮点 1234567891011121314151617&gt;&gt;&gt; import json&gt;&gt;&gt; jData=&apos;&#123;&apos;username&apos;:&apos;李华&apos;,&apos;sex&apos;:&apos;male&apos;,&apos;age&apos;:16&#125;&apos; File &quot;&lt;stdin&gt;&quot;, line 1 jData=&apos;&#123;&apos;username&apos;:&apos;李华&apos;,&apos;sex&apos;:&apos;male&apos;,&apos;age&apos;:16&#125;&apos; ^SyntaxError: invalid syntax&gt;&gt;&gt; import json&gt;&gt;&gt; jData=&apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3, &quot;d&quot;:4&#125;&apos;&gt;&gt;&gt; result=json.loads(jData)&gt;&gt;&gt; print result&#123;u&apos;a&apos;: 1, u&apos;c&apos;: 3, u&apos;b&apos;: 2, u&apos;d&apos;: 4&#125;&gt;&gt;&gt; result&#123;u&apos;a&apos;: 1, u&apos;c&apos;: 3, u&apos;b&apos;: 2, u&apos;d&apos;: 4&#125;&gt;&gt;&gt; type(result)&lt;type &apos;dict&apos;&gt;&gt;&gt;&gt; type(jData)&lt;type &apos;str&apos;&gt; encodePython encode() 函数用于将 Python 对象编码成 JSON 字符串 1demjson.encode(self, obj, nest_level=0) 123456789&gt;&gt;&gt; import demjson&gt;&gt;&gt; data = [ &#123; &apos;a&apos; : 1, &apos;b&apos; : 2, &apos;c&apos; : 3, &apos;d&apos; : 4, &apos;e&apos; : 5 &#125; ]&gt;&gt;&gt; result = demjson.encode(data)&gt;&gt;&gt; print result[&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;]&gt;&gt;&gt; type(result)&lt;type &apos;unicode&apos;&gt;&gt;&gt;&gt; type(data)&lt;type &apos;list&apos;&gt; decodePython 可以使用 demjson.decode() 函数解码 JSON 数据。该函数返回 Python 字段的数据类型 1demjson.decode(self, txt) 123456789&gt;&gt;&gt; import demjson&gt;&gt;&gt; jdata=&apos;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;&apos;&gt;&gt;&gt; result=demjson.decode(jdata)&gt;&gt;&gt; print result&#123;u&apos;a&apos;: 1, u&apos;c&apos;: 3, u&apos;b&apos;: 2, u&apos;e&apos;: 5, u&apos;d&apos;: 4&#125;&gt;&gt;&gt; type(result)&lt;type &apos;dict&apos;&gt;&gt;&gt;&gt; type(jdata)&lt;type &apos;str&apos;&gt;","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Python学习笔记05","date":"2019-08-04T07:52:58.444Z","path":"20190804/python-study-notes-05.html","text":"正则表达式re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 1re.match(pattern, string, flags=0) pattern：匹配的正则表达式 string：要匹配的字符串。 flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.match方法返回一个匹配的对象，否则返回None。 使用group(num) 或 groups() 匹配对象函数来获取匹配表达式 group(num=0):匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups():返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 1234567891011121314import reprint(re.match(&apos;www&apos;, &apos;www.baidu.com&apos;).span()) # 在起始位置匹配print(re.match(&apos;com&apos;, &apos;www.baidu.com&apos;)) # 不在起始位置匹配line = &quot;Cats are smarter than dogs&quot; matchObj = re.match( r&apos;(.*) are (.*?) .*&apos;, line, re.M|re.I) if matchObj: print &quot;matchObj.group() : &quot;, matchObj.group() print &quot;matchObj.group(1) : &quot;, matchObj.group(1) print &quot;matchObj.group(2) : &quot;, matchObj.group(2)else: print &quot;No match!!&quot; 123456# 输出(0, 3)NonematchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter r&#39;(.*) are (.*?) .*&#39; 解析 r 表示字符串为非转义的原始字符串，让编译器忽略反斜杠，也就是忽略转义字符。但是这个字符串里没有反斜杠，所以这个 r 可有可无。 (.*) 第一个匹配分组，.* 代表匹配除换行符之外的所有字符 (.*?) 第二个匹配分组，.*? 后面多个问号，代表非贪婪模式，也就是说只匹配符合条件的最少字符 后面的一个 .* 没有括号包围，所以不是分组，匹配效果和第一个一样，但是不计入匹配结果中。 matchObj.group() 等同于 matchObj.group(0)，表示匹配到的完整文本字符 matchObj.group(1) 得到第一组匹配结果，也就是(.*)匹配到的 matchObj.group(2) 得到第二组匹配结果，也就是(.*?)匹配到的 因为只有匹配结果中只有两组，所以如果填 3 时会报错。 re.search方法re.search 扫描整个字符串并返回第一个成功的匹配。 1re.search(pattern, string, flags=0) 匹配成功re.search方法返回一个匹配的对象，否则返回None 123import reprint(re.search(&apos;www&apos;, &apos;www.baidu.com&apos;).span()) # 在起始位置匹配print(re.search(&apos;com&apos;, &apos;www.baidu.com&apos;).span()) # 不在起始位置匹配 123# 输出：(0, 3)(11, 14) re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 123456789101112131415import re line = &quot;Cats are smarter than dogs&quot;; matchObj = re.match( r&apos;dogs&apos;, line, re.M|re.I)if matchObj: print &quot;match --&gt; matchObj.group() : &quot;, matchObj.group()else: print &quot;No match!!&quot; matchObj = re.search( r&apos;dogs&apos;, line, re.M|re.I)if matchObj: print &quot;search --&gt; matchObj.group() : &quot;, matchObj.group()else: print &quot;No match!!&quot; 123# 输出：No match!!search --&gt; matchObj.group() : dogs 检索和替换re.sub用于替换字符串中的匹配项 1re.sub(pattern, repl, string, count=0, flags=0) pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 1234567891011import re phone = &quot;2004-959-559 # 这是一个国外电话号码&quot; # 删除字符串中的 Python注释 num = re.sub(r&apos;#.*$&apos;, &quot;&quot;, phone)print &quot;电话号码是: &quot;, num # 删除非数字(-)的字符串 num = re.sub(r&apos;\\D&apos;, &quot;&quot;, phone)print &quot;电话号码是 : &quot;, num 123# 输出：电话号码是: 2004-959-559 电话号码是 : 2004959559 re.compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 1re.compile(pattern[, flags]) findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。match 和 search 是匹配一次 findall 匹配所有。 1findall(string[, pos[, endpos]]) string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。 12345678import re pattern = re.compile(r&apos;\\d+&apos;) # 查找数字，用于匹配至少一个数字result1 = pattern.findall(&apos;baidu 123 google 456&apos;)result2 = pattern.findall(&apos;bai88bai123google456&apos;, 0, 10) print(result1)print(result2) 123# 输出[&apos;123&apos;, &apos;456&apos;][&apos;88&apos;, &apos;12&apos;] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags=0) re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表 1re.split(pattern, string[, maxsplit=0, flags=0]) 12345678910&gt;&gt;&gt;import re&gt;&gt;&gt; re.split(&apos;\\W+&apos;, &apos;baidu, baidu, baidu.&apos;)[&apos;baidu&apos;, &apos;baidu&apos;, &apos;baidu&apos;, &apos;&apos;]&gt;&gt;&gt; re.split(&apos;(\\W+)&apos;, &apos; baidu, baidu, baidu.&apos;) [&apos;&apos;, &apos; &apos;, &apos;baidu&apos;, &apos;, &apos;, &apos;baidu&apos;, &apos;, &apos;, &apos;baidu&apos;, &apos;.&apos;, &apos;&apos;]&gt;&gt;&gt; re.split(&apos;\\W+&apos;, &apos; baidu, baidu, baidu.&apos;, 1) [&apos;&apos;, &apos;baidu, baidu, baidu.&apos;] &gt;&gt;&gt; re.split(&apos;a*&apos;, &apos;hello world&apos;) # 对于一个找不到匹配的字符串而言，split 不会对其作出分割[&apos;hello world&apos;] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式常用符号解释 \\ : 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\\\‘ 匹配 “\\“ 而 “\\(“ 则匹配 “(“ ^ : 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline(多行匹配) 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置 $ : 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置 * : 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,} : 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,} ? : 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1} {n} : n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o {n,} : n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’ {n,m} : m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格，贪婪模式 ? : 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’ . : 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式 […] : 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] : 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 a| b : 匹配a或b (?imx) : 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域 \\w : 匹配字母数字及下划线 \\W : 匹配非字母数字及下划线 \\s : 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S : 匹配任意非空字符，等价于 [^ \\f\\n\\r\\t\\v] \\d : 匹配任意数字，等价于 [0-9]. \\D : 匹配任意非数字，等价于 [^0-9]. \\A : 匹配字符串开始 \\Z : 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z : 匹配字符串结束 \\G : 匹配最后匹配完成的位置。 \\b : 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B : 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. : 匹配一个换行符。匹配一个制表符。等 \\1…\\9 : 匹配第n个分组的内容。 \\10 : 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 正则表达式修饰符 - 可选标志修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Python学习笔记04","date":"2019-08-02T15:20:00.795Z","path":"20190802/python-study-notes-04.html","text":"datetime模块其实就是date和time 模块的结合， 常见的属性方法都比较常用比如：datetime.day,datetime.month,datetime.year 分别表示一个datetime对象的日，月，年 12345678from datetime import datetimedt=datetime.now() #创建一个datetime类对象print dt.year,dt.month,dt.day&apos;&apos;&apos;输出为：2019 8 1&apos;&apos;&apos; strftime()函数strftime() 用来格式化datetime 对象, 有时候会十分的方便：先看一下格式： datetime.strftime(‘%’ ) %后面跟一个控制字符 123456789101112131415161718192021222324252627282930from datetime import datetimedt = datetime.now() print &apos;时间：(%Y-%m-%d %H:%M:%S %f): &apos; , dt.strftime( &apos;%Y-%m-%d %H:%M:%S %f&apos; ) print &apos;时间：(%Y-%m-%d %H:%M:%S %p): &apos; , dt.strftime( &apos;%y-%m-%d %I:%M:%S %p&apos; ) print &apos;星期缩写%%a: %s &apos; % dt.strftime( &apos;%a&apos; ) print &apos;星期全拼%%A: %s &apos; % dt.strftime( &apos;%A&apos; ) print &apos;月份缩写%%b: %s &apos; % dt.strftime( &apos;%b&apos; ) print &apos;月份全批%%B: %s &apos; % dt.strftime( &apos;%B&apos; ) print &apos;日期时间%%c: %s &apos; % dt.strftime( &apos;%c&apos; ) print &apos;今天是这周的第%s天 &apos; % dt.strftime( &apos;%w&apos; ) print &apos;今天是今年的第%s天 &apos; % dt.strftime( &apos;%j&apos; ) print &apos;今周是今年的第%s周 &apos; % dt.strftime( &apos;%U&apos; ) print &apos;今天是当月的第%s天 &apos; % dt.strftime( &apos;%d&apos; )&apos;&apos;&apos;输出如下：--------------------------------------------------------------时间：(%Y-%m-%d %H:%M:%S %f): 2019-08-01 19:49:49 347018时间：(%Y-%m-%d %H:%M:%S %p): 19-08-01 07:49:49 PM星期缩写%a: Thu 星期全拼%A: Thursday 月份缩写%b: Aug 月份全批%B: August 日期时间%c: Thu Aug 1 19:49:49 2019 今天是这周的第4天 今天是今年的第213天 今周是今年的第30周 今天是当月的第01天 ---------------------------------------------------&apos;&apos;&apos; Calendar模块获取月历日历 123456789&gt;&gt;&gt; import calendar&gt;&gt;&gt; print calendar.month(2019, 8) August 2019Mo Tu We Th Fr Sa Su 1 2 3 4 5 6 7 8 9 10 1112 13 14 15 16 17 1819 20 21 22 23 24 2526 27 28 29 30 31 可更改(mutable)与不可更改(immutable)对象在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。 不定长参数一个函数能处理比当初声明时更多的参数 声明1234def functionname([formal_args,] *var_args_tuple ): &quot;函数_文档字符串&quot; function_suite return [expression] 实例1234567891011121314151617181920212223#!/usr/bin/env python# -*- coding: utf-8 -*- # 可写函数说明def printinfo( arg1, *vartuple ): &quot;打印任何传入的参数&quot; print &quot;输出: &quot; print arg1 for var in vartuple: print var return; # 调用printinfo 函数printinfo( 10 );printinfo( 70, 60, 50 );# 输出输出:10输出:706050 os 模块操作文件和目录重命名和删除文件Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。 os.rename()1234import os # 重命名文件test1.txt到test2.txt。os.rename( &quot;test1.txt&quot;, &quot;test2.txt&quot; ) os.remove()1234import os # 删除一个已经存在的文件test2.txtos.remove(&quot;test2.txt&quot;) 目录操作mkdir() 创建目录使用os模块的mkdir()方法在当前目录下创建新的目录 1234import os # 创建目录testos.mkdir(&quot;test&quot;) chdir() 切换目录用chdir()方法来改变当前的目录 1234567import os # getcwd() 获取当前目录print os.getcwd()# 将当前目录改为&quot;/home/newdir&quot;os.chdir(&quot;/home/newdir&quot;) rmdir() 删除目录rmdir()方法删除目录，目录名称以参数传递。 在删除这个目录之前，它的所有内容应该先被清除。 1234import os # 删除”/tmp/test”目录os.rmdir( &quot;/tmp/test&quot; ) Python 类属性与方法类的私有属性private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.private_attrs。 类的方法在类的内部，使用 def 关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数 self,且为第一个参数 类的私有方法private_method：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 self.private_methods 1234567891011121314151617#!/usr/bin/env python# -*- coding: UTF-8 -*- class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print self.__secretCount counter = JustCounter()counter.count()counter.count()print counter.publicCountprint counter.__secretCount # 报错，实例不能访问私有变量 输出： 1234567122Traceback (most recent call last): File &quot;test.py&quot;, line 17, in &lt;module&gt; print counter.__secretCount # 报错，实例不能访问私有变量AttributeError: JustCounter instance has no attribute &apos;__secretCount&apos; 访问私有属性Python不允许实例化的类访问私有数据，但你可以使用 object._className__attrName（ 对象名._类名__私有属性名 ）访问属性 1234567891011#!/usr/bin/env python# -*- coding: UTF-8 -*-class private_var: __site = &quot;访问私有属性成功&quot;my_var = private_var()print my_var._private_var__site# 输出：访问私有属性成功 单下划线、双下划线、头尾双下划线区别 __foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。 _foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Python学习笔记03","date":"2019-08-01T14:37:52.877Z","path":"20190801/python-study-notes-03.html","text":"判断python字典中key是否存在的两种方法使用自带函数实现python的字典的属性方法里面有一个has_key()方法，可以直接判断字典中是否有某个key 12345&gt;&gt;&gt; dic = &#123;&quot;name&quot;:&quot;duanmuxu&quot;, &quot;sex&quot;:&quot;male&quot;&#125;&gt;&gt;&gt; dic.has_key(&quot;name&quot;)True&gt;&gt;&gt; dic.has_key(&quot;address&quot;)False in方法做判断12345&gt;&gt;&gt; dic = &#123;&quot;name&quot;:&quot;duanmuxu&quot;, &quot;sex&quot;:&quot;male&quot;&#125;&gt;&gt;&gt; &quot;name&quot; in dic.keys()True&gt;&gt;&gt; &quot;address&quot; in dic.keys()False 同理，not in 方法也可做判断 12345&gt;&gt;&gt; dic = &#123;&quot;name&quot;:&quot;duanmuxu&quot;, &quot;sex&quot;:&quot;male&quot;&#125;&gt;&gt;&gt; &quot;name&quot; not in dic.keys()False&gt;&gt;&gt; &quot;address&quot; not in dic.keys()True input()和raw_input()的区别版本差异 Python2.X 中input()和raw_input()都可使用 Python3.X 中只能使用input(),raw_input()已经与input()结合了 输入格式差异 以下代码使用Python2.X版本实现 raw_input()123456789101112&gt;&gt;&gt; name= raw_input(&apos;输入姓名：&apos;)输入姓名：duanmuxu&gt;&gt;&gt; name&apos;duanmuxu&apos;&gt;&gt;&gt; type(name)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; age= raw_input(&apos;输入年龄：&apos;)输入年龄：21&gt;&gt;&gt; age&apos;21&apos;&gt;&gt;&gt; type(age)&lt;type &apos;str&apos;&gt; 对于任何类型的数据都是直接输入，返回一个字符串类型的变量 input()123456789101112131415161718&gt;&gt;&gt; name= input(&apos;输入姓名：&apos;)输入姓名：duanmuxuTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;duanmuxu&apos; is not defined&gt;&gt;&gt; name= input(&apos;输入姓名：&apos;)输入姓名：&apos;duanmuxu&apos;&gt;&gt;&gt; name&apos;duanmuxu&apos;&gt;&gt;&gt; type(name)&lt;type &apos;str&apos;&gt;&gt;&gt;&gt; age= input(&apos;输入年龄：&apos;)输入年龄：21&gt;&gt;&gt; age21&gt;&gt;&gt; type(age)&lt;type &apos;int&apos;&gt; 需要根据输入数据的类型进行输入，字符串型数据输入时加上 ‘ ‘，数字就是数字 使用场景 输入的类型为字符的时候可以用raw_input()，当然不怕麻烦也可以用input()手动加引号 int类型的时候最好用input() Python 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。 choice() 函数描述choice() 方法返回一个列表，元组或字符串的随机项。 使用12345import randomrandom.choice(seq)# seq -- 可以是一个列表，元组或字符串。 实例123456789#!/usr/bin/env pythonimport randomprint &quot;choice([1, 2, &apos;a&apos;, &apos;b&apos;]) : &quot;, random.choice([1, 2, &apos;a&apos;, &apos;b&apos;])print &quot;choice(&apos;String&apos;) : &quot;, random.choice(&apos;String&apos;)# 输出：choice([1, 2, &apos;a&apos;, &apos;b&apos;]) : achoice(&apos;String&apos;) : S randrange() 函数描述randrange() 方法返回指定递增基数集合中的一个随机数，基数缺省值为1。 使用123import randomrandom.randrange ([start,] stop [,step]) start – 指定范围内的开始值，包含在范围内。 stop – 指定范围内的结束值，不包含在范围内。 step – 指定递增基数。 实例12345678910111213#!/usr/bin/env python#-*- coding:utf-8 -*-import random# 输出 100 &lt;= number &lt; 1000 间的偶数print &quot;randrange(100, 1000, 2) : &quot;, random.randrange(100, 1000, 2)# 输出 100 &lt;= number &lt; 1000 间的其他数print &quot;randrange(100, 1000, 3) : &quot;, random.randrange(100, 1000, 3)# 输出：randrange(100, 1000, 2) : 762randrange(100, 1000, 3) : 532 random() 函数描述random() 方法返回随机生成的一个实数，它在[0,1)范围内。 使用123import randomrandom.random() 实例1234567891011#!/usr/bin/env python#-*- coding:utf-8 -*-import randomfor i in range(0, 3): print &quot;第%s个随机数:&quot; %(i+1) , random.random() # 输出：第1个随机数: 0.683753845699第2个随机数: 0.146315223384第3个随机数: 0.328288508196 seed() 函数描述seed() 方法改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数。 Random初始化的时候，可以以一个INT32作为参数，称为seed，MSDN上的解释是：“伪随机数是以相同的概率从一组有限的数字中选取的……随机数的生成是从种子值开始……” 也就是说，当seed的值设为一样时，所产生的随机数也是相同的。 使用123import randomrandom.seed ( [x] ) x – 改变随机数生成器的种子seed。 实例123456789101112#!/usr/bin/env python#-*- coding:utf-8 -*-import randomfor i in range(0, 3): random.seed(5) print &quot;第%s个随机数:&quot; %(i+1) , random.random() # 输出：第1个随机数: 0.62290169489第2个随机数: 0.62290169489第3个随机数: 0.62290169489 shuffle() 函数描述shuffle() 方法将序列的所有元素随机排序。 使用123import randomrandom.shuffle (lst ) lst – 可以是一个列表。 实例12345678910111213#!/usr/bin/env python#-*- coding:utf-8 -*-import randomli = [1, 2, 3, 4, 5]for i in range(1, 4): random.shuffle(li) print &quot;第%s次随机排序列表，结果是：&quot; %i , li # 输出：第1次随机排序列表，结果是： [4, 1, 2, 3, 5]第2次随机排序列表，结果是： [4, 3, 2, 5, 1]第3次随机排序列表，结果是： [1, 3, 4, 5, 2] uniform() 函数描述uniform() 方法将随机生成下一个实数，它在 [x, y] 范围内。 使用123import randomrandom.uniform(x, y) x – 随机数的最小值，包含该值。 y – 随机数的最大值，不包含该值。 返回一个浮点数 N，取值范围为如果 x&lt;y 则 x &lt;= N &lt; y，如果 y&lt;x 则y &lt;= N &lt; x。 实例12345678#!/usr/bin/env python#-*- coding:utf-8 -*-import randomprint &quot;uniform(3, 6)生成的随机数为：&quot;,random.uniform(3, 6)# 输出uniform(3, 6)生成的随机数为： 3.71157971278 r/R 打印原始字符串有时候字符串中带有 \\n 、 \\t 等特殊字符，会被识别成特殊操作而不被输出。此时在字符串前加上 r/R 即可打印原始字符串 1234567&gt;&gt;&gt; print &quot;原始字符串\\n&quot;原始字符串&gt;&gt;&gt; print r&quot;原始字符串\\n&quot;原始字符串\\n&gt;&gt;&gt; print R&quot;原始字符串\\n&quot;原始字符串\\n 三引号（triple quotes）python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。 12345678910111213141516171819HTML_wd = &apos;&apos;&apos;&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;&apos;&apos;&apos;print HTML_wd# 输出：&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt; 所见即所得 直接赋值(=)、浅拷贝(copy)和深度拷贝(deepcopy) 直接赋值：其实就是对象的引用（别名）。 浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。 深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。 直接上例子 1234567891011121314151617181920212223#!/usr/bin/env python# -*-coding:utf-8 -*- import copya = [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]] #原始对象 b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象aa[4].append(&apos;c&apos;) #修改对象a中的[&apos;a&apos;, &apos;b&apos;]数组对象 print( &apos;a = &apos;, a )print( &apos;b = &apos;, b )print( &apos;c = &apos;, c )print( &apos;d = &apos;, d )# 输出：(&apos;a = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5])(&apos;b = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], 5])(&apos;c = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]])(&apos;d = &apos;, [1, 2, 3, 4, [&apos;a&apos;, &apos;b&apos;]]) b = a: 赋值引用，a 和 b 都指向同一个对象。 b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象还是指向统一对象（是引用）。 b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Python学习笔记02","date":"2019-07-31T15:29:56.330Z","path":"20190731/python-study-notes-02.html","text":"strip()方法strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 1234567&gt;&gt;&gt; x=&quot;01013434343430101010&quot;&gt;&gt;&gt; x.strip(&apos;01&apos;)&apos;343434343&apos;&gt;&gt;&gt; x.strip(&apos;014&apos;)&apos;343434343&apos;&gt;&gt;&gt; x.strip(&apos;013&apos;)&apos;4343434&apos; // 运算符取整除 —— 返回商的整数部分（向下取整） 123456789101112131415&gt;&gt;&gt; a=13&gt;&gt;&gt; a/26&gt;&gt;&gt; a//26&gt;&gt;&gt; b=13.5&gt;&gt;&gt; b/26.75&gt;&gt;&gt; b//26.0&gt;&gt;&gt; c=-9.5&gt;&gt;&gt; c/2-4.75&gt;&gt;&gt; c//2-5.0 pow() 函数pow() 方法返回 xy（x的y次方） 的值。 123456&gt;&gt;&gt; x = 3&gt;&gt;&gt; y = 5&gt;&gt;&gt; pow(x, y)243&gt;&gt;&gt; pow(y, x)125 for循环通过序列索引迭代遍历1234567891011#!/usr/bin/env python# -*- coding: UTF-8 -*-food = [&quot;rise&quot;, &quot;noodle&quot;, &quot;Hamburg&quot;]for i in range(len(food)): print &quot;晚饭是：&quot; + food[i] # 输出：晚饭是：rise晚饭是：noodle晚饭是：Hamburg 循环使用 else 语句在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。 123456789101112131415161718192021222324#!/usr/bin/python# -*- coding: UTF-8 -*- for num in range(10,20): # 迭代 10 到 20 之间的数字 for i in range(2,num): # 根据因子迭代 if num%i == 0: # 确定第一个因子 j=num/i # 计算第二个因子 print &apos;%d 等于 %d * %d&apos; % (num,i,j) break # 跳出当前循环 else: # 循环的 else 部分 print num, &apos;是一个质数&apos; # 结果：10 等于 2 * 511 是一个质数12 等于 2 * 613 是一个质数14 等于 2 * 715 等于 3 * 516 等于 2 * 817 是一个质数18 等于 2 * 919 是一个质数 pass 语句pass 是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。 运用一123456789101112131415161718#!/usr/bin/env python# -*- coding: UTF-8 -*- # 输出 Python 的每个字母for letter in &apos;Python&apos;: if letter == &apos;h&apos;: pass print &apos;这是 pass 块&apos; print &apos;当前字母 :&apos;, letter # 输出：当前字母 : P当前字母 : y当前字母 : t这是 pass 块当前字母 : h当前字母 : o当前字母 : n 运用二12def sample(n_samples): pass 在 Python 中有时候会看到一个 def 函数，该处的 pass 便是占据一个位置，因为如果定义一个空函数程序会报错，当你没有想好函数的内容是可以用 pass 填充，使程序可以正常运行。","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Python学习笔记01","date":"2019-07-30T15:57:09.952Z","path":"20190730/python-study-notes-01.html","text":"Python头部 #!/usr/bin/python和 #!/usr/bin/env python 的区别1#!/usr/bin/env python 这样声明的时候，会去取你机器的 PATH 中指定的第一个 python 来执行你的脚本。 1#!/usr/bin/python 表示写死了就是要 /usr/bin/python 这个目录下 python 来执行你的脚本。这样写程序的可移植性就差了，如果此路径下python命令不存在就会报错。 所以一般情况还是用第一种写法。 Python中文编码Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。 解决方法为只要在文件开头加入 # -*- coding: UTF-8 -*- 或者 # coding=utf-8 就行了 1234#!/usr/bin/env python# -*- coding: UTF-8 -*- print &quot;Hello，world&quot;; Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。 Python 标识符 在 Python 里，标识符由字母、数字、下划线组成。 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。 Python 中的标识符是区分大小写的。 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。 以双下划线开头的 foo 代表类的私有成员，以双下划线开头和结尾的 __foo 代表 Python 里特殊方法专用的标识，如 init() 代表类的构造函数。 Python 可以同一行显示多条语句，方法是用分号 ; 分开。 多行语句Python语句中一般以新行作为语句的结束符。 但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下： 12345678910#! /usr/bin/evn pythonmy_name = &quot;duan&quot; + \\ &quot;mu&quot; + \\ &quot;xu&quot; print my_name# 输出duanmuxu 标准数据类型 Numbers（数字） String（字符串） List（列表） Tuple（元组） Dictionary（字典） 四种数字类型 int（有符号整型） long（长整型[也可以代表八进制和十六进制]） float（浮点型） complex（复数） 字符串（string）截取使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 [头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。 123456789101112131415161718192021222324#! /usr/bin/evn python# -*- coding: UTF-8 -*- str = &apos;abcdefghijklmn&apos; print str # 输出完整字符串print str[0] # 输出字符串中的第一个字符print str[2:5] # 输出字符串中第三个至第六个之间的字符串print str[2:-2] # 输出字符串中第三个至倒数第三个的字符串print str[2:] # 输出从第三个字符开始的字符串print str * 2 # 输出字符串两次print str + &quot;TEST&quot; # 输出连接的字符串print str[2::3] # 输出从第三个字符开始，以3为截取步长的字符串# 执行结果abcdefghijklmnacdecdefghijklcdefghijklmnabcdefghijklmnabcdefghijklmnabcdefghijklmnTESTcfil Python列表 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。 列表用 [ ] 标识，是 python 最通用的复合数据类型。 列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。 Python 元组元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。 Python 字典 列表是有序的对象集合，字典是无序的对象集合。 两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典用”{ }”标识。字典由索引(key)和它对应的值value组成。 int() 函数int() 函数用于将一个字符串或数字转换为整型。 1class int(x, base=10) x – 字符串或数字。 base – 进制数，默认十进制。 返回整型数据。 long(x, base)函数也一样 tuple() 函数将列表转换为元组 1234567891011&gt;&gt;&gt;tuple([1,2,3,4]) (1, 2, 3, 4) &gt;&gt;&gt; tuple(&#123;1:2,3:4&#125;) #针对字典 会返回字典的key组成的tuple (1, 3) &gt;&gt;&gt; tuple((1,2,3,4)) #元组会返回元组自身 (1, 2, 3, 4) set() 函数 set() 函数创建一个无序不重复元素集，可进行关系测试，删除重复数据，还可以计算交集、差集、并集等 返回新的集合对象 123456789101112&gt;&gt;&gt; x=set(&apos;1234312&apos;)&gt;&gt;&gt; x&#123;&apos;1&apos;, &apos;3&apos;, &apos;2&apos;, &apos;4&apos;&#125;&gt;&gt;&gt; y=set(&apos;4567657&apos;)&gt;&gt;&gt; y&#123;&apos;4&apos;, &apos;5&apos;, &apos;7&apos;, &apos;6&apos;&#125;&gt;&gt;&gt; x &amp; y # 交集&#123;&apos;4&apos;&#125;&gt;&gt;&gt; x | y # 并集&#123;&apos;4&apos;, &apos;7&apos;, &apos;6&apos;, &apos;2&apos;, &apos;1&apos;, &apos;3&apos;, &apos;5&apos;&#125;&gt;&gt;&gt; x - y # 差集&#123;&apos;1&apos;, &apos;3&apos;, &apos;2&apos;&#125; chr() 函数、ord() 函数 chr() 用一个范围在 range（256）内的（就是0～255）整数作参数，返回一个对应的字符。 ord() 函数以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值，如果所给的 Unicode 字符超出了你的 Python 定义范围，则会引发一个 TypeError 的异常。 12345&gt;&gt;&gt; chr(48)&apos;0&apos;&gt;&gt;&gt; ord(&apos;c&apos;)99 hex() 函数hex() 函数用于将10进制整数转换成16进制，以字符串形式表示。 1234&gt;&gt;&gt; hex(12)&apos;0xc&apos;&gt;&gt;&gt; type(hex(12))&lt;class &apos;str&apos;&gt; oct() 函数oct() 函数将一个整数转换成8进制字符串。 12&gt;&gt;&gt; oct(15)&apos;017&apos;","tags":[{"name":"Python","slug":"Python","permalink":"http://www.duanmuxu.top/tags/Python/"}]},{"title":"Shell学习11：Shell小记","date":"2019-06-30T09:10:27.777Z","path":"20190630/shell-learning-11-notes.html","text":"echo -e 参数若echo的字符串参数中出现以下字符，则特别加以处理，而不会将它当成一般文字输出： 12345678910\\a 发出警告声； \\b 删除前一个字符； \\c 最后不加上换行符号； \\f 换行但光标仍旧停留在原来的位置； \\n 换行且光标移至行首； \\r 光标移至行首，但不换行； \\t 插入tab； \\v 与\\f相同； \\ 插入\\字符； \\nnn 插入nnn（八进制）所代表的ASCII字符； echo -e实例123str1=&quot;test1\\n&quot;str2=&quot;test2&quot;echo $str1$str2 没有 -e 输出为 1test1\\ntest2 带 -e 输出为 12test1test2 关于/r与/n 以及 /r/n 的区别来源在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。 区别\\r就是回到行首，\\n就是到下一行的，但是一般我们输出程序时，看不到明显的差别的 ‘\\r’是回车，’\\n’是换行，前者使光标到行首，后者使光标下移一格。通常用的Enter是两个加起来。 对于cprintf和sprintf来说，你如果要换行的话，你要输入”\\r\\n”而对于printf不说，换行只要”\\r”就可以了。一个是回车，一个是换行ASCII码一个是10一个是13。 \\r\\n与\\n是有区别的。如果要通用的则是\\r\\n，因为有些编辑器它不认\\n echo 中 -c 命令表示不换行，搭配 -e 使用 1234567891011# 脚本内容#!/bin/shecho -e &quot;first line！ \\c&quot; # -e 开启转义 \\c 不换行echo &quot;second line！&quot;# 输出结果first line！second line！# 若没有 -c ,则输出结果为first line！second line！ 文件检测命令 命令 作用 -b file 检测文件是否是块设备文件，如果是，则返回 true。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 -d file 检测文件是否是目录，如果是，则返回 true。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true -p file 检测文件是否是有名管道，如果是，则返回 true -u file 检测文件是否设置了 SUID 位，如果是，则返回 true -r file 检测文件是否可读，如果是，则返回 true -w file 检测文件是否可写，如果是，则返回 true -x file 检测文件是否可执行，如果是，则返回 true -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true -e file 检测文件（包括目录）是否存在，如果是，则返回 true -S 判断某文件是否 socket。 -L 检测文件是否存在并且是一个符号链接。 ## test 命令 test命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试 #### 数值与字符检测 参数与前面讲的运算符中关系运算符和字符串运算符一样，只是将表达式中外部的[] 换成了 test而已，如以下例子： 12345678910111213141516171819202122232425#！ /bin/bashnum1=100num2=100if test $[num1] -eq $[num2]then echo &apos;两个数相等！&apos;else echo &apos;两个数不相等！&apos;fi# 输出结果为两个数相等！# 执行结果与将 test 换成 [ ] 后一样num1=100num2=100if [ $[num1] -eq $[num2] ]then echo &apos;两个数相等！&apos;else echo &apos;两个数不相等！&apos;fi# 输出结果为两个数相等！ 文件测试参数为上一条文件检测命令的参数，直接上例子 12345678#！/bin/bashif test -e ./notFile -o -e ./bashthen echo &apos;至少有一个文件存在!&apos;else echo &apos;两个文件都不存在&apos;fi 文件测试中还支持 -o 与 -a 来连接多个表达式。优先级为：！&gt; -a &gt; -o let 命令let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 123456a=5let &quot;a++&quot; # 这里的变量a加不加双引号都可以echo $a# 输出为6 文件包含简单说就是一个脚本中调用其他脚本，直接上例子： 1234# 脚本one.sh#!/bin/bash one=&quot;the is one in file one.sh&quot; 1234# 脚本two.sh#!/bin/bash one=&quot;the is two in file two.sh&quot; 123456789# 脚本three.sh#!/bin/bash #以下包含文件的两种方法等效，推荐使用source关键字. one.sh # 文件路径source two.sh echo $oneecho $two 123# 执行脚本 three.sh，输出为the is one in file one.shthis is two in file two.sh 连接FTP直接上例子 1234567ftp -i -n $&#123;HOST&#125; &lt;&lt;! user $&#123;user&#125; $&#123;passwd&#125; lcd $&#123;local_file&#125; cd $&#123;tar_file&#125; mput *quit! -i 在多个文件传输期间关闭交互提示 使用 -n 选项连接ftp客户端以阻止ftp客户端立即登录.这样,ftp客户端就不要你输入一个用户名和密码了 HOST 是要连接的主机号 user user passwd 输入连接的主机用户名和相应密码 lcd 表示本地需要传输的文件路径 cd 表示目标主机需要接收文件的路径 mput 表示将本地文件路径下的所有文件都传输过去，如果只需要传输一个文件，则使用put命令 quit 退出本次连接","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习10：输入、输出重定向","date":"2019-06-30T08:26:34.401Z","path":"20190630/shell-learning-10-input-output-redirection.html","text":"大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到你的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向命令列表 命令 说明 command &gt; file 将输出重定向到 file command &lt; file 将输入重定向到 file command &gt;&gt; file 将输出以追加的方式重定向到 file n &gt; file 将文件描述符为 n 的文件重定向到 file n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file n &gt;&amp; m 将输出文件 m 和 n 合并 n &lt;&amp; m 将输入文件 m 和 n 合并 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR） ## 输出重定向 前面讲echo命令的时候有提到过 &gt; 与 &gt;&gt; 的区别。现在清楚了，这就是输出重定向的命令。 &gt; 表示将 conmand 的执行结果存入file中，文件覆盖，&gt;&gt; 表示文件内容追加，不覆盖。 ## 输入重定向 与输出重定向相反，输入重定向就是从文件获取输入 1command &lt; file 这样，本来需要从键盘获取输入的命令会转移到文件读取内容。 1234567891011# 统计文件行数wc -l users# 输出为2 users# 统计文件行数wc -l &lt; users# 输出2 以上两个例子都是为了统计users 文件中的行数，区别在于加了 &lt; 符号的例子仅仅从标准输入读取内容，不读取文件名称。 1command &lt; infile &gt; outfile 以上命令可以同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。 标准文件重定向上面刚讲过，一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件 标准输入文件(stdin)：stdin的文件描述符为0 标准输出文件(stdout)：stdout 的文件描述符为1 标准错误文件(stderr)：stderr的文件描述符为2默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file，这两个也是常用的，那么如果想把标准错误文件重定向该怎么办呢？ 可以通过以下命令实现： 123456789101112# stderr 重定向到 filecommand 2 &gt; file# stderr 追加到 file 文件末尾command 2 &gt;&gt; file# stdout 和 stderr 合并后重定向到 filecommand &gt; file 2&gt;&amp;1command &gt;&gt; file 2&gt;&amp;1# 对 stdin 和 stdout 都重定向command &lt; file1 &gt;file2 Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。基本形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command 直接上例子： 1234567891011121314# 通过 wc -l 计算文件行数#! /bin/bashwc -l &lt;&lt; EOF 一别都门三改火，天涯踏尽红尘。 依然一笑作春温。 无波真古井，有节是秋筠。 惆怅孤帆连夜发，送行淡月微云。 尊前不用翠眉颦。 人生如逆旅，我亦是行人。EOF# 输出为6 /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null 1command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果 123# 屏蔽 stdout 和 stderrcommand &gt; /dev/null 2&gt;&amp;1 最重要的就是要记住文件描述符 0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习09：函数","date":"2019-06-30T03:58:08.965Z","path":"20190630/shell-learning-09-function.html","text":"概述shell 中可以用户定义函数，然后在shell脚本中可以随便调用。函数定义格式： 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 实例123456789101112131415# 定义函数并调用#! /bin/bashdemoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot;# 执行脚本结果：-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- 带有返回参数的例子： 12345678910111213#!/bin/bashfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 输出结果为 1234567这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 ! 函数返回值在调用该函数后通过 $? 来获得。 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 函数参数在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 123456789101112#! /bin/bashfunWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出结果为： 1234567第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 值得注意的是，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习08：流程控制","date":"2019-06-30T03:32:43.921Z","path":"20190630/shell-learning-08-process-control.html","text":"shell中的流程控制不能为空 if elseif 语句格式1234567if conditionthen command1 command2 ... commandN fi 写成一行的形式，除了最后一个fi，每个语句后面都需要加上 ;进行语句分割，否则会报错 1if [ &quot;lop&quot; = &quot;lop&quot; ]; then echo &quot;true&quot;; fi if else 语句格式前面说过流程控制不能为空，即如果if条件中else 的值为空，那么else就不要写。因此if 与if else 分开来讲。 123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else 语句格式123456789if condition1then command1elif condition2 then command2else commandNfi for 循环语句格式 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 实例 1234567891011for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done# 输出为The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 也可以使用以下形式的语句 1234567891011for ((i=1;i&lt;=5;i++))do echo $idone# 输出为12345 while 循环用于循环判断/读取信息，直到判断条件为假时退出。语句格式： 1234while conditiondo commanddone while还可以和read命令连用，用于循环读取信息 123456echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;echo -n &apos;输入你的名字： &apos;while read NAMEdo echo &quot;你好！$&#123;NAME&#125;!&quot;done 这种方法会造成无限死循环，因此需要 CTRL-D 退出 无限循环除了上面讲的通过while与read连用造成无限循环外，还可以使用下面几种方法进入无限循环 1234567891011121314# 1while :do commanddone# 2while truedo commanddone# 3for (( ; ; )) until 循环与while 循环在处理方式上正好相反，until 循环执行一系列命令直至条件为 true 时停止。语句格式：condition条件为假则一直执行 1234until conditiondo commanddone case多选择语句，可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。语句格式： 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 举个栗子 123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac 输入不同的内容，会有不同的结果，例如： 1234输入 1 到 4 之间的数字:你输入的数字为:2你选择了 2 esac作为case 语句的结束标志，与前面if 语句的fi 异曲同工。并且每个case分支用右圆括号，用两个分号表示break。 跳出循环break 命令break命令允许跳出所有循环（终止执行后面的所有循环），直接上例子 12345678910111213#! /bin/bashwhile read numdo echo &quot;你输入的数字为：$&#123;num&#125;&quot; if [ $&#123;num&#125; -eq 2] then echo &quot;输入正确！&quot; break else echo &quot;输入错误，请重新输入：&quot; fidone 123456789101112131415# 执行脚本sh test.sh3# 输出为你输入的数字为：3输入错误，请重新输入：# 执行脚本sh test.sh2# 输出为你输入的数字为：2输入正确！ continue 命令与break类似，但是不会跳出所有循环，仅仅跳出当前循环。 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read Num case $Num in 1|2|3|4|5) echo &quot;你输入的数字为 $Num!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; ;; esacdone 运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “游戏结束” 永远不会被执行。","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习07：read、echo和printf命令","date":"2019-06-29T16:47:14.861Z","path":"20190630/shell-learning-07-read-echo-and-printf-commands.html","text":"readread 命令用于一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。 实例及参数说明： 123456789101112# 脚本 test.sh 内容read firstStr secondStrecho &quot;第一个参数:$&#123;firstStr&#125; 第二个参数:$&#123;secondStr&#125;&quot;# 执行脚本 test.shsh test.sh one two three# 输出第一个参数:one 第二个参数:two three read 参数说明： -p 输入提示文字 -n 输入字符长度限制(达到6位，自动结束) -t 输入限时 -s 隐藏输入内容实例： 123456789101112# 脚本 test.sh 内容read -p &quot;请输入一段文字:&quot; -n 6 -t 5 -s passwordecho -e &quot;\\npassword is $password&quot;# 执行脚本 test.shsh test.sh 请输入一段文字:123456789# 输出password is 123456789 echo从之前学习的例子看来，echo就是用于字符串的输出，这个字符串可以直接是字符串，也可以是变量。 具体的功能有以下几种： 显示普通字符串12345678# 这里字符串加不加双引号结果都是一样的echo &quot;It is a test&quot;echo It is a test# 输出： It is a test 显示转义字符123456echo &quot;\\&quot;It is a test\\&quot;&quot;echo \\&quot;It is a test\\&quot; # 双引号也可以省略# 输出： It is a test 显示变量有两种情况，一种是通过read命令读取用户输入的变量，然后输出；一种是脚本内部的变量，相当于字符串。 123456789101112# 用户输入变量#! /bin/shread name echo &quot;My name is $&#123;name&#125;&quot;# 执行sh test.shJerry# 输出My name is Jerry 12345678# 脚本内部变量#! /bin/shtime=$(date) echo &quot;time is $&#123;time&#125;&quot;# 直接执行脚本并输出：Sat Jun 29 15:41:38 UTC 2019 显示命令执行结果以上通过变量获取时间再输出的方式，可以直接把获取时间的命令放在echo中输出： 12345# 脚本内容echo `date`# 输出 Sat Jun 29 15:41:38 UTC 2019 输出结果到文件中通常用在写日志里 123# 脚本内容echo &quot;time is `date`&quot; &gt; filenameecho &quot;time is `date`&quot; &gt;&gt; filename 表示将echo的内容写进 filename文件中，若文件中已有内容，先删除后添加 表示将echo 的内容追加到 filename 文件中，不删除文件原有内容 printf学过C语言的应该都知道C的输出命令最常用的就是printf了，Shell中的printf也差不多，可以给输出的内容指定类型，具体语法如下： 1234printf format-string [arguments...]- format-string: 为格式控制字符串- arguments: 为参数列表 举个例子 123456#！ /bin/bashprintf &quot;%-10s %-8s %-4.2f\\n&quot; Jerry 男 62.2223# 输出为：Jerry 男 62.22 %s %c %d %f都是格式替代符 d: Decimal 十进制整数 – 对应位置参数必须是十进制整数 s: String 字符串 – 对应位置参数必须是字符串或者字符型 c: Char 字符 – 对应位置参数必须是字符串或者字符型 f: Float 浮点 – 对应位置参数必须是数字型 例子中的%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来；%-4.2f 指格式化为小数，其中.2指保留2位小数。 更多实例说明： 12345678910111213141516# 1.格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf &quot;%s %s %s\\n&quot; a b c d e f g h i j# 输出为a b cd e fg h ij # 2.如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \\n&quot; # 输出为 and 0","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习06：运算符汇总","date":"2019-06-28T15:52:54.730Z","path":"20190628/shell-learning-06-operator-summary.html","text":"数学运算原生bash不支持直接的数学运算 12345678# 若直接执行以下脚本#！ /bin/bashvar=$(3 + 4)echo &quot;两数之和为$&#123;var&#125;&quot;# 执行脚本，得到下面报错信息command not found 虽然不支持直接的数学运算，但是可以通过命令来实现数学运算。通常使用expr 命令来进行数学运算，expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 12345678# 执行以下脚本#！ /bin/bashvar=$(expr 3 + 4)echo &quot;两数之和为$&#123;var&#125;&quot;# 执行脚本，得到以下结果两数之和为 : 7 需要注意的是： 表达式和运算符之间要有空格，例如 3+4 是不对的，得出来的结果是“两数之和为 : 3+4”必须写成 3 + 4才能得到正确的运算结果； 表达式要被$() 或者 (反引号)包含，表示执行这一运算操作。 算术运算符与我们平时使用的运算符相同 加法 + 减法 - 乘法 * 除法 / 取余 % 赋值 = 相等 == 不相等 != 使用算术运算符时也需要注意以下几点： 条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]; 乘号(*)前边必须加反斜杠(\\ )才能实现乘法运算，[ 4 \\ * 5 ]; 关系运算符重点来啦 运算符 作用 -eq 判断两个数是否相等，相等返回 true -ne 判断两个数是否不相等，不相等返回 true -gt 判断左边的数是否大于右边的，如果是，则返回 true -lt 判断左边的数是否小于右边的，如果是，则返回 true -ge 判断左边的数是否大于等于右边的，如果是，则返回 true -le 判断左边的数是否小于等于右边的，如果是，则返回 true 注意，以上关系运算符只支持数字或者值为数字的字符串，不支持除了值为数字以外的字符串。 布尔运算符 运算符 作用 ！ 非运算，表达式为 true 则返回 false，否则返回 true -o 或运算，有一个表达式为 true 则返回 true -a 与运算，两个表达式都为 true 才返回 true 实例： 12345678910111213141516171819202122232425262728293031323334353637383940#！ /bin/bashvalue1=0value2=5value3=10if [ ! $&#123;value1&#125; ]then echo &quot;! 起作用啦&quot;else echo &quot;! 没有起作用&quot;fiif [ $&#123;value2&#125; -o $&#123;value1&#125; ]then echo &quot;$&#123;value1&#125; 或 $&#123;value2&#125; 为真&quot;else echo &quot;$&#123;value1&#125; 或 $&#123;value2&#125; 为假&quot;fiif [ $&#123;value1&#125; -a $&#123;value2&#125; ]then echo &quot;$&#123;value1&#125; 与 $&#123;value2&#125; 为真&quot;else echo &quot;$&#123;value1&#125; 与 $&#123;value2&#125; 为假&quot;fiif [ $&#123;value1&#125; -a $&#123;value3&#125; == $&#123;value2&#125; ]then echo &quot;$&#123;value1&#125; 与 $&#123;value3&#125; 为真&quot;else echo &quot;$&#123;value1&#125; 与 $&#123;value3&#125; 为假&quot;fi# 结果为! 没有起作用0 或 5 为真0 与 5 为真0 与 10 为假 从结果可以看出，这与我们平时 ！ 运算的要求不大一样，平时编程时 !0 即为真，但在shell里，0 为字符串，真实存在的即为真，所以 !0 为假。因此只有通过其他运算符判断为假的表达式和!共用才能整体判断为真。如if [ ${value1} -a ${value3} == ${value2} ]例子所示。 字符串运算符 运算符 作用 = 判断两个字符串是否相等，相等返回 true != 判断两个字符串是否相等，不相等返回 true -z （zero）判断字符串长度是否为0，为0返回 true -n 判断字符串长度是否为0，不为0返回 true $ 判断字符串是否为空，不为空返回 true 与上面布尔运算符不同，字符串运算符的两边为字符串，布尔运算符的两边为判断结果为true 或 false 的布尔变量。 逻辑运算符与Java相同，&amp;&amp; 表示 逻辑与，|| 表示逻辑或","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习05：参数传递","date":"2019-06-26T15:44:57.067Z","path":"20190626/shell-learning-05-parameter-passing.html","text":"概述执行脚本时，可以向脚本里面传递参数，脚本可以根据传递的参数进行进一步操作。 脚本内获取参数的格式为：$n。n代表一个数字，比如 $1 表示传进来的第一个参数，$2 表示传进来的第二个参数，以此类推。 实例创建脚本并添加内容 12touch chuancan.shvim chuancan.sh 1234567#!/bin/bashecho &quot;Shell 传递参数&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 设置可执行权限，并执行脚本： 123456789101112# 设置可执行权限chmod +x chuancan.sh# 执行文件./chuancan.sh 参数一 参数二 参数三# 输出结果Shell 传递参数执行的文件名：./chuancan.sh第一个参数为：参数一第二个参数为：参数二第三个参数为：参数三 参数处理 $# : 表示传递参数的个数 $* : 字符串形式展示传递给脚本的所有参数 $$ : 当前脚本运行的当前进程ID号 $@ : 与$* 相同，但是使用时会给每个参数加引号，在引号中返回每个参数 $? : 显示最后命令的退出状态，0表示没有错误，其他值都表示有错误。 参数处理实例12345678910111213141516171819202122232425#!/bin/bashecho &quot;Shell 传递参数&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;echo &quot;$#&quot;echo &quot;$*&quot;echo &quot;$$&quot;echo &quot;$@&quot;echo &quot;$?&quot;# 输出结果为：Shell 传递参数执行的文件名：./chuancan.sh第一个参数为：参数一第二个参数为：参数二第三个参数为：参数三3参数一 参数二 参数三2437参数一 参数二 参数三0 $* 与 $@ 详解 相同点：都是引用所有参数 不同点：$* 是直接以字符串的形式输出参数字符串，$@ 则是将参数先用双引号包含，再引用双引号中的所有参数 实例： 1234567891011121314151617181920#! /bin/bashecho &quot;-- \\$* 测试 ---&quot;for i in &quot;$*&quot;; do echo &quot;$i&quot;doneecho &quot;-- \\$@ 测试 ---&quot;for i in &quot;$@&quot;; do echo &quot;$i&quot;done# 输出结果-- $* 测试 ---参数一 参数二 参数三-- $@ 测试 ---参数一参数二参数三 参数校验概述有时候我们执行带参数的脚本可能只是为了某种特殊情况才需要传入参数进行执行，比如说有个脚本作用是转移每一天的数据，执行一段时间后发现某一天的数据给没了，或者某一天执行失败但是没被发现，那么就需要传入特定的天数参数去执行脚本。 那么问题来了，既然有时候会用到参数，那么我们怎么判断脚本里是否有参数传递呢？ 其实想一想就能知道，可以用判断，如果传进来的参数不为空，那么就用传进来的参数作为执行条件，若为空，则无事发生，继续执行脚本。 简单实例创建脚本 12345678# 创建脚本touch getTime.sh# 给脚本赋权chmod +x getTime.sh# 编辑脚本vim getTime.sh 输入脚本内容 123456789#!/bin/bashnow_time=$(date +%Y%m%d)if [ $1 ];then echo &quot;现在时间为$1&quot;else echo &quot;现在时间为$&#123;now_time&#125;&quot;fi 不带参数运行： 12345# 运行脚本$ ./getTime.sh# 运行结果现在时间为20190626 带参数运行： 12345# 运行脚本$ ./getTime.sh 20190505# 运行结果现在时间为20190505 脚本内容使用if进行判断，这里注意两点：一是获取时间，$(date +%Y%m%d) 中，date 与 + 号要用空格隔开，二是判断语句中if与大括号间要用空格隔开，否则会执行失败。具体函数后面会讲，这里不做过多介绍。","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习04：Shell数据类型","date":"2019-06-25T02:14:09.511Z","path":"20190625/shell-learning-04-data-type.html","text":"字符串字符串引用Shell中引用字符串可以使用双引号，也可以使用单引号，也可以不使用引号。 双引号最常使用的引用形式就是加双引号 12str=&quot;test&quot;echo &quot;quote \\&quot;$str\\&quot;&quot; 使用双引号的优点： 双引号里可以有变量 双引号里可以出现转义字符 单引号1str=&apos;this is a string&apos; 使用单引号有所限制： 在echo命令下，单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 无引号12str=this is a stringstr=this 不使用引号只适合引用单个单词变量时使用，空格之后的字符无法识别。 字符串操作拼接字符串123456789your_name=&quot;Jerry&quot;# 使用双引号拼接greeting1=&quot;hello, &quot;$your_name&quot; !\\r&quot;greeting2=&quot;hello, $&#123;your_name&#125; !&quot;echo -e $greeting1$greeting2# 使用单引号拼接greeting3=&apos;hello, &apos;$your_name&apos; !\\r&apos;greeting4=&apos;hello, $&#123;your_name&#125; !&apos;echo -e $greeting3$greeting4 输出结果： 1234hello, Jerry !hello, Jerry !hello, Jerry !hello, $&#123;your_name&#125; ! 证明单引号中直接引用变量是无效的。 获取字符串长度1234string=&quot;abcdefg&quot;echo $&#123;#string&#125; #输出为7 提取子字符串123string=&quot;I am learning Shell!&quot;echo $&#123;string:1:5&#125; # 输出 am lecho $&#123;string:3&#125; # 输出 m learning Shell! 空格不做字符统计，使用${string:1:5}时包头不包尾。 反引号使用如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和$(命令)是一样的，但是反引号非常容易和单引号搞混，所以推荐大家使用 $(命令) 的方式引用命令的输出。 1234echo `date`#输出为：Tue Jun 25 01:43:27 UTC 2019#作用与命令 echo $(date) 相同 查找子字符串12345string=&quot;I am learning Shell!&quot;echo `expr index &quot;$string&quot; Sh`echo $(expr index &quot;$string&quot; Sh)#输出为 15 查找字符 S 的位置(哪个字母先出现就计算哪个) 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。 定义数组用括号来表示数组，数组元素用空格分割开，等号左边不能加空格 1array_name=(value0 value1 value2 value3 ...) 也可以使用空行： 1234567array_name=(value0value1value2value3...) 还可以单独定义数组的各个分量： 1234array_name[0]=value0array_name[1]=value1...array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 读取数组1$&#123;array_name[index]&#125; 通过引用数组的方式进行读取 使用 @ 获取 * 符号可以获取数组中的所有元素： 12345678array=(1 2 3 4)echo $&#123;array[2]&#125;echo $&#123;array[@]&#125;echo $&#123;array[*]&#125;#输出为31 2 3 4 获取数组长度获取数组长度的方法与获取字符串长度的方法相同： 12345678910111213141516array=(12 2 3 4)# 取得数组指定元素的长度echo $&#123;#array[2]&#125;# 取得数组元素的个数echo $&#123;#array[@]&#125;# 取得数组元素的个数echo $&#123;#array[*]&#125;# 取得数组单个元素的长度（取最大）echo $&#123;#array[n]&#125;# 输出为1442","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习03：expect实现自动输入密码登录服务器","date":"2019-06-20T15:14:46.304Z","path":"20190620/shell-learning-03-expect-to-automatically-enter-the-password-log-in-server.html","text":"我们通过Shell脚本可以实现简单的控制流功能，比如说循环、判断、对本地文件进行一些简单的操作、输入输出写日志等，但都是对于本地机器而言进行的操作。那么当我们需要在一台机器上操作另一台机器时，那该怎么办呢？ expect就是用来实现这种交互功能的工具。 expect介绍expect是Unix系统中用来进行自动化控制和测试的软件工具，作为Tcl脚本语言的一个扩展，应用在交互式软件中如telnet，ftp，Passwd，fsck，rlogin，tip，ssh等等。expect是一个免费的编程工具，用来实现自动的交互式任务，而无需人为干预。说白了，expect就是一套用来实现自动交互功能的软件，比如上面说的一台机子操作另一台机子。 在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而利用expect，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。这就是expect！ expect安装我用的是Ubuntu发行版，因此执行命令 1apt-get install expect 就ok啦，CentOS用户可以通过命令 yum install expect 安装 expect相关命令 spawn：启动新的进程 expect：从进程接收字符串（换行后系统自动打印的字符串） send：用于向进程发送字符串 interact：允许用户交互 exp_continue： 匹配多个字符串在执行动作后加此命令 expect参数1set name [lindex $argv 0] 使用[lindex $argv 0]进行读取参数，使用set将参数添加进变量中 实例详解1234567891011#!/usr/bin/expectset timeout 30set host &quot;10.11.43.90&quot;set username &quot;root&quot;set password &quot;123456&quot;spawn ssh $username@$hostexpect &quot;*password*&quot; &#123;send &quot;$password\\r&quot;&#125;interact set timeout 30：设置超时时间，单位为秒，默认情况下是10秒，也可设为-1，表示一直运作 set host/username/password：设置变量 spawn ssh $username@$host：启动新的进程，spawn主要的功能是给ssh运行进程加个壳，用来传递交互指令。这里变量的引用和Shell脚本中一致，直接使用$或者使用${}都可以 expect “password“：接受的字符串中是否包含’password’这个子串 {send “$password\\r”}：如果包含，则发送$password过去并回车，即执行交互动作 interact：执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。 expect登录其他服务器执行命令以下内容是一台机器通过ssh登录另一台机器，并在另一台机器上执行命令将以日期作为分区的文件从一个hdfs集群转移至另一个hdfs集群上。参数为一个日期，如果传了参数，则使用用户传的参数，否则使用前一天的日期作为分区标志。 1234567891011121314151617181920212223242526272829303132#! /usr/bin/expect# 设置超时时间 等待三十秒set timeout 30# 传入参数set name [lindex $argv 0]# 设置时间set date [ clock format [ clock seconds ] -format &quot;%Y%m%d&quot; ]set secon [ clock seconds ]set yestoday_secon 0 set yestoday_secon [expr &#123;$secon - 86400&#125; ]set yestoday [ clock format [ expr &#123;$yestoday_secon&#125; ] -format &quot;%Y%m%d&quot; ]if &#123;&quot;$name&quot; &gt; 0&#125; &#123; set time &quot;$name&quot;&#125; else &#123; set time &quot;$yestoday&quot;&#125;spawn ssh hadoop@10.11.43.90expect &quot;*assword&quot; send &quot;123456\\r&quot; expect &quot;hadoop&quot;send &quot;hadoop distcp hdfs://10.11.56.29/apps/hive/warehouse/location_stay/dt=$&#123;time&#125;/* /DOMAIN_B/DISNEY/LOCATION/APP/HY/location_stay/dt=$&#123;time&#125;\\r&quot;expect &quot;hadoop&quot;send &quot;exit\\r&quot;expect eofexit","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习02：Shell变量","date":"2019-06-19T13:20:22.650Z","path":"20190619/shell-learning-02-variables.html","text":"定义变量定义变量时，变量名不加美元符号($)，并且变量名和等号中不能有空格。如： 1tempVar=&quot;variable&quot; 同时，变量名的命令规则如下： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头 中间不能有空格，可以使用下划线 _ 不能使用标点符号 不能使用bash里的关键字（可用 compgen -k 命令查看保留关键字）。 使用变量使用一个定义过的变量，只要在变量名前面加$符号即可，如： 123tempVar=&quot;variable&quot;echo $tempVarecho $&#123;tempVar&#125; 变量名外面的大括号是可选的，加大括号是为了帮助解释器识别变量的边界，防止出现识别错误变量。如： 12str=&quot;shell&quot;echo &quot;I am learning $&#123;str&#125;skill&quot; 打印出来就是I am learning shellskill，如果没有大括号，则打印出来的内容是I am learning，系统识别strskill为一个变量，但并没有此变量，因此打印变量为空。所以使用变量时建议加上大括号，更为规范。 readonly 只读变量使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。如： 1234#!/bin/bashmyVar=&quot;change&quot;readonly myVarmyUrl=&quot;http://www.runoob.com&quot; 运行时报错： 1/bin/sh: NAME: This variable is read only. 删除变量使用 unset 命令就可以删除变量。 1unset myVar 变量被删除后不能再次使用。并且 unset 命令不能删除只读变量。 （当脚本文件规模不大时，要删除变量的话直接在脚本里把变量去掉就行了。） 变量类型 环境变量 本地变量 局部变量 位置变量 特殊变量（bash内置变量，也称系统变量） 环境变量1export var_name=value //作用域为当前shell进程及其子进程` 给Linux系统配置过JDK的同学应该对这个变量很熟悉 本地变量1var_name=value //本地变量，作用域为当前shell进程，对当前shell外的其他shell进程，v包括当前shell，子shell进程均无效 局部变量1local var_name=value //局部变量，作用域为当前代码段，常用于函数 局部变量也是一种本地变量 位置变量123$1,$2,$3, .... //用来引用脚本的参数shift [num] //位置变量使用完以后退出，后面的参数向前推进 shift 1 //一次往前推，例：$1完成任务后变成$2执行 特殊变量1234567$# //是传给脚本的参数个数$0 //是脚本本身的名字$! //是shell最后运行的后台Process的PID$@ //是传给脚本的所有参数的列表$* //是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个$$ //是脚本运行的当前进程ID号$? //是显示上条命令的退出状态，0表示没有错误，其他表示有错误 123456789bash内建环境变量，这些变量不能当作自定义变量使用PATHSHELLUIDHISTSIZEHOMEPWDHISTFILEPS1","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Shell学习01：创建和执行脚本文件","date":"2019-06-18T07:51:38.418Z","path":"20190618/shell-learning-01-creating-and-executing-script-files.html","text":"新建Shell脚本进入一个你想要放脚本文件的目录。执行 12345678# 直接新建脚本文件并进入编辑vim ShellTest.sh # 或者# 先新建脚本文件，再进入编辑页面touch ShellTest.sh vim ShellTest.sh 在脚本文件编辑页面中放入 12#!/bin/bashecho &quot;Hello World !&quot; #! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。一般默认使用Bash进行脚本执行。 echo 命令用于向窗口输出文本。 执行Shell脚本作为可执行程序在root用户下新建文件时，文件的默认权限为 -rw-r–r–，即文件在root用户下可读写，其他用户只能读不能写，但是所有用户都无法执行。因此执行命令 1chmod +x ShellTest.sh 将脚本文件变为可执行文件，执行后的权限为 -rwxr-xr-x ，即所有用户都可执行。然后执行 1./ShellTest.sh 控制台输出 “Hello World !”，脚本执行成功。 ./ 表示执行本文件所在目录下的某一文件 作为解释器参数这种运行方式直接运行解释器，把 shell 脚本的文件名作为解释器的参数，如： 1/bin/sh ShellTest.sh 这种方式运行的脚本，不需要在第一行指定解释器信息，也不需要将脚本文件的权限转为可执行，只要作为参数的脚本文件的路径没错就行。","tags":[{"name":"Shell","slug":"Shell","permalink":"http://www.duanmuxu.top/tags/Shell/"}]},{"title":"Storm学习02：八种grouping分组策略","date":"2019-06-11T08:24:43.140Z","path":"20190611/storm-learning-02-eight-grouping-strategies.html","text":"简述为拓扑中的每个 Bolt 的确定输入数据流是定义一个拓扑的重要环节。数据流分组定义了在 Bolt 的不同任务（tasks）中划分数据流的方式。 在 Storm 中有八种内置的数据流分组方式，而且还可以通过 CustomStreamGrouping接口实现自定义的数据流分组模型。（所以总共可以算是九种分组方式） 具体分组这八种分组分时分别为： Shuffle grouping：随机分组。这种方式下元组会被尽可能随机地分配到Bolt的不同任务（tasks）中，使得每个任务所处理元组数量能够保持基本一致，以确保集群的负载均衡。 Fields grouping：按字段分组。这种方式下数据流根据定义的Field来进行分组。比如，如果某个数据流是基于一个名为“user-id”的字段进行分组的，那么所有包含相同的“user-id”的tuple都会被分配到同一个任务中，这样就可以确保消息处理的一致性。 Partial Key grouping：部分关键字分组。这种方式与Fields grouping很相似，根据定义的域来对数据流进行分组，不同的是，这种方式会考虑下游Bolt数据处理的均衡性问题，在输入数据源关键字不平衡时会有更好的性能。 All grouping：完全分组。这种方式下数据流会被同时发送到Bolt的所有任务中（也就是说同一个元组会被复制多份然后被所有的任务处理），使用这种分组方式要特别小心。 Global grouping：全局分组。这种方式下所有的数据流都会被发送到 Bolt 的同一个任务中，也就是id最小的那个任务。 None grouping：无分组。使用这种方式说明你不关心数据流如何分组。目前这种方式的结果与随机分组完全等效，不过未来Storm社区可能会考虑通过非分组方式来让 Bolt 和它所订阅的 Spout 或 Bolt 在同一个线程中执行。 Direct grouping：直接分组。这是一种特殊的分组方式。使用这种方式意味着元组的发送者可以指定下游的哪个任务可以接收这个元组。只有在数据流被声明为直接数据流时才能够使用直接分组方式。使用直接数据流发送元组需要使用OutputCollector的其中一个emitDirect方法。Bolt可以通过TopologyContext来获取它的下游消费者的任务id，也可以通过跟踪OutputCollector的emit方法（该方法会返回它所发送元组的目标任务的id）的数据来获取任务 id。 Local or shuffle grouping：本地或随机分组。如果目标bolt有一个或者多个task与源bolt的task在同一个工作进程中，tuple将会被随机发送给这些同进程中的tasks。否则，和普通的Shuffle Grouping行为一致。 其中Shuffle grouping、Fields grouping、All grouping、Global grouping四种策略用得较多。 实例拿最简单的WordCount来做例子： 新建wordcount项目新建RandomSentenceSpout类来产生数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.topo;import org.apache.storm.spout.SpoutOutputCollector;import org.apache.storm.task.TopologyContext;import org.apache.storm.topology.OutputFieldsDeclarer;import org.apache.storm.topology.base.BaseRichSpout;import org.apache.storm.tuple.Fields;import org.apache.storm.tuple.Values;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Map;import java.util.Random;public class RandomSentenceSpout extends BaseRichSpout &#123; private static final long serialVersionUID = 6102239192526611945L; private static final Logger LOGGER = LoggerFactory.getLogger(RandomSentenceSpout.class); private SpoutOutputCollector collector; private Random random; /** * 当一个Task被初始化的时候会调用此open方法, * 一般都会在此方法中对发送Tuple的对象SpoutOutputCollector和配置对象TopologyContext初始化 */ public void open(Map conf, TopologyContext context, SpoutOutputCollector collector) &#123; this.collector = collector; this.random = new Random(); &#125; /** * 这个spout类，之前说过，最终会运行在task中，某个worker进程的某个executor线程内部的某个task中 * 那个task会负责去不断的无限循环调用nextTuple()方法 * 只要的话呢，无限循环调用，可以不断发射最新的数据出去，形成一个数据流 */ public void nextTuple() &#123; String[] sentences = new String[]&#123; &quot;I used to watch her from my kitchen widow&quot; , &quot;she seemed so small as she muscled her way through the crowd of boys on the playground&quot; , &quot;The school was across the street from our home and I would often watch the kids as they played during recess&quot; , &quot;A sea of children, and yet tome&quot; , &quot;she stood out from them all&quot;&#125;; String sentence = sentences[random.nextInt(sentences.length)]; LOGGER.info(&quot; --- 发射 sentence 数据 ---&gt; &#123;&#125;&quot;, sentence); // 这个values，你可以认为就是构建一个tuple,tuple是最小的数据单位，无限个tuple组成的流就是一个stream,通过 emit 发送数据到下游bolt tuple this.collector.emit(new Values(sentence)); &#125; /** * 用于声明当前Spout的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的 * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key */ public void declareOutputFields(OutputFieldsDeclarer declarer) &#123; declarer.declare(new Fields(&quot;sentence&quot;)); &#125;&#125; 新建SplitSentenceBolt类用来切割单词1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.topo;import org.apache.storm.task.OutputCollector;import org.apache.storm.task.TopologyContext;import org.apache.storm.topology.OutputFieldsDeclarer;import org.apache.storm.topology.base.BaseRichBolt;import org.apache.storm.tuple.Fields;import org.apache.storm.tuple.Tuple;import org.apache.storm.tuple.Values;import java.util.Map;public class SplitSentenceBolt extends BaseRichBolt &#123; private static final long serialVersionUID = -4758047349803579486L; private OutputCollector collector; /** * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法 * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化 */ public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123; this.collector = collector; &#125; /** * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的 * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行 * 切分单词 */ public void execute(Tuple input) &#123; // 接收上游数据 String sentence = input.getStringByField(&quot;sentence&quot;); String[] words = sentence.split(&quot; &quot;); for(String word : words)&#123; //发射数据 this.collector.emit(new Values(word)); &#125; &#125; /** * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的 * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key * 定义发射出去的tuple，每个field的名称 */ public void declareOutputFields(OutputFieldsDeclarer declarer) &#123; declarer.declare(new Fields(&quot;word&quot;)); &#125;&#125; 新建WordCountBolt类用来单词计数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.topo;import org.apache.storm.shade.com.google.common.collect.Maps;import org.apache.storm.task.OutputCollector;import org.apache.storm.task.TopologyContext;import org.apache.storm.topology.OutputFieldsDeclarer;import org.apache.storm.topology.base.BaseRichBolt;import org.apache.storm.tuple.Fields;import org.apache.storm.tuple.Tuple;import org.apache.storm.tuple.Values;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Map;public class WordCountBolt extends BaseRichBolt &#123; private static final Logger LOGGER = LoggerFactory.getLogger(WordCountBolt.class); private static final long serialVersionUID = -7114915627898482737L; private OutputCollector collector; Map&lt;String,Long&gt; countMap = Maps.newConcurrentMap(); /** * 当一个Task被初始化的时候会调用此prepare方法,对于bolt来说，第一个方法，就是prepare方法 * OutputCollector，这个也是Bolt的这个tuple的发射器,一般都会在此方法中对发送Tuple的对象OutputCollector初始化 */ public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) &#123; this.collector = collector; &#125; /** * 这是Bolt中最关键的一个方法，对于Tuple的处理都可以放到此方法中进行。具体的发送也是通过emit方法来完成的 * 就是说，每次接收到一条数据后，就会交给这个executor方法来执行 * 统计单词 */ public void execute(Tuple input) &#123; // 接收上游数据 String word = input.getStringByField(&quot;word&quot;); Long count = countMap.get(word); if(null == count)&#123; count = 0L; &#125; count ++; countMap.put(word, count); LOGGER.info(&quot; --- 单词计数[&#123;&#125;] ---&gt; 出现的次数：&#123;&#125;&quot;, word, count); //发射数据 this.collector.emit(new Values(word,count)); &#125; /** * 用于声明当前bolt的Tuple发送流的域名字。Stream流的定义是通过OutputFieldsDeclare.declareStream方法完成的 * 通俗点说法：就是这个方法是定义一个你发射出去的每个tuple中的每个field的名称是什么，作为下游 bolt 中 execute 接收数据 key * 定义发射出去的tuple，每个field的名称 */ public void declareOutputFields(OutputFieldsDeclarer declarer) &#123; declarer.declare(new Fields(&quot;word&quot;,&quot;count&quot;)); &#125;&#125; 新建WordCountTopology类用来链接Spout和Bolt，执行主程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.topo;import org.apache.storm.Config;import org.apache.storm.LocalCluster;import org.apache.storm.StormSubmitter;import org.apache.storm.topology.TopologyBuilder;import org.apache.storm.utils.Utils;public class WordCountTopology &#123; public static void main(String[] args) &#123; //去将spout和bolts组合起来，构建成一个拓扑 TopologyBuilder builder = new TopologyBuilder(); // 第一个参数的意思，就是给这个spout设置一个名字 // 第二个参数的意思，就是创建一个spout的对象 // 第三个参数的意思，就是设置spout的executor有几个 builder.setSpout(&quot;RandomSentence&quot;, new RandomSentenceSpout(), 2); builder.setBolt(&quot;SplitSentence&quot;, new SplitSentenceBolt(), 5) //为bolt 设置 几个task .setNumTasks(10) //设置流分组策略 .shuffleGrouping(&quot;RandomSentence&quot;); // fieldsGrouping 这个很重要，就是说，相同的单词，从SplitSentenceSpout发射出来时，一定会进入到下游的指定的同一个task中 // 只有这样子，才能准确的统计出每个单词的数量 // 比如你有个单词，hello，下游task1接收到3个hello，task2接收到2个hello // 通过fieldsGrouping 可以将 5个hello，全都进入一个task builder.setBolt(&quot;wordCount&quot;, new WordCountBolt(), 10) //为bolt 设置 几个task .setNumTasks(20) //设置流分组策略 .shuffleGrouping(&quot;SplitSentence&quot;); //.globalGrouping(&quot;SplitSentence&quot;); //.allGrouping(&quot;SplitSentence&quot;); //.fieldsGrouping(&quot;SplitSentence&quot;, new Fields(&quot;word&quot;)); // 运行配置项 Config config = new Config(); //说明是在命令行执行，打算提交到storm集群上去 if(args != null &amp;&amp; args.length &gt; 0)&#123; /** * 要想提高storm的并行度可以从三个方面来改造 * worker(进程)&gt;executor(线程)&gt;task(实例) * 增加work进程，增加executor线程，增加task实例 * 对应 supervisor.slots.port 中配置个数 * 这里可以动态设置使用个数 * 最好一台机器上的一个topology只使用一个worker,主要原因时减少了worker之间的数据传输 * * 注意：如果worker使用完的话再提交topology就不会执行，因为没有可用的worker，只能处于等待状态，把之前运行的topology停止一个之后这个就会继续执行了 */ config.setNumWorkers(3); try &#123; // 将Topolog提交集群 StormSubmitter.submitTopology(args[0], config, builder.createTopology()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;else&#123; // 用本地模式运行1个拓扑时，用来限制生成的线程的数量 config.setMaxTaskParallelism(20); // 将Topolog提交本地集群 LocalCluster cluster = new LocalCluster(); cluster.submitTopology(&quot;wordCountTopology&quot;, config, builder.createTopology()); // 为了测试模拟等待 Utils.sleep(60000); // 执行完毕，关闭cluster cluster.shutdown(); &#125; &#125;&#125; 运行结果shuffleGrouping运行结果 shuffleGrouping运行结果 随机分组，不自觉间做到了负载均衡。 globalGrouping运行结果 globalGrouping运行结果 只往一个里面发,发送到id最小的那个任务。 allGrouping运行结果 allGrouping运行结果 两个spot并行 所有都分发。 fieldsGrouping运行结果 fieldsGrouping运行结果 相同的名称的fields分发到一个bolt里面。","tags":[{"name":"大数据","slug":"大数据","permalink":"http://www.duanmuxu.top/tags/大数据/"},{"name":"Storm","slug":"Storm","permalink":"http://www.duanmuxu.top/tags/Storm/"}]},{"title":"Ambari集群搭建（HDP离线安装版）","date":"2019-06-04T10:57:20.241Z","path":"20190604/ambari-cluster-setup-hdp-offline-installation.html","text":"安装环境部署使用版本 Ubuntu：ubuntu-16.04.6-server-amd64 Ambari：ambari-2.5.0.3-ubuntu16 HDP：HDP-2.6.0.3-ubuntu16 HDP-UTILS：HDP-UTILS-1.1.0.21-ubuntu16 设置每台主机的host首先修改每一台主机的hostname输入命令： 1vim /etc/hostname 命名随意，不重复就行。 输入命令： 1vim /etc/hosts 进入hosts编辑页面每台主机host的配置都要相同 1234# 127.0.0.1 localhost ambari01192.168.2.93 ambari01192.168.2.94 ambari02192.168.2.95 ambari03 ip地址后的名称与hostname中的名称相同 修改完后ping其他不同的主机，看能不能ping通 链接Xshell安装Ubuntu的时候，勾选安装OpenSSH，系统打开后就能直接使用ssh服务了。 登录每台主机，输入命令： 1vim /etc/ssh/sshd_config 将该文件下的 PermitRootLogin的值改为 yes 输入以下命令重启一下SSH服务： 1/etc/init.d/ssh restart 重启成功后就能使用xShell连接虚拟机进行操作了。 免密登录从机首先在主机上运行 sudo ssh-keygen ，然后一路回车，生成本机公私密钥。 注意要一路回车，不用输入任何字符。 然后执行以下命令： 123ssh-copy-id root@ambari01ssh-copy-id root@ambari02ssh-copy-id root@ambari03 注意也要对自己本机也操作一次，不然后面在ambari服务器上安装组件的时候本机会显示permision denied 的情况。 执行以上命令时，会依次提示输入每台从机的root密码，然后主机就会自动将公钥发送给各个从机的机器中并立即生效。 执行后可以通过执行ssh root@ambari02 进行测试，可以直接登陆从机，无需密码。 保存主机的私钥复制一份刚才主机生成的私钥，后面ambari搭建集群的时候会需要用到，密钥的文件位于 /root/.ssh/id_rsa，执行以下命令： 1cp /root/.ssh/id_rsa /root 将密钥复制到root文件目录下，然后通过xftp将文件下载到Windows本地。因为xftp不能直接访问.ssh目录。 安装yum和ntp每个从机、主机都需要安装yum、ntp，否则后面Ambari部署有些会不通过。 12apt-get install yumapt-get install ntp python版本 &gt; 2.6一般Ubuntu默认都会安装python2.7，此条可以忽略。 准备工作完毕。下面开始集群的搭建。 下载HDP与HDP-UTILS离线安装包前面一个安装包大约5.9G，如果选择在线安装则太费时间，因此下载已经编译好的HDP安装包进行离线安装。 首先进入 https://docs.hortonworks.com/ 找到ambari，选择自己想要的版本。本文使用的是Ambari-2.5.0.3版本。选择好版本后，找到Apache Ambari Installation ，点击进入后，通过点击 Getting Ready -&gt; Using a Local Repository -&gt; Obtaining the Repositories -&gt; HDP Stack Repositories 找到HDP离线版下载，我使用的版本为 HDP-2.6.0.3，具体网址为下： 1https://docs.hortonworks.com/HDPDocuments/Ambari-2.5.0.3/bk_ambari-installation/content/hdp_26_repositories.html 然后就是漫长的下载之路了，一共6G左右，记住要选择对应的Ambari和虚拟机版本。下载HDP和HDP-UTILS两个文件。 安装 AmbariAmbari只需要在主机上安装，而后安装组件时其他从机会自动部署。 继续在刚才的网站上，找到 Download the Ambari Repository，选择对应的虚拟机版本，然后按照官方手册指引，root用户登录主机后依次执行以下三句命令即可完成安装源的配置。 123wget -O /etc/apt/sources.list.d/ambari.list http://public-repo-1.hortonworks.com/ambari/ubuntu16/2.x/updates/2.5.0.3/ambari.listapt-key adv --recv-keys --keyserver keyserver.ubuntu.com B9733A7A07513CADapt-get update 要注意ambari版本的问题，不要版本不一致。 具体操作可以查看官方操作手册。 然后进行ambari-server 的安装 1apt-get install ambari-server 一共七百多MB，大概安装个二十分钟左右，视网速而定。 配置 Ambari执行命令 1ambari-server setup 进行配置ambari-server，一路回车进行配置，途中会安装JDK，选择JDK1.8继续安装。 中途也会遇到选择安装数据库，默认选择安装MySQL，继续安装。 ambari的用户名和密码如果不进行设置则默认都为admin。 安装好后将JDK1.8安装包发送给每个从机，都将JDK1.8安装一遍。 启动 Ambari操作手册上如是说： 12345678- Run the following command on the Ambari Server host:ambari-server start- To check the Ambari Server processes:ambari-server status- To stop the Ambari Server:ambari-server stop 执行 ambari-server start ，稍候片刻启动服务。然后进入网址 http://&lt;主机IP&gt;:8080 就可以进入Ambari的登录界面。账号密码如果刚才没有配置，则均为admin。 部署HDP离线安装包安装Nignx也不一定是要nignx，只要能提供Http服务，来作为HDP离线包的下载服务器就行。 主机上运行： 1apt-get install nignx 安装完成后浏览器进入 http://&lt;主机IP&gt;:80 查看是否有Nignx欢迎页面。 上传HDP离线安装包使用xftp进行文件传输，xftp连接主机后进入 /var/www/html 目录，将HDP-UTILS-1.1.0.21-ubuntu16.tar.gz和HDP-2.6.0.3-ubuntu16-deb.tar.gz两个文件传到该目录下。 在linux终端下新建文件夹HDP-UTILS-1.1.0.21，将压缩包HDP-2.6.0.3-ubuntu16-deb.tar.gz直接解压，将压缩包HDP-UTILS-1.1.0.21-ubuntu16.tar.gz解压到新建的文件夹HDP-UTILS-1.1.0.21下 执行以下命令将默认的欢迎页面重命名： 1mv /var/www/html/index.nginx-debian.html /var/www/html/index.nginx-debian.html.bak 进入nignx的配置页面 1vim /etc/nginx/sites-enabled/default 在 server{…} 里添加一句 autoindex on; 即打开目录浏览功能。 以上步骤做完后，再次访问 http://&lt;主机IP&gt;:80 时，能看到目录结构，同时能找到HDP以及HDP-UTILS，能够从页面上下载，HDP离线安装包就配置好了。 开始创建集群 进入 http://&lt;主机IP&gt;:8080 Ambari登录页面，账号密码均为admin； ambari登录界面 登陆后选择Launch Install Wizard； 在这里插入图片描述 命名你的集群，好听点就行； 下一步，选择本地Repository，选择对应的虚拟机版本，链接填刚才配置好的Nignx的服务器路径址，即http://&lt;主机IP&gt;/HDP/ubuntu16/ 和 http://&lt;主机IP&gt;/HDP-UTILS-1.1.0.21/； 在这里插入图片描述 进入install options，输入集群机器的ip，选择之前下载到本地的id_rsa文件。点击Register and confirm 进入下一步； 在这里插入图片描述 confirm host 之后，进行选择服务，即要安装的大数据组件，进行安装 进行到Customize Services时可能会让你进行一些密码的设置，比如hive组件之类的，设置好不报错后继续安装； 在这里插入图片描述 安装成功即完成部署。 在这里插入图片描述 完结撒花！ 在这里插入图片描述 参考文章：如何优雅地使用Apache Ambari安装HDFS、HBase等分布式应用","tags":[{"name":"大数据","slug":"大数据","permalink":"http://www.duanmuxu.top/tags/大数据/"},{"name":"Ambari","slug":"Ambari","permalink":"http://www.duanmuxu.top/tags/Ambari/"}]},{"title":"罗马数字转化为阿拉伯数字","date":"2019-06-02T04:28:32.282Z","path":"20190602/roman-numerals-are-converted-to-arabic.html","text":"题目简述： Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. 简而言之，从I到M七个字母分别代表着1~1000的七种不同大小。当所给罗马数字的字母顺序为从M到I的顺序排列时，它的值即为其字母所代表的值相加，比如’XXVII’，即表示X+X+V+I+I。当所给罗马数字字符串中有一个字母比这个字母其后的字母所表示的值小时，这两个字母结合起来代表一个数值，其值为（后一个字母的值-前一个字母的值），比如’MCD’，C的值比D小，因此等于M+CD=1000+500-100=1400。 解题思路其实经过分析过后思路就很明确了，比较所给字符串中当前字母和下一个字母的数值大小，如果当前字母的值比下一个字母的值大，直接相加，反之则后一个字母的值减去当前字母的值，并将这两个字母当作一个整体。 有了思路，就得有解题方法。既然是涉及到前后两个字母进行比较，那么就有两种情况，一种是获取当前字母的值，与后一个字母进行比较；一种是保存前一个字母的值，与当前字母的值进行比较。 当前字母与前一个字母相比较1234567891011121314151617181920212223class Solution &#123; public int romanToInt(String s) &#123; int[] a = new int[26]; a[&apos;I&apos; - &apos;A&apos;] = 1; a[&apos;V&apos; - &apos;A&apos;] = 5; a[&apos;X&apos; - &apos;A&apos;] = 10; a[&apos;L&apos; - &apos;A&apos;] = 50; a[&apos;C&apos; - &apos;A&apos;] = 100; a[&apos;D&apos; - &apos;A&apos;] = 500; a[&apos;M&apos; - &apos;A&apos;] = 1000; int sum = 0; char prev = &apos;A&apos;; for (char str : s.toCharArray()) &#123; if(a[str - &apos;A&apos;] &gt; a[prev - &apos;A&apos;])&#123; sum = sum - 2*a[prev - &apos;A&apos;]; &#125; sum = sum + a[str - &apos;A&apos;]; prev = str; &#125; return sum; &#125;&#125; 这种方法foreach中，当前值为str，保存的前一个字母为prev。当当前字母的值大于前一个字母的值时，整体总数sum减去前一个字母的值的两倍（一倍拿来消除之前加过的前一个字母的值，一倍拿来做整体两个字母的减数）。从而得出结果。 当前字母与后一个字母相比较12345678910111213141516171819202122class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;Character, Integer&gt; chara = new HashMap&lt;&gt;(); chara.put(&apos;I&apos;, 1); chara.put(&apos;V&apos;, 5); chara.put(&apos;X&apos;, 10); chara.put(&apos;L&apos;, 50); chara.put(&apos;C&apos;, 100); chara.put(&apos;D&apos;, 500); chara.put(&apos;M&apos;, 1000); int sum = 0; //定义总数 for(int i = 0; i &lt; s.length(); i++)&#123; if(i &lt; s.length()-1 &amp;&amp; chara.get(s.charAt(i)) &lt; chara.get(s.charAt(i+1)))&#123; sum = sum - chara.get(s.charAt(i)); &#125;else&#123; sum = sum + chara.get(s.charAt(i)); &#125; &#125; return sum; &#125;&#125; 使用Map进行存储，当时使用数组也可以，只是为了存储多元化。这种方法要注意charAt的界限，防止越界。当当前的字母的值大于下一个字母的值时，正常相加；反之则总数sum减去当前字母的值。 有一点值得注意的是if的条件中有个i &lt; s.length()-1，即为了防止越界我们作比较只比较到了字符串的倒数第二个字母，最后一个字母的值是直接相加的。因为最后一个字母无需与其后的字母相比较，因此此种方法可行。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.duanmuxu.top/tags/leetcode/"}]},{"title":"两个字符串中含有几个相同字符的几种解法","date":"2019-06-02T04:28:32.281Z","path":"20190602/several-solutions-for-identical-characters-in-two-strings.html","text":"最近为了暑期实习面试开始复习数据结构与算法，作为一个大三的软件工程的学生，在大三下学期才开始接触算法练习平台，真够不好意思的。进入正题，题目如下： You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”.Example 1:Input: J = “aA”, S = “aAAbbbb”Output: 3Example 2:Input: J = “z”, S = “ZZ”Output: 0Note:S and J will consist of letters and have length at most 50.The characters in J are distinct. 简单理解就是给定两个字符串J和S，S字符串中有多少个字母是J字符串中的字母，并且要区分大小写。 以下方法全是基于Java进行实现 先放我的方法： 方法一：将字符串转化成数组1234567891011121314class Solution &#123; public int numJewelsInStones(String J, String S) &#123; char[] Ja = J.toCharArray(); char[] Sa = S.toCharArray(); int r = 0; for (int i = 0;i &lt; Ja.length ; i ++)&#123; for(int j = 0; j &lt; Sa.length; j++)&#123; if(Ja[i] == Sa[j]) r ++; &#125; &#125; return r; &#125;&#125; 先将J和S字符串转化成两个数组 对J的数组进行遍历，再对S的数组进行遍历 如果J中的字母与S中的字母相等（区分大小写），累加器r就加一 最后输出r即可 &nbsp;&nbsp;&nbsp;&nbsp;很简单的一道题，当时想着继续刷题吧，反正刷题网站的意义就在于刷刷刷。不过还好打开了这道题的评论区，让我看到了一个新的世界。评论里有着许许多多其他不同的解题方法。这才是刷题网站的意义，**给一道题以不同的解题思路，让每个人都能有多种不同的思考。** &nbsp;&nbsp;&nbsp;&nbsp;以下是本道题评论区中给出的其他解题方法，亲测有效 方法二：字符串直接进行比较12345678910111213class Solution &#123; public int numJewelsInStones(String J, String S)&#123; int count=0; for (int i=0;i&lt;J.length();i++)&#123; for (int j=0;j&lt;S.length();j++)&#123; if (S.charAt(j) == J.charAt(i))&#123; count+=1; &#125; &#125; &#125; return count; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;其实和方法一差不大多，直接对字符串进行循环比较。最开始我也想用这方法，不过忘了charAt方法，不能确定字符串某个位置上的字母，于是换成了方法一。&nbsp;&nbsp;&nbsp;&nbsp;另一种直接比较方法 1234567891011class Solution &#123; public int numJewelsInStones(String J, String S) &#123; int count =0; for (int i =0;i&lt;S.length();i++)&#123; if (J.contains(String.valueOf(S.charAt(i))))&#123; count++; &#125; &#125; return count; &#125;&#125; 也是循环比较，少了层for循环而已，不再赘述。 方法三：正则表达式123public int numJewelsInStones(String J, String S) &#123; return S.replaceAll(&quot;[^&quot; + J + &quot;]&quot;, &quot;&quot;).length();&#125; 太狠了，这方法太狠了，一行解决事情。先介绍一下什么是正则表达式： 正则表达式是对字符串（包括普通字符（例如，a到z之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，模式描述在搜索文本时要匹配的一个或多个字符串。 判断S字符串中有多少能被J字符串所替换的字符，将这些字符的长度输出就是答案。太狠了。不过这种方法时间会占用更多。 方法四：Hash Set方法123456789101112class Solution &#123; public int numJewelsInStones(String J, String S) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (char c : J.toCharArray()) set.add(c); int res = 0; for (char c : S.toCharArray()) if (set.contains(c)) res++; return res; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;Hash Set就是用来提高查找效率的，将J字符串中的字母放在set中，判断S字符串中的字母知否包含在set中，是则累加器res加一，最后输出。这种方法运行效率也高。 问：为什么不是将S字符串的字符存入set中？答：Hash Set不能存入相同的元素。以例子一为例，S字符串为：S = “aAAbbbb”，”A”有两个，”b”有四个，最后存入set后，set的长度为3，即存入元素为”a”,”A,”b”，因为字符串直接存入set里时，相同元素的HashCode是一样的，就会跳过重复的字符。这时与J字符串相比较，就只有”a”,”A”相匹配，输出结果为2，答案错误。 方法五：ASCII值转换123456789public int numJewelsInStones(String J, String S) &#123; int count = 0; int[] arr = new int[&apos;z&apos; - &apos;A&apos; + 1]; for (char c : J.toCharArray()) arr[c - &apos;A&apos;] = 1; for (char c : S.toCharArray()) count += arr[c - &apos;A&apos;]; return count;&#125; &nbsp;&nbsp;&nbsp;&nbsp;创建一个arr数组，大小为A的ASCII的值（65）到z的ASCII的值（122）的范围，中间有些特殊字符也占用了空间，不过没关系，不碍事。然后将J字符串中的字符也转成ASCII值，并将以该字符的ASCII值（与A相减过后的值，不然会溢出）为角标的数组值设为1，再对S字符串进行循环，累加器count一直与角标为S串中的字符的ASCII值的arr数组的值相加，最后结果输出即可。也是一种转换思维。 方法六：Hash Map方法1234567891011public int numJewelsInStones(String J, String S) &#123; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int count = 0; for(char s : S.toCharArray()) map.put(s, map.getOrDefault(s, 0) + 1); for(int i = 0; i &lt; J.length(); i++) count += map.getOrDefault(J.charAt(i), 0); return count; &#125; HashSet方法更简洁，详情参见方法四。 暂时放这一些方法，有看到新的再更新，继续学习！","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"},{"name":"字符串","slug":"字符串","permalink":"http://www.duanmuxu.top/tags/字符串/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.duanmuxu.top/tags/leetcode/"}]},{"title":"链表中倒数第k个结点","date":"2019-06-02T04:28:32.279Z","path":"20190602/the-kth-node-in-list.html","text":"题目描述： 输入一个链表，输出该链表中倒数第k个结点。 链表结构如下： 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 由链表结构就能知道由此基础建立的链表不能直接知道该链表的长度，需要通过node = node.next 一步一步遍历链表才能获取链表长度。 因此最先想到的方法就是先遍历一遍链表，获取链表长度，然后通过链表长度和k数值的差得出目标地址。实现方法如下： 1234567891011121314151617181920public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode newHead = head, pre = head; int count = 0; // 获取链表长度 while(pre != null)&#123; count++; pre = pre.next; &#125; if(count &lt; k) // 不存在倒数第k个链表 return null; else&#123; int num = count - k; // num为正数的目的地址，与倒数第k个链表值一致 while(num &gt; 0)&#123; newHead = newHead.next; num--; &#125; return newHead; &#125; &#125;&#125; 有了基础思路，下一步就是简化代码，用更简洁的表达将效果呈现出来。以下使用for循环： 12345678910111213public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; //5,&#123;1,2,3,4,5&#125; ListNode p, q; p = q = head; int i = 0; for (; p != null; i++) &#123; if (i &gt;= k) q = q.next; p = p.next; // p相当于上面的pre链表，用于测量链表长度 &#125; return i &lt;= k ? null : q; &#125;&#125; 也可以使用while一次遍历： 1234567891011121314151617181920212223242526public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; ListNode pre=null,p=null; //两个指针都指向头结点 p=head; pre=head; //记录k值 int a=k; //记录节点的个数 int count=0; //p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑， //当p指针跑到最后时，pre所指指针就是倒数第k个节点 while(p!=null)&#123; p=p.next; count++; if(k&lt;1)&#123; pre=pre.next; &#125; k--; &#125; //如果节点个数小于所求的倒数第k个节点，则返回空 if(count&lt;a) return null; return pre; &#125;&#125; 其实思路是一致的，就是通过得到链表长度，再得到n-k位置的链表值。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.duanmuxu.top/tags/leetcode/"}]},{"title":"括号匹配消除","date":"2019-06-02T04:28:32.278Z","path":"20190602/bracket-matching-elimination.html","text":"题目描述： Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. input : ()[]{}output : true input : ({[]})output : true input : ({)}output : false 简单得说就是括号相匹配，同一个类型的括号连在一起。同一对括号可以嵌套在其他括号中，但只能一对括号都嵌套进去（如（{}）），不能只嵌套一边的括号（如（{）}）。 有看过二叉树的前中后序遍历进行加减乘除操作的应该一看到这一题就知道怎么做了。运算中有有括号的先算括号中的数的原则，那么就需要对运算中的括号进行识别与约束，与这道题一个道理。因此一看到这道题就应该想到可以用栈去求解。解法如下： 使用栈(Stack)的解法1234567891011121314151617181920212223class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (Character chara:s.toCharArray()) &#123; if (chara == &apos;(&apos; || chara == &apos;[&apos; || chara == &apos;&#123;&apos;) stack.push(chara); else &#123; if (stack.isEmpty())&#123; return false; &#125;else &#123; Character charPop = stack.pop(); if (charPop == &apos;(&apos; &amp;&amp; chara != &apos;)&apos; || charPop == &apos;[&apos; &amp;&amp; chara != &apos;]&apos; || charPop == &apos;&#123;&apos; &amp;&amp; chara != &apos;&#125;&apos;)&#123; return false; &#125; &#125; &#125; &#125; if (stack.isEmpty()) return true; else return false; &#125;&#125; 思路：所给字符串第一个字符必为”(“,”[“,”{“中的一种，如果不是，那必然无法必配成功，return false。按字符串顺序识别字符将字符串push进栈中。当字符为”)”,”]”,”}”中的一种时，pop一个字符与上面三种字符向匹配，如果匹配成功，继续执行程序，匹配成功的括号自动消除。反之return false，说明这个“右”括号的前面一个括号也是“右”括号，即前面一个括号无法匹配成功。最后判断这个栈是否为空，如果全部都匹配消除完成，栈为空。 优化后的使用栈的方法1234567891011121314public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c : s.toCharArray()) &#123; if (c == &apos;(&apos;) stack.push(&apos;)&apos;); else if (c == &apos;&#123;&apos;) stack.push(&apos;&#125;&apos;); else if (c == &apos;[&apos;) stack.push(&apos;]&apos;); else if (stack.isEmpty() || stack.pop() != c) return false; &#125; return stack.isEmpty();&#125; 太简洁了！！！ 字符如果是“左”括号，那么栈中保存相应的“右”括号。字符如果是“右”括号，与pop出的值相比，如果不相等则说明前一个括号不是相对应的“左”括号，即无法匹配，return false。 除了上面用栈的方法外，还有一种值替换法，实现如下： 目标值替换法123456789101112public class Solution &#123; public boolean isValid(String s) &#123; int length; do &#123; length = s.length(); s = s.replace(&quot;()&quot;, &quot;&quot;).replace(&quot;&#123;&#125;&quot;, &quot;&quot;).replace(&quot;[]&quot;, &quot;&quot;); &#125; while(length != s.length()); return s.length() == 0; &#125;&#125; 思路：暴力替换目标值，符合一整对括号的值直接替换成空值，以替换前的字符串长度和替换后的字符串长度作比较条件，建立循环。最后判断字符串长度是否为零，即整对括号是否被替换完全。 还有Map的方法： 使用Key-Value匹配进行求解123456789101112131415161718public boolean isValid(String s) &#123; char[] chars = s.toCharArray(); Map&lt;Character,Character&gt; pairs = new HashMap&lt;Character,Character&gt;(); pairs.put(&apos;(&apos;, &apos;)&apos;); pairs.put(&apos;&#123;&apos;, &apos;&#125;&apos;); pairs.put(&apos;[&apos;, &apos;]&apos;); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (char c:chars) &#123; if (pairs.containsKey(c)) &#123; stack.push(pairs.get(c)); &#125; else &#123; if (stack.isEmpty() || c != stack.pop()) return false; &#125; &#125; return stack.isEmpty();&#125; 思路：将“左”括号作为key，“右”括号作为值放在Map中，其他思路与优化后的使用栈的方法一致。 无论是用栈还是数组还是Hash Map，都只是一种工具，最主要的是思路，有了思路就有了目标，各种存储方法只是帮助达到目标的工具罢了。（当然，有些工具是独轮车，有些工具是飞机哈哈哈哈哈哈哈）","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://www.duanmuxu.top/tags/leetcode/"}]},{"title":"反转链表","date":"2019-06-02T04:28:32.276Z","path":"20190602/reverse-list.html","text":"题目描述 输入一个链表，反转链表后，输出新链表的表头。 最开始的思路是保存链表中的每一个值到一个数组中，然后逆序输出到新链表中，暴力反转链表。实现如下： 123456789101112131415161718192021222324class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;(); ListNode cur = head; ListNode pre, result = new ListNode(0); pre = result; if(head == null)&#123; return result; &#125; while(cur != null)&#123; //循环读取链表数值，存在array链表中 array.add(cur.val); cur = cur.next; &#125; for(int i = array.size() - 1; i &gt;=0; i--)&#123; pre = new ListNode(array.get(i)); pre = pre.next; &#125; return result.next; &#125;&#125; 想法很美好，现实很骨感。运行时报出如下错误： Exception in thread “main” java.lang.NullPointerException 咋肥事，还会有空指针报错？马上Debug，发现一个漏洞。 最开始定义了ListNode pre, result两个新链表，pre用于循环，每次增加新的next节点，因为每次pre.next = new ListNode(num)时，pre.val会赋予新的值，不能成为一条完整的逆序链表，因此定义了result链表来与pre每次添加的值相等，因为result = pre，因此两个内存地址相等，也就是result每次会以链表形式添加pre所添加的新元素，从而达到逆序操作。 不过问题就出在pre = new ListNode(array.get(i));这上，每次new一个值时，pre的内存地址就改变一次，但是result的内存地址不会变，因此result不会与pre产生联系，也就是最后return result的时候，result的值在最开始定义result时就已经确定了，与后续pre的操作无关，因此无法得到反转链表的目的。 所以上述代码是些辣鸡。那就换个思路吧，直接从链表本身入手。实现如下： 123456789101112131415public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; ListNode pre = null; ListNode next = null; while(head!=null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125;&#125; 啥意思呢，pre表示所给链表的前一个节点，next表示所给链表的下一个节点。代码解释如下: next = head.next 表示next保存head的下一个节点，保证head.next不会丢失； head.next = pre 表示head指向了pre,也就是head从后指向前； pre = head 表示pre现在已经是在next前面的数值中，由后指向前的一个链表； head = next 表示head找回原先的head的下一节点，也就是第一步中被next保存的节点； 继续以上操作，直至head遍历完成，此时pre也反转完成。 举个栗子最直观： 输入链表 1-&gt;2-&gt;3-&gt;4-&gt;5 next = head.next = 2-&gt;3-&gt;4-&gt;5 head.next = pre =null pre = head = 1 head = next = 2-&gt;3-&gt;4-&gt;5 —新一轮循环— next = head.next = 3-&gt;4-&gt;5 head.next = pre = 1 （此时head.val = 2，因此head 表示2-&gt;1） pre = head = 2-&gt;1 （达到反转的目的） head = next = 3-&gt;4-&gt;5 —新一轮循环— …… head = null pre = 5-&gt;4-&gt;3-&gt;2-&gt;1 输出链表 5-&gt;4-&gt;3-&gt;2-&gt;1 任务完成，值得品味。","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.duanmuxu.top/tags/剑指Offer/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"}]},{"title":"对所有员工的薪水按照salary进行按照1-N的排名","date":"2019-06-02T04:28:32.273Z","path":"20190602/salary-for-all-employees-is-ranked-according-to-1n-in.html","text":"题目描述 对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列 建表语句： 123456CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`)); 输出描述： emp_no salary rank 10005 94692 1 10002 94409 2 10010 94409 2 10001 88958 3 10007 88958 3 10004 74057 4 不看最后一个rank排名，那么这道题特别简单： 1234select s.emp_no, s.salaryfrom salaries swhere s.to_date = &apos;9999-01-01&apos;order by s.salary desc, s.emp_no asc 但是题目偏偏加了一个rank工资排名。那么怎样才能获得这个排名呢？ 在Java中我们可以直接使用循环来给目标值加排名，SQL查询语句中看来行不通。仅仅使用一张表似乎达不到目的，那就使用两张表吧。 既然不能使用循环，那么可以通过什么方法来表示排名，或者说是表示在自己的前面还有多少人（包括自己）。 很明显了，我们可以通过两张表中salary的大小不同来获取在自己前面的人的个数，即s1.salary &lt;= s2.salary。举个栗子：有三个salary（6000，5000，4000， 4000），输出为s1.salary，那么当s1.salary = 6000时，s1.salary &lt;= s2.salary 的值为6000，也就是一个，当s1.salary = 5000时，s1.salary &lt;= s2.salary 的值为6000和5000两个。但是当s1.salary = 4000时，s1.salary &lt;= s2.salary 的值就为（6000，5000，4000， 4000）四个，且4000是重复的，因此我们使用count(distinct s2.salary) rank 来去重，并计算个数，即排名，以此类推，输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary就是s1.salary的排名 当然不要忘了group by s1.emp_no ，用来将员工编号分组，计算count() 最后结果为： 12345select s1.emp_no, s1.salary, count(distinct s2.salary) rankfrom salaries s1, salaries s2where s1.salary &lt;= s2.salary and s1.to_date = &apos;9999-01-01&apos; and s2.to_date = &apos;9999-01-01&apos;group by s1.emp_noorder by rank","tags":[{"name":"数据库","slug":"数据库","permalink":"http://www.duanmuxu.top/tags/数据库/"}]},{"title":"单向链表小记","date":"2019-06-02T04:28:32.272Z","path":"20190602/oneway-linked-list.html","text":"什么是链表？链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 什么是单向链表？单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。（其实就是上一篇中提到的ListNode） 单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。 单向链表的具体实现这边放上练习用的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package LinkedList;import java.util.LinkedList;public class SingleLinkedList &#123; private int size; private Node head; public SingleLinkedList() &#123; size = 0; head = null; &#125; private class Node&#123; private Object data;//每个节点的数据 private Node next; //每个节点指向下一个节点的连接 public Node(Object data) &#123; this.data = data; &#125; &#125; //在链表头添加元素 public Object addhead(Object obj) &#123; Node newHead = new Node(obj); if(size == 0) head = newHead; else &#123; newHead.next = head; head = newHead; &#125; size++; return obj; &#125; //在链表头删除元素 public Object deleteHead() &#123; Object obj = head.data; head = head.next; size--; return obj; &#125; //查找指定元素，找到了返回节点Node，找不到返回null public Node find(Object obj) &#123; Node current = head; int tempSize = size; while(tempSize &gt; 0)&#123; if(obj.equals(current.data))&#123; return current; &#125;else&#123; current = current.next; &#125; tempSize--; &#125; return null; &#125; //删除指定的元素，删除成功返回true public boolean delete(Object value)&#123; if(size == 0)&#123; return false; &#125; Node current = head; Node previous = head; while(current.data != value)&#123; if(current.next == null)&#123; return false; &#125;else&#123; previous = current; current = current.next; &#125; &#125; //如果删除的节点是第一个节点 if(current == head)&#123; head = current.next; size--; &#125;else&#123;//删除的节点不是第一个节点 previous.next = current.next; size--; &#125; return true; &#125; //判断链表是否为空 public boolean isEmpty() &#123; return (size == 0); &#125; //在链表尾部添加元素 public Object addTail(Object obj) &#123; Node newTail = new Node(obj); Node current = head; int temSize = size; while (temSize &gt; 0) &#123; if (current.next == null) &#123; //需要先增加链表的容量，才能进行添加 size++; current.next = newTail; newTail.next = null; return current; &#125;else &#123; current = current.next; &#125; temSize--; &#125; return obj; &#125; //显示节点信息 public void display() &#123; if (size &gt; 0) &#123; Node node = head; int tempSize = size; if (tempSize == 1) &#123; System.out.print(&quot;[&quot; + node.data + &quot;]&quot;); &#125; while (tempSize &gt; 0) &#123; if (node.equals(head)) &#123; System.out.print(&quot;[&quot; + node.data + &quot;-&gt;&quot;); &#125;else if (node.next == null) &#123; System.out.print(node.data+&quot;]&quot;); &#125;else &#123; System.out.print(node.data+&quot;-&gt;&quot;); &#125; node = node.next; tempSize--; &#125; System.out.println(); &#125;else &#123; System.out.println(&quot;[]&quot;); &#125; &#125;&#125; 测试源码： 123456789101112131415161718public static void main(String[] args) &#123; // TODO Auto-generated method stub SingleLinkedList sLinkedList = new SingleLinkedList(); sLinkedList.addhead(&quot;A&quot;); sLinkedList.addhead(&quot;B&quot;); sLinkedList.addhead(&quot;C&quot;); sLinkedList.addhead(&quot;D&quot;); sLinkedList.display(); sLinkedList.addTail(&quot;O&quot;); sLinkedList.display(); sLinkedList.deleteHead(); sLinkedList.display(); sLinkedList.delete(&quot;B&quot;); sLinkedList.display(); &#125; 测试结果： 1234[D-&gt;C-&gt;B-&gt;A][D-&gt;C-&gt;B-&gt;A-&gt;O][C-&gt;B-&gt;A-&gt;O][C-&gt;A-&gt;O] 这边注意一个地方，addTail()是往链表的末尾添加一个元素，在进行判断current.next == null 后，要先将整体链表的size + 1，不要将size + 1放在循环外进行,才能够使current.next = newTail,否则将无法添加成功，因为容量不够。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"}]},{"title":"StringBuffer 替换字符串中的空格","date":"2019-06-02T04:28:32.269Z","path":"20190602/stringbuffer-replaces-spaces-in-strings.html","text":"题目描述： 1234567将一个字符串中的空格替换成 &quot;%20&quot;。Input:&quot;A B&quot;Output:&quot;A%20B&quot; 解法一：将String Buffer转换为String类型，再进行操作1234567public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String str1 = str.toString(); str1 = str1.replace(&quot; &quot;,&quot;%20&quot;); return str1; &#125;&#125; 特别简单，不过好像不是出题者的原意 解法二：先填充字符串再进行遍历替换 解题思路：在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。 12345678910111213141516171819public String replaceSpace(StringBuffer str) &#123; int P1 = str.length() - 1; for (int i = 0; i &lt;= P1; i++) if (str.charAt(i) == &apos; &apos;) str.append(&quot; &quot;); int P2 = str.length() - 1; while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123; char c = str.charAt(P1--); if (c == &apos; &apos;) &#123; str.setCharAt(P2--, &apos;0&apos;); str.setCharAt(P2--, &apos;2&apos;); str.setCharAt(P2--, &apos;%&apos;); &#125; else &#123; str.setCharAt(P2--, c); &#125; &#125; return str.toString();&#125;","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.duanmuxu.top/tags/剑指Offer/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"},{"name":"字符串","slug":"字符串","permalink":"http://www.duanmuxu.top/tags/字符串/"}]},{"title":"Single Number 找出数组中的单一数字","date":"2019-06-02T04:28:32.252Z","path":"20190602/single-number-find-a-in-the-array.html","text":"题目描述： Given a non-empty array of integers, every element appears twice except for one. Find that single one.给定一个非空的整数数组，除了一个元素外，每个元素都会出现两次。找出那个单一的整数。 最常规的思路就是进行循环，统计出现的数字，只出现一次的就是我们要的答案了 for循环统计数字出现次数123456789101112131415161718192021222324class Solution &#123; public int singleNumber(int[] nums) &#123; int[] result = new int[nums.length]; int count = 0; for (int i = 0;i &lt; nums.length; i++)&#123; for (int j = 0;j &lt;= count;j++)&#123; if (j == count)&#123; result[j] = -1; count++; j = count +1; &#125;else if (nums[i] == nums[j])&#123; result[j]++; count++; j = count + 1; &#125; &#125; &#125; for (int k = 0; k &lt; result.length ;k++)&#123; if (result[k] == -1) return nums[k]; &#125; return 0; &#125;&#125; 新建一个result数组用来存放统计的次数，初始值为-1，进行双重循环，以后每找到一个与nums数组中相同的数字，就在result数组中+1，即值变为0。最后根据result中值为-1（即在nums数组中没找到相同数值的数字）的数字就是我们要找的数字。 这种方法逻辑很顺，但是时间复杂度为O(n^2)，运行时间会消费很多。那么要降低时间复杂度，就得减少一层循环。怎么才能实现呢？既要实现统计次数，又要遍历数组，有应用过Map Reducer方法的同学应该很容易就能想到word count程序好像就是这么一个道理，因此我们可以使用Map进行存值判断。 Map实现123456789101112131415161718class Solution &#123; public int singleNumber(int[] nums) &#123; HashMap&lt;Integer, Integer&gt; result = new HashMap&lt;&gt;(); int resultNum = 0; for(int i = 0; i &lt; nums.length; i++)&#123; int num = nums[i]; if(result.containsKey(num))&#123; result.remove(num); &#125;else&#123; result.put(num, i); &#125; &#125; for (int res : result.keySet()) &#123; resultNum = res; &#125; return resultNum; &#125;&#125; 因为nums数组中的重复数字只有两个，因此判断数字是否已经存在于Map中，若已经存在，则remove该数字，此时Map和nums数组中都已不存在该数字，若Map中不存在该数字，则put该数字。最后Map只剩下单一的数字，即我们想要的结果。 Map中需要插入key-value两个值，但是value的值对我们没有什么帮助，因此可以使用HashSet进一步优化。 HashSet实现1234567891011class Solution &#123; public int singleNumber(int[] nums) &#123; HashSet&lt;Integer&gt; result = new HashSet&lt;&gt;(); for (int num : nums) &#123; if(!result.add(num)) result.remove(num); &#125; Iterator&lt;Integer&gt; it = result.iterator(); return it.next(); &#125;&#125; 判断nums中的数字是否已经存在与HashSet中，若已经存在，则remove，若不存在，则直接add。这步与Map类似，不过只需要插入一个nums数组中的值就够了。 上面都是常规的一些存储方法，可没想到还有一个更加简洁帅气的方法。就是使用异或 ^ 的方法。 XOR异或方法123456789class Solution &#123; public int singleNumber(int[] nums) &#123; int result = 0; for (int num : nums) &#123; result = result ^ num; &#125; return result; &#125;&#125; 什么意思呢，^ 异或满足下面的转化： a b result 0 0 0 0 1 1 1 0 1 1 1 0 所以两个数字进行 ^ 运算时，先将数字转化为二进制，再进行 ^ 操作，当两个数字相同时，则对应的二进制数的位数也都相同，因此运算结果为0。当0与任意数字进行异或运算时，运算结果为该任意数字，因此最终的结果就是nums数组中出现的单一数字。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"}]},{"title":"PAT乙级真题—福尔摩斯的约会","date":"2019-06-02T04:28:32.251Z","path":"20190602/pat-b-level-question-sherlock-holmess-date.html","text":"题目描述 大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入描述: 输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。 输出描述: 在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。 输入例子: 3485djDkxh4hhGE2984akDfkkkkggEdsbs&amp;hgsfdkd&amp;Hyscvnm 输出例子: THU 14:04 这边注意几点，如果前两个输入中出现连续相同的字母怎么办？如果代表小时的相同字母/数字出现得比代表日期的相同字母要早怎么办？如果后两个输入中有多组相同的字母怎么办？输出中碰到个位数的小时/分钟时前面不带”0”（输出不规范）怎么办？ 这些都不是问题，下面贴出通过的代码，并且有详细注释。可能会显得有些冗长，但是看起来一目了然，毫无难度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import java.util.Scanner;public class Holmes &#123; //定义日期 private static char[] day = &#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;&#125;; //定义当天的小时 private static char[] hour =&#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;&#125;; public static void main(String[] args)&#123; //循环读取四个输入 Scanner scanner = new Scanner(System.in); while (scanner.hasNext())&#123; //获取四个字符串 String str1 = scanner.nextLine(); String str2 = scanner.nextLine(); String str3 = scanner.nextLine(); String str4 = scanner.nextLine(); //判断前两个字符串哪一个最短 int daytime = shortest(str1, str2); boolean isDay = true;//判断相同的字母是否是代表“天” String result = &quot;&quot;;//结果字符串 int sum = 0; //前两个字符串中相同字母/数字的个数 for (int i = 0; i &lt; daytime; i++)&#123; if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInDay(str1.toCharArray()[i]) &amp;&amp; isDay)&#123; result += getDay(str1.toCharArray()[i]); /** * isDay有两个作用： * 一是防止下一次有字母出现时将字母当作成“天”的字母； * 二是供else if 中做判断，防止识别时间在识别周几之前 */ isDay = false; sum++; &#125;else if (str1.toCharArray()[i] == str2.toCharArray()[i] &amp;&amp; isInHour(str1.toCharArray()[i]) &amp;&amp; !isDay )&#123; //输出规范化，防止出现输出为 “THU 2:12”的情况 if (getHour(str1.toCharArray()[i]) &lt; 10)&#123; result += &quot; 0&quot;+ getHour(str1.toCharArray()[i]); sum++; &#125;else &#123; result += &quot; &quot;+ getHour(str1.toCharArray()[i]); sum++; &#125; &#125; //防止已经识别周几和小时之后还有相同又符合判断条件的字母出现 if (sum == 2) break; &#125; //获取str3，str4中最小的字符串长度 int minute = shortest(str3, str4); for (int i = 0; i &lt; minute ; i++)&#123; if (str3.toCharArray()[i] == str4.toCharArray()[i] &amp;&amp; isEnglishChar(str3.toCharArray()[i]))&#123; //输出规范化，与上同 if (i &lt; 10 ) &#123; result += &quot;:0&quot; + i; break; //有相同的字母直接退出for循环 &#125;else &#123; result += &quot;:&quot; + i; break; &#125; &#125; &#125; //输出 System.out.println(result); &#125; &#125; /** * 返回两个字符串长度最小的字符串长度 * @param str1 * @param str2 * @return */ public static int shortest(String str1, String str2)&#123; return str1.length() &lt; str2.length() ? str1.length() : str2.length(); &#125; /*** * 判断输入字符是否存在与day的数组中 * @param character * @return */ public static boolean isInDay(Character character)&#123; for (int i = 0; i &lt; day.length; i++)&#123; if (character == day[i]) return true; &#125; return false; &#125; /** * 判断输入字符是否存在与hour数组中 * @param character * @return */ public static boolean isInHour(Character character)&#123; for (int i = 0; i &lt; hour.length; i++)&#123; if (character == hour[i]) return true; &#125; return false; &#125; /** * 根据输入字符获取星期几的简写 * @param dayChar * @return */ public static String getDay(Character dayChar)&#123; switch (dayChar)&#123; case &apos;A&apos;: return &quot;MON&quot;; case &apos;B&apos;: return &quot;TUE&quot;; case &apos;C&apos;: return &quot;WED&quot;; case &apos;D&apos;: return &quot;THU&quot;; case &apos;E&apos;: return &quot;FRI&quot;; case &apos;F&apos;: return &quot;SAT&quot;; case &apos;G&apos;: return &quot;SUN&quot;; &#125; return &quot;Not Found This Day&quot;; &#125; /** * 根据输入字符获取小时时间 * @param hourChar * @return */ public static int getHour(Character hourChar)&#123; for (int i = 0; i &lt; hour.length; i++)&#123; if (hourChar == hour[i]) return i; &#125; return -1; &#125; /** * 判断输入字符是否是一个英文字母（包含大小写） * @param engChar * @return */ public static boolean isEnglishChar(Character engChar)&#123; if (engChar &gt;= &apos;a&apos; &amp;&amp; engChar &lt;= &apos;z&apos;) return true; else if(engChar &gt;= &apos;A&apos; &amp;&amp; engChar &lt;= &apos;Z&apos;) return true; else return false; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"},{"name":"PAT","slug":"PAT","permalink":"http://www.duanmuxu.top/tags/PAT/"}]},{"title":"往微信图文中插入外链视频的方法（包含几种失败方法）","date":"2019-06-02T04:28:32.249Z","path":"20190602/how-to-insert-an-external-video-into-a-wechat-graphic-including-several-failure-methods.html","text":"几种不同方法最常见方法我们平时转发图文时，往往转发的图文中会带有视频，一般的解决方法就是在浏览器中打开腾讯视频，找到原图文中的原视频，然后进行分享复制链接， 在这里插入图片描述 再把链接复制粘贴到后台视频链接的地方就会有视频显示出来 再点击确定就可以在图文中看见插入的视频了。但是！！前几天在进行转发一篇图文中的视频时我发现了一个新的问题，有些视频点击分享时无法复制视频地址链接，怎么整都不行！所以我先试了以下方法，但都无法实现！为了不让大家走弯路，我先把我用过的行不通的方法列出来。 失败方法一：下载视频上传后台 该视频只有 57 秒，不足 20M（微信公众号后台要求上传的视频大小要小于20M），那我就下载腾讯视频客户端，再下载原视频，然后把视频上传到后台就行了呗，但是问题又出现了，腾讯视频的下载格式是qlv，公众号后台不支持该格式的视频。 不过问题不大，将原视频进行格式转换成 MP4，再上传到后台，还是美滋滋，但是问题又来了，格式工厂无法支持该格式，无法进行转换，那就从网上找吧，可是市面上的格式转换器（对我使用过的而言）转换后的 MP4 格式上传到后台后，公众号后台却无法解码， 因此视频还是无法成功上传，这条路，卒。 利用windows 系统命令行对视频缓存的合成及转换我们每次在浏览器或是客户端进行视频查看时，系统会自动生成缓存保存在电脑中，下次查看视频时就会方便很多，因此我们先找到电脑本地视频缓存区， 腾讯视频将一整段完整的视频进行分段缓存，还都是ts的文件，这个格式第一次见，问题不大，打开 cmd 命令行，使用 copy/b 命令进行分段视频的合成和转换， 合成并转换后的视频文件 视频转换成功，美滋滋。可是问题又来了，点击打开只能在腾讯视频进行播放，其他视频软件出现解码错误（又是解码错误！！） 而且腾讯视频里只有音频，没有视频图像，这条路，卒。 检查网页元素进行视频捕捉和保存知乎上的一个方法，利用浏览器播放视频，检查网页元素进行视频捕捉和保存 如何下载网页上的视频？ - 习惯秋落的回答 - 知乎 有兴趣的可以根据里面详细的介绍试一试 当我开开心心地进行视频保存时，却发现保存的视频格式是ts 文件 在这里插入图片描述 又是ts文件！！！这条路，卒。 手机端UC浏览器进行视频保存平时我们用手机 UC 浏览器进行看视频时，右上角会有一个下载视频的图标，我们可以进行视频下载，一般来说是 MP4 格式，但是前两天我在试验的时候那个图标不见了，我也就没有去深究。 成功方法查找浏览器视频元素既然团中央学校部的图文中可以播放该视频，那这篇图文的信息中肯定有该视频的信息，所以重点来啦，下面都是要记笔记的地方！首先在浏览器中打开我们要转发的图文，我用的是谷歌浏览器，也建议大家使用。 浏览器打开图文 然后打开网页检查元素，一种方法是右击鼠标，选择检查即可，另一种方法是 shift+ctrl+I快捷键进入检查 进入检查页面 点击右边框框中的 element 元素 在这里插入图片描述 键入 ctrl+F 进行元素检索 进行检索 搜索 v.qq.com,因为这个是所有腾讯视频链接中所包含的特定元素 在这里插入图片描述 此时网页自动找到页面中的视频元素（左半边），以及该视频的链接地址（右半边中的黄色部分所在区域），然后呢，我们有了该视频链接的总地址，此时我们复制 src=…后的部分，从 v.qq.com 一直到 false 在这里插入图片描述 然后将我们复制的这段链接再粘贴到后台 在这里插入图片描述 以上就是从原图文找原视频链接地址的方法，十分简便，为什么我之前会试那么多复杂的方法！！ 当然如果腾讯视频可以直接复制视频地址链接，那就不要整这些花里胡哨的。","tags":[{"name":"新媒体","slug":"新媒体","permalink":"http://www.duanmuxu.top/tags/新媒体/"},{"name":"视频","slug":"视频","permalink":"http://www.duanmuxu.top/tags/视频/"}]},{"title":"使用MultipleOutputs方法将mapreduce分组输出","date":"2019-06-02T04:28:32.247Z","path":"20190602/mapreduce-group-output-using-the-multipleoutputs-method.html","text":"MapReduce是我们再进行离线大数据处理的时候经常要使用的计算模型，MapReduce的计算过程被封装的很好，我们只用通过使用Map和Reduce函数，再定义输入输出就能得到我们想要的结果。不过一般Map Reduce的输出只包含一个可视化输出文件（如下图part-r-00000文件），那么我们如果需要将这一个输出文件分为多个输出文件该怎么办呢？ 一个输出 这里就用到了MR框架中的MultipleOutputs函数（MultipleOutputs是2.0之后的新API，是对老版本中MultipleOutputs与MultipleOutputFormat的一个整合）。先来看段完整代码熟悉一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class dateFormat &#123; static class MyMapper extends Mapper&lt;LongWritable,Text,Text,Text&gt;&#123; @Override protected void map(LongWritable key, Text value,Context context)throws IOException, InterruptedException &#123; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd-HH-mm-ss&quot;); String time = simpleDateFormat.format(new Date()); String line = value.toString().trim(); for (int i =0; i&lt; line.length(); i++)&#123; char newChar = line.charAt(i); context.write(new Text(time), new Text(String.valueOf(newChar))); &#125; &#125; &#125; static class MyReducer extends Reducer&lt;Text,Text,Text,Text&gt;&#123; private MultipleOutputs&lt;Text, Text&gt; multipleOutputs; protected void setup(Context context)&#123; multipleOutputs = new MultipleOutputs&lt;Text, Text&gt;(context); &#125; @Override protected void reduce(Text key, Iterable&lt;Text&gt; values,Context context)throws IOException, InterruptedException &#123; for (Text value : values) &#123; multipleOutputs.write((Text) null, value, key.toString()); &#125; &#125; protected void cleanup(Context context) throws IOException, InterruptedException&#123; multipleOutputs.close(); &#125; &#125; public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf); job.setJarByClass(dateFormat.class); job.setJobName(&quot;MultipleOutputTest&quot;); job.setMapperClass(MyMapper.class); job.setReducerClass(MyReducer.class); job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Text.class); job.setOutputKeyClass(NullWritable.class); job.setOutputValueClass(Text.class);// MultipleOutputs.addNamedOutput(job, TextOutputFormat.class, NullWritable.class, Text.class); FileInputFormat.setInputPaths(job, new Path(args[0])); Path outPath = new Path(args[1]); FileSystem fs = FileSystem.get(conf); if(fs.exists(outPath)) &#123; fs.delete(outPath, true); &#125; FileOutputFormat.setOutputPath(job, outPath); job.waitForCompletion(true); &#125;&#125; multipleOutputs.write的输出规范如下：multipleOutputs.write((namedOutput,) key, value, baseOutputPath)这里需要注意的一点在是map中的输出值会作为reduce中输出文件的文件命名（map.key-r-00000），即baseOutputPath的值确定了分组输出文件的命名规范。 namedOutput为可选项，为当前输出Job的名称，如果有多于一个multipleOutputs.write时，需指定namedOutput名称，并在Driver里添加 MultipleOutputs.addNamedOutput(job, “namedOutput” , TextOutputFormat.class, NullWritable.class, Text.class);作为作业的入口。 上述的代码段是我根据获取系统时间作为reducer的输入key值，命名时也根据map的执行时间进行命名，输出到同一文件夹之下，具体结果如下图： 分组输出到同一文件下 如果需要将这些文件分别输出到不同的文件夹下，那么只需要将 multipleOutputs.write((Text) null, value, key.toString());中的key.toString()改为key+”/“,即改为multipleOutputs.write((Text) null, value, key+”/“); 即可，输出结果如下： 分组输出到不同文件夹下","tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://www.duanmuxu.top/tags/Hadoop/"},{"name":"大数据","slug":"大数据","permalink":"http://www.duanmuxu.top/tags/大数据/"},{"name":"Map Reduce","slug":"Map-Reduce","permalink":"http://www.duanmuxu.top/tags/Map-Reduce/"}]},{"title":"只爱一点点","date":"2019-06-02T04:28:32.246Z","path":"20190602/just-love-a-little-bit.html","text":"不爱那么多，只爱一点点。别人的爱情像海深，我的爱情浅。不爱那么多，只爱一点点。别人的爱情像天长，我的爱情短。不爱那么多，只爱一点点。别人眉来又眼去，我只偷看你一眼。 在这里插入图片描述","tags":[{"name":"现代诗","slug":"现代诗","permalink":"http://www.duanmuxu.top/tags/现代诗/"}]},{"title":"Java实现从尾到头打印链表（ListNode）每个节点的值","date":"2019-06-02T04:28:32.243Z","path":"20190602/java-implementation-prints-the-value-of-each-node-from-end-to-linked-list-listnode.html","text":"进行做题之前，先来看看什么是ListNode。 ListNode是由自己定义的Java中的链表对象(其实也可以理解成C语言中的链表)。也就是在Java类库中没有这个类，需要自己定义。定义如下： 123456789public class ListNode&#123; int val; ListNode next; public ListNode(int x)&#123; val=x; &#125;&#125; val表示当前ListNode的值，next指向下一个ListNode。在进行ListNode初始化时必须传值，如下面main函数中进行初始化： 123456public static void main(String[] args) &#123; ListNode listNode = new ListNode(1); listNode.next = new ListNode(3); listNode.next.next = new ListNode(4); listNode.next.next.next = new ListNode(1); &#125; 此时生成链表：1-&gt;3-&gt;4-&gt;1 题目描述： 1输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 方法一：利用栈的思想一个链表从头到尾输入，要求输出的是从尾到头。符合栈先进后出的思想，因此可以用下面方法实现： 123456789101112131415 public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();while (listNode != null) &#123; stack.push(listNode.val); listNode = listNode.next;&#125;ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();while (!stack.isEmpty()) &#123; arrayList.add(stack.pop());&#125; return arrayList; &#125; 方法二：递归123456789public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); if (listNode != null) &#123; arrayList.addAll(printListFromTailToHead(listNode.next)); arrayList.add(listNode.val); &#125; return arrayList; &#125; 顺便说一下addAll()和all()的区别： add（）是将传入的的参数作为当前 List 中d的一个项目（Item）来存储，即使你传入一个 list 也只会另当前的List集合增加 1 个元素。addAll（）是传入一个List，将此前List集合中的所有元素加入到当前的 List 中，当前 List 集合会增加的元素个数是传入的 List 的大小。 方法三：头插法利用链表头插法为逆序的特点： 123456789101112131415161718public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); ListNode head = new ListNode(-1); while (listNode != null) &#123; ListNode q = listNode.next; listNode.next = head.next; head.next = listNode; listNode = q; &#125; head = head.next; while (head != null) &#123; arrayList.add(head.val); head = head.next; &#125; return arrayList;&#125; 方法四：链表翻转 利用函数： 1234567891011public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(listNode != null)&#123; list.add(listNode.val); listNode = listNode.next; &#125; Collections.reverse(list);//使用Collections的reverse方法，直接将list反转 return list;&#125; 强行进行逆序 123456789101112131415161718public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); if(listNode == null)&#123; return arr; &#125; while(listNode.next != null)&#123; arr.add(listNode.val); listNode = listNode.next; &#125; arr.add(listNode.val); int temp = 0; for(int inx=0, end=arr.size()-1; inx&lt;end; inx++, end--)&#123; temp = arr.get(inx); arr.set(inx, arr.get(end)); arr.set(end, temp); &#125; return arr;&#125;","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.duanmuxu.top/tags/剑指Offer/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"}]},{"title":"查找二叉树的下一个节点（中序遍历）","date":"2019-06-02T04:28:32.229Z","path":"20190602/find-the-next-node-of-binary-tree-middle-order-traversal.html","text":"首先我们先了解一下二叉树的三种遍历方法： 前序遍历：从根节点开始，根在前，从左往右，一棵树的根永远在左子树前面，左子树又永远在右子树前面； 中序遍历：从最左节点开始，根在中，从左往右，一棵树的左子树永远在根前面，根永远在右子树前面； 后序遍历：也是从最左节点开始，根在后，从左往右，一棵树的左子树永远在右子树前面，右子树永远在根前面。 比如下面一张图 image 前序遍历为：ABDGHECKFIJ 中序遍历为：GDHBEAKCIJF 后序遍历为：GHDEBKJIFCA 了解了二叉树的大致遍历方式，我们来看下题目： 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 通过中序遍历我们可以知道一个节点的下一个节点有两种情况： 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点，比如上图中C的后一个节点是I； 如果一个节点的右子树为空，那么向上找第一个左链接指向的树包含该节点的父节点。比如上图H的下一个节点是B。 接下来看代码实现： 12345678910111213// 定义一棵树public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125; 12345678910111213141516171819202122public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; //判断该节点是否存在右子节点 if(pNode.right != null)&#123; //如果有右子树，则找右子树的最左节点 TreeLinkNode rightNode = pNode.right; while(rightNode.left != null) rightNode = rightNode.left; return rightNode; &#125;else&#123; //没右子树，则找第一个当前节点是父节点左孩子的节点 while(pNode.next != null)&#123; TreeLinkNode parentNode = pNode.next; if(parentNode.left == pNode) return parentNode; pNode = pNode.next; &#125; &#125; return null; &#125;&#125;","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.duanmuxu.top/tags/剑指Offer/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"}]},{"title":"剑指Offer中关于斐波那契数列的分析和运用","date":"2019-06-02T04:28:32.227Z","path":"20190602/analysis-and-application-of-the-fibonacci-sequence-in-sword.html","text":"我们先来看一下什么是斐波那契数列，这个应该在大一高数时大家都学过。 斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n-1)+F(n-2)（n&gt;=3，n∈N*）——《百度百科》 具体函数表达参考下面这张图。 img 那么我们该如何求解与斐波那契数列相关的问题呢？先看一下题目描述： 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 具体可以用以下几种方法求解： 使用递归递归能将一个问题划分成多个子问题进行求解。求F(n)时会转化成求F(n-1)、F(n-2),以此类推，最后转化成几个F(0)、F(1)相加的结果。实现如下： 1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; int result = 0; if (n &lt;= 1)&#123; return n; &#125;else&#123; result = Fibonacci(n - 1) + Fibonacci(n - 2); &#125; return result; &#125;&#125; 运行时间与占用内存如下： img 可是使用递归会有一个问题，会重复计算一些子问题。比如计算F(5)需要计算F(4)和F(3)，计算F(4)需要计算F(3)和F(2)，可以看到F(3)被重复计算了。造成了资源浪费。 所以我们换个思路。 动态规划递归是将一个问题划分成多个子问题进行求解。动态规划相当于是个相反的过程，将子问题的解存储起来，用来解决大问题，比如已知F(0)、F(1)，进行求F(2)，再进一步求F(3)，以此类推，直至求到F(n)。这样子就不会有重复求解子问题的烦恼产生。实现如下： 123456789101112131415public class Solution &#123; public int Fibonacci(int n) &#123; if (n &lt;= 1)&#123; return n; &#125; int[] fib = new int[n+1]; fib[0] = 0; fib[1] = 1; for(int i = 2;i &lt; n + 1; i++)&#123; fib[i] = fib[i - 1] + fib[i - 2]; &#125; return fib[n]; &#125;&#125; 运行时间与占用内存如下： img 这么做比递归好很多，但是考虑到第i项只与第i-1和第i-2项有关，因此只需要存储前两项的值就能求解第i项，从而将空间复杂度由O(N)降低为O(1)。所以我们可以进一步优化。 动态规划的进一步优化使用两个值存储i-1和i-2，避免使用数组，浪费更多的空间。实现如下： 12345678910111213141516public class Solution &#123; public int Fibonacci(int n) &#123; if (n &lt;= 1)&#123; return n; &#125; int preOne = 1; //存储i-1 int preTwo = 0; //存储i-2 int result = 0; for(int i = 2;i &lt; n + 1; i++)&#123; result = preOne + preTwo; preTwo = preOne; preOne = result; &#125; return result; &#125;&#125; 运行时间与占用内存如下： img 接下来我们来看看剑指Offer中其他关于斐波那契数列的运用的题目： 题目一：跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 简单分析一下，就可以知道还是上面斐波那契数列的变化，青蛙跳1级台阶有1种跳法，2级台阶有2种跳法，3级台阶时可以从1级台阶跳上来也可以从2级台阶跳上来，即等于1级台阶的跳法加2级台阶的跳法因此n级台阶共有n-2级台阶跳法数+n-1级台阶跳法数。 实现如下： 12345678910111213141516public class Solution &#123; public int JumpFloor(int target) &#123; if(target &lt;= 2) return target; int preOne = 2; int preTwo = 1; int result = 0; for(int i = 3;i &lt; target+1 ;i++)&#123; result = preOne + preTwo; preTwo = preOne; preOne = result; &#125; return result; &#125;&#125; 题目二：变态跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法 上一题的升级版，跳n级台阶时可以允许跳1~n任意阶级的台阶。先来分析一下 跳n级台阶，那么第一步有n种跳法：跳1级、跳2级、到跳n级 跳1级，剩下n-1级，则剩下跳法是F(n-1)； 跳2级，剩下n-2级，则剩下跳法是F(n-2)； 所以F(n)=F(n-1)+F(n-2)+…+F(1)+1，最后的+1是因为直接跳n级台阶只有一种方法； 因为F(n-1)=F(n-2)+F(n-3)+…+F(1)+1; 以此类推，得F(n)=2*F(n-1)。 分析后变得比上面一提还要简单。实现如下： 123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; if(target &lt;= 2)&#123; return target; &#125; int preNum = 2; int result = 0; for(int i = 3;i &lt; target + 1;i++)&#123; result = 2 * preNum; preNum = result; &#125; return result; &#125;&#125; 题目三：矩阵覆盖 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 再来分析一下 首先从n=1开始，小矩阵只能竖着放，只有一种方法； n=2时，大矩阵为2 * 2，小矩阵既可以竖着放也可以横着放，有两种方法； 当n越来越大时，如果第一步选择竖着放，如下图： 第一步：竖着放 那么大矩阵的规模缩小成2 * (n-1)； 如果第一步选择竖着放，那么第二排也只能横着放，如下图： 第一步：横着放 那么大矩阵的规模缩小成2 * (n-2)； 因此，题目又转化成了与题目一一样的斐波那契数列了。实现如下： 12345678910111213141516public class Solution &#123; public int RectCover(int target) &#123; if(target &lt;= 2) return target; int preOne = 2; int preTwo = 1; int result = 0; for(int i = 3;i &lt; target+1 ;i++)&#123; result = preOne + preTwo; preTwo = preOne; preOne = result; &#125; return result; &#125;&#125; 以上就是关于斐波那契数列的含义和使用方式，题目一二三都是剑指Offer中的真题，示例中关于运行时间和占用内存是根据牛客网的测试用例得来的。","tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://www.duanmuxu.top/tags/剑指Offer/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.duanmuxu.top/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://www.duanmuxu.top/tags/算法/"}]},{"title":"Storm学习01：Storm简介","date":"2019-06-02T04:28:32.198Z","path":"20190602/storm-learning-01-introduction-to.html","text":"什么是StormApache Storm是Apache与基金会的开源的分布式实时计算系统。与Hadoop的批处理相类似，Storm可以对大量的数据流进行可靠的实时处理，这一过程也称为“流式处理”，是分布式大数据处理的一个重要方向。Storm支持多种类型的应用，包括：实时分析、在线机器学习、连续计算、分布式 RPC（ DRPC）、ETL等。Strom的一个重要特点就是“快速”的数据处理，有benchmark示显示Storm级能够达到单个节点每秒百万级tuple处理（tuple是Storm的最小数据单元）的速度。快速的数据是处理、优秀的可扩展性与容错性、便捷的可操作性与维护性、活跃的社区技术支持，这就是 Storm 。 Hadoop与Storm的比较相似之处 Hadoop Storm 系统角色 JobTracker Nimbus TaskTracker Supervisor Child Worker 应用名称 Job Topology 组件接口 Mapper/Reducer Spout/Bolt Nimbus：Nimbus在Storm中用于资源分配和作业调度，类比Hadoop中的Job Tracker Supervisor：Supervisor在Storm中用于接收Nimbus分配的任务，并且启动和停止用于完成这些任务对的Worker进程。Supervisor类比Hadoop中的TaskTracker Worker：运行Storm中具体组件逻辑的进程。这里的组件指的是Spout或者Bolt，对比Hadoop.x的Child进程。 Topology：Topology是Storm中运行的一个任务，类比Hadoop.x中的一个作业（Job） Spout：在一个Topology中产生源数据流的组件 Bolt：在一个Topology中接收数据，并进行逻辑处理的组件，称为Transformation 不同之处 Hadoop Storm 数据来源 Hadoop处理的是HDFS上TB级别的数据（历史数据） Storm处理的是实时新增的某一笔数据（实时数据） 处理过程 Hadoop是分Map阶段和Reduce阶段 Storm是由用户定义处理流程，流程中可以包含多个步骤，每个步骤可以是数据源（Spout）或处理逻辑（Bolt） 是否结束 Hadoop最后是要结束的 Storm没有结束状态，到最后一步时，就停在那，直到有新数据进入时再从头开始 处理速度 Hadoop是以处理HDFS上大量数据为目的的，处理速度慢 Storm是只要处理新增的某一笔数据即可，可以做到很快 适用场景 Hadoop是在要处理批量数据时用的，不讲究时效性 Storm是要处理某一新增数据时使用的，讲究时效性 ps：在Hadoop集群上运行MapReduce jobs，在Storm集群上运行topologies。jobs和topologies有很大的不同。一个关键区别是：一个Map Reduce jobs最终可以完成，而topologies处理过程将永远执行（除非Kill it） Storm组件 image Storm集群中包含两类节点：主控节点（Master Node）和工作节点（Work Node） 主控节点上运行着Nimbus，负责在Storm集群内分发代码，分配任务给工作机器，并且负责监控集群运行状态 工作节点上运行着Supervisor，负责监听从Nimbus分配给它执行的任务，据此启动或停止任务的工作进程。 每一个工作进程执行一个Topology的子集；一个运行中的Topology由分布在不同工作节点上的多个工作进程组成。 Nimbus 和和 Supervisor节点之间所有的协调工作是通过Zookeeper集群来实现的。此外，Nimbus 和Supervisor进程都是快速失败（fail-fast) 和 无状态（stateless） 的；Storm集群所有的状态要么在Zookeeper集群中，要么存储在本地磁盘上。这意味着我们可以用kill-9来杀死Nimbus和Supervisor进程，它们在重启后可以继续工作。这个设计使得Storm集群拥有极强的稳定性。","tags":[{"name":"大数据","slug":"大数据","permalink":"http://www.duanmuxu.top/tags/大数据/"},{"name":"Storm","slug":"Storm","permalink":"http://www.duanmuxu.top/tags/Storm/"}]}]